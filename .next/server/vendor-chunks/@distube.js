/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@distube";
exports.ids = ["vendor-chunks/@distube"];
exports.modules = {

/***/ "(rsc)/./node_modules/@distube/ytdl-core/lib/agent.js":
/*!******************************************************!*\
  !*** ./node_modules/@distube/ytdl-core/lib/agent.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("const { ProxyAgent } = __webpack_require__(/*! undici */ \"(rsc)/./node_modules/undici/index.js\");\nconst { HttpsProxyAgent } = __webpack_require__(/*! https-proxy-agent */ \"(rsc)/./node_modules/@distube/ytdl-core/node_modules/https-proxy-agent/dist/index.js\");\nconst { Cookie, CookieJar, canonicalDomain } = __webpack_require__(/*! tough-cookie */ \"(rsc)/./node_modules/tough-cookie/dist/cookie/index.js\");\nconst { CookieAgent, cookie } = __webpack_require__(/*! http-cookie-agent/undici */ \"(rsc)/./node_modules/http-cookie-agent/undici/index.js\");\n\nconst convertSameSite = sameSite => {\n  switch (sameSite) {\n    case \"strict\":\n      return \"strict\";\n    case \"lax\":\n      return \"lax\";\n    case \"no_restriction\":\n    case \"unspecified\":\n    default:\n      return \"none\";\n  }\n};\n\nconst convertCookie = cookie =>\n  cookie instanceof Cookie\n    ? cookie\n    : new Cookie({\n        key: cookie.name,\n        value: cookie.value,\n        expires: typeof cookie.expirationDate === \"number\" ? new Date(cookie.expirationDate * 1000) : \"Infinity\",\n        domain: canonicalDomain(cookie.domain),\n        path: cookie.path,\n        secure: cookie.secure,\n        httpOnly: cookie.httpOnly,\n        sameSite: convertSameSite(cookie.sameSite),\n        hostOnly: cookie.hostOnly,\n      });\n\nconst addCookies = (exports.addCookies = (jar, cookies) => {\n  if (!cookies || !Array.isArray(cookies)) {\n    throw new Error(\"cookies must be an array\");\n  }\n  if (!cookies.some(c => c.name === \"SOCS\")) {\n    cookies.push({\n      domain: \".youtube.com\",\n      hostOnly: false,\n      httpOnly: false,\n      name: \"SOCS\",\n      path: \"/\",\n      sameSite: \"lax\",\n      secure: true,\n      session: false,\n      value: \"CAI\",\n    });\n  }\n  for (const cookie of cookies) {\n    jar.setCookieSync(convertCookie(cookie), \"https://www.youtube.com\");\n  }\n});\n\nexports.addCookiesFromString = (jar, cookies) => {\n  if (!cookies || typeof cookies !== \"string\") {\n    throw new Error(\"cookies must be a string\");\n  }\n  return addCookies(\n    jar,\n    cookies\n      .split(\";\")\n      .map(c => Cookie.parse(c))\n      .filter(Boolean),\n  );\n};\n\nconst createAgent = (exports.createAgent = (cookies = [], opts = {}) => {\n  const options = Object.assign({}, opts);\n  if (!options.cookies) {\n    const jar = new CookieJar();\n    addCookies(jar, cookies);\n    options.cookies = { jar };\n  }\n  return {\n    dispatcher: new CookieAgent(options),\n    localAddress: options.localAddress,\n    jar: options.cookies.jar,\n  };\n});\n\nexports.createProxyAgent = (options, cookies = []) => {\n  if (!cookies) cookies = [];\n  if (typeof options === \"string\") options = { uri: options };\n  const jar = new CookieJar();\n  addCookies(jar, cookies);\n\n  // ProxyAgent type that node httplibrary supports\n  const agent = new HttpsProxyAgent(options.uri);\n\n  // ProxyAgent type that undici supports\n  const dispatcher = new ProxyAgent(options).compose(cookie({ jar }));\n\n  return { dispatcher, agent, jar, localAddress: options.localAddress };\n};\n\nexports.defaultAgent = createAgent();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGRpc3R1YmUveXRkbC1jb3JlL2xpYi9hZ2VudC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxRQUFRLGFBQWEsRUFBRSxtQkFBTyxDQUFDLG9EQUFRO0FBQ3ZDLFFBQVEsa0JBQWtCLEVBQUUsbUJBQU8sQ0FBQywrR0FBbUI7QUFDdkQsUUFBUSxxQ0FBcUMsRUFBRSxtQkFBTyxDQUFDLDRFQUFjO0FBQ3JFLFFBQVEsc0JBQXNCLEVBQUUsbUJBQU8sQ0FBQyx3RkFBMEI7O0FBRWxFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVAsb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixtQkFBbUIsMkJBQTJCO0FBQ25FLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCx3QkFBd0I7QUFDeEI7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsOERBQThELEtBQUs7O0FBRW5FLFdBQVc7QUFDWDs7QUFFQSxvQkFBb0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly95dC1kb3dubG9hZGVyLy4vbm9kZV9tb2R1bGVzL0BkaXN0dWJlL3l0ZGwtY29yZS9saWIvYWdlbnQuanM/ZWMzZCJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCB7IFByb3h5QWdlbnQgfSA9IHJlcXVpcmUoXCJ1bmRpY2lcIik7XG5jb25zdCB7IEh0dHBzUHJveHlBZ2VudCB9ID0gcmVxdWlyZShcImh0dHBzLXByb3h5LWFnZW50XCIpO1xuY29uc3QgeyBDb29raWUsIENvb2tpZUphciwgY2Fub25pY2FsRG9tYWluIH0gPSByZXF1aXJlKFwidG91Z2gtY29va2llXCIpO1xuY29uc3QgeyBDb29raWVBZ2VudCwgY29va2llIH0gPSByZXF1aXJlKFwiaHR0cC1jb29raWUtYWdlbnQvdW5kaWNpXCIpO1xuXG5jb25zdCBjb252ZXJ0U2FtZVNpdGUgPSBzYW1lU2l0ZSA9PiB7XG4gIHN3aXRjaCAoc2FtZVNpdGUpIHtcbiAgICBjYXNlIFwic3RyaWN0XCI6XG4gICAgICByZXR1cm4gXCJzdHJpY3RcIjtcbiAgICBjYXNlIFwibGF4XCI6XG4gICAgICByZXR1cm4gXCJsYXhcIjtcbiAgICBjYXNlIFwibm9fcmVzdHJpY3Rpb25cIjpcbiAgICBjYXNlIFwidW5zcGVjaWZpZWRcIjpcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIFwibm9uZVwiO1xuICB9XG59O1xuXG5jb25zdCBjb252ZXJ0Q29va2llID0gY29va2llID0+XG4gIGNvb2tpZSBpbnN0YW5jZW9mIENvb2tpZVxuICAgID8gY29va2llXG4gICAgOiBuZXcgQ29va2llKHtcbiAgICAgICAga2V5OiBjb29raWUubmFtZSxcbiAgICAgICAgdmFsdWU6IGNvb2tpZS52YWx1ZSxcbiAgICAgICAgZXhwaXJlczogdHlwZW9mIGNvb2tpZS5leHBpcmF0aW9uRGF0ZSA9PT0gXCJudW1iZXJcIiA/IG5ldyBEYXRlKGNvb2tpZS5leHBpcmF0aW9uRGF0ZSAqIDEwMDApIDogXCJJbmZpbml0eVwiLFxuICAgICAgICBkb21haW46IGNhbm9uaWNhbERvbWFpbihjb29raWUuZG9tYWluKSxcbiAgICAgICAgcGF0aDogY29va2llLnBhdGgsXG4gICAgICAgIHNlY3VyZTogY29va2llLnNlY3VyZSxcbiAgICAgICAgaHR0cE9ubHk6IGNvb2tpZS5odHRwT25seSxcbiAgICAgICAgc2FtZVNpdGU6IGNvbnZlcnRTYW1lU2l0ZShjb29raWUuc2FtZVNpdGUpLFxuICAgICAgICBob3N0T25seTogY29va2llLmhvc3RPbmx5LFxuICAgICAgfSk7XG5cbmNvbnN0IGFkZENvb2tpZXMgPSAoZXhwb3J0cy5hZGRDb29raWVzID0gKGphciwgY29va2llcykgPT4ge1xuICBpZiAoIWNvb2tpZXMgfHwgIUFycmF5LmlzQXJyYXkoY29va2llcykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJjb29raWVzIG11c3QgYmUgYW4gYXJyYXlcIik7XG4gIH1cbiAgaWYgKCFjb29raWVzLnNvbWUoYyA9PiBjLm5hbWUgPT09IFwiU09DU1wiKSkge1xuICAgIGNvb2tpZXMucHVzaCh7XG4gICAgICBkb21haW46IFwiLnlvdXR1YmUuY29tXCIsXG4gICAgICBob3N0T25seTogZmFsc2UsXG4gICAgICBodHRwT25seTogZmFsc2UsXG4gICAgICBuYW1lOiBcIlNPQ1NcIixcbiAgICAgIHBhdGg6IFwiL1wiLFxuICAgICAgc2FtZVNpdGU6IFwibGF4XCIsXG4gICAgICBzZWN1cmU6IHRydWUsXG4gICAgICBzZXNzaW9uOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBcIkNBSVwiLFxuICAgIH0pO1xuICB9XG4gIGZvciAoY29uc3QgY29va2llIG9mIGNvb2tpZXMpIHtcbiAgICBqYXIuc2V0Q29va2llU3luYyhjb252ZXJ0Q29va2llKGNvb2tpZSksIFwiaHR0cHM6Ly93d3cueW91dHViZS5jb21cIik7XG4gIH1cbn0pO1xuXG5leHBvcnRzLmFkZENvb2tpZXNGcm9tU3RyaW5nID0gKGphciwgY29va2llcykgPT4ge1xuICBpZiAoIWNvb2tpZXMgfHwgdHlwZW9mIGNvb2tpZXMgIT09IFwic3RyaW5nXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJjb29raWVzIG11c3QgYmUgYSBzdHJpbmdcIik7XG4gIH1cbiAgcmV0dXJuIGFkZENvb2tpZXMoXG4gICAgamFyLFxuICAgIGNvb2tpZXNcbiAgICAgIC5zcGxpdChcIjtcIilcbiAgICAgIC5tYXAoYyA9PiBDb29raWUucGFyc2UoYykpXG4gICAgICAuZmlsdGVyKEJvb2xlYW4pLFxuICApO1xufTtcblxuY29uc3QgY3JlYXRlQWdlbnQgPSAoZXhwb3J0cy5jcmVhdGVBZ2VudCA9IChjb29raWVzID0gW10sIG9wdHMgPSB7fSkgPT4ge1xuICBjb25zdCBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0cyk7XG4gIGlmICghb3B0aW9ucy5jb29raWVzKSB7XG4gICAgY29uc3QgamFyID0gbmV3IENvb2tpZUphcigpO1xuICAgIGFkZENvb2tpZXMoamFyLCBjb29raWVzKTtcbiAgICBvcHRpb25zLmNvb2tpZXMgPSB7IGphciB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgZGlzcGF0Y2hlcjogbmV3IENvb2tpZUFnZW50KG9wdGlvbnMpLFxuICAgIGxvY2FsQWRkcmVzczogb3B0aW9ucy5sb2NhbEFkZHJlc3MsXG4gICAgamFyOiBvcHRpb25zLmNvb2tpZXMuamFyLFxuICB9O1xufSk7XG5cbmV4cG9ydHMuY3JlYXRlUHJveHlBZ2VudCA9IChvcHRpb25zLCBjb29raWVzID0gW10pID0+IHtcbiAgaWYgKCFjb29raWVzKSBjb29raWVzID0gW107XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gXCJzdHJpbmdcIikgb3B0aW9ucyA9IHsgdXJpOiBvcHRpb25zIH07XG4gIGNvbnN0IGphciA9IG5ldyBDb29raWVKYXIoKTtcbiAgYWRkQ29va2llcyhqYXIsIGNvb2tpZXMpO1xuXG4gIC8vIFByb3h5QWdlbnQgdHlwZSB0aGF0IG5vZGUgaHR0cGxpYnJhcnkgc3VwcG9ydHNcbiAgY29uc3QgYWdlbnQgPSBuZXcgSHR0cHNQcm94eUFnZW50KG9wdGlvbnMudXJpKTtcblxuICAvLyBQcm94eUFnZW50IHR5cGUgdGhhdCB1bmRpY2kgc3VwcG9ydHNcbiAgY29uc3QgZGlzcGF0Y2hlciA9IG5ldyBQcm94eUFnZW50KG9wdGlvbnMpLmNvbXBvc2UoY29va2llKHsgamFyIH0pKTtcblxuICByZXR1cm4geyBkaXNwYXRjaGVyLCBhZ2VudCwgamFyLCBsb2NhbEFkZHJlc3M6IG9wdGlvbnMubG9jYWxBZGRyZXNzIH07XG59O1xuXG5leHBvcnRzLmRlZmF1bHRBZ2VudCA9IGNyZWF0ZUFnZW50KCk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@distube/ytdl-core/lib/agent.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@distube/ytdl-core/lib/cache.js":
/*!******************************************************!*\
  !*** ./node_modules/@distube/ytdl-core/lib/cache.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { setTimeout } = __webpack_require__(/*! timers */ \"timers\");\n\n// A cache that expires.\nmodule.exports = class Cache extends Map {\n  constructor(timeout = 1000) {\n    super();\n    this.timeout = timeout;\n  }\n  set(key, value) {\n    if (this.has(key)) {\n      clearTimeout(super.get(key).tid);\n    }\n    super.set(key, {\n      tid: setTimeout(this.delete.bind(this, key), this.timeout).unref(),\n      value,\n    });\n  }\n  get(key) {\n    let entry = super.get(key);\n    if (entry) {\n      return entry.value;\n    }\n    return null;\n  }\n  getOrSet(key, fn) {\n    if (this.has(key)) {\n      return this.get(key);\n    } else {\n      let value = fn();\n      this.set(key, value);\n      (async () => {\n        try {\n          await value;\n        } catch (err) {\n          this.delete(key);\n        }\n      })();\n      return value;\n    }\n  }\n  delete(key) {\n    let entry = super.get(key);\n    if (entry) {\n      clearTimeout(entry.tid);\n      super.delete(key);\n    }\n  }\n  clear() {\n    for (let entry of this.values()) {\n      clearTimeout(entry.tid);\n    }\n    super.clear();\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGRpc3R1YmUveXRkbC1jb3JlL2xpYi9jYWNoZS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxRQUFRLGFBQWEsRUFBRSxtQkFBTyxDQUFDLHNCQUFROztBQUV2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8veXQtZG93bmxvYWRlci8uL25vZGVfbW9kdWxlcy9AZGlzdHViZS95dGRsLWNvcmUvbGliL2NhY2hlLmpzP2YwMzgiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgeyBzZXRUaW1lb3V0IH0gPSByZXF1aXJlKFwidGltZXJzXCIpO1xuXG4vLyBBIGNhY2hlIHRoYXQgZXhwaXJlcy5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgQ2FjaGUgZXh0ZW5kcyBNYXAge1xuICBjb25zdHJ1Y3Rvcih0aW1lb3V0ID0gMTAwMCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy50aW1lb3V0ID0gdGltZW91dDtcbiAgfVxuICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgIGlmICh0aGlzLmhhcyhrZXkpKSB7XG4gICAgICBjbGVhclRpbWVvdXQoc3VwZXIuZ2V0KGtleSkudGlkKTtcbiAgICB9XG4gICAgc3VwZXIuc2V0KGtleSwge1xuICAgICAgdGlkOiBzZXRUaW1lb3V0KHRoaXMuZGVsZXRlLmJpbmQodGhpcywga2V5KSwgdGhpcy50aW1lb3V0KS51bnJlZigpLFxuICAgICAgdmFsdWUsXG4gICAgfSk7XG4gIH1cbiAgZ2V0KGtleSkge1xuICAgIGxldCBlbnRyeSA9IHN1cGVyLmdldChrZXkpO1xuICAgIGlmIChlbnRyeSkge1xuICAgICAgcmV0dXJuIGVudHJ5LnZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBnZXRPclNldChrZXksIGZuKSB7XG4gICAgaWYgKHRoaXMuaGFzKGtleSkpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldChrZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgdmFsdWUgPSBmbigpO1xuICAgICAgdGhpcy5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGF3YWl0IHZhbHVlO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICB0aGlzLmRlbGV0ZShrZXkpO1xuICAgICAgICB9XG4gICAgICB9KSgpO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgfVxuICBkZWxldGUoa2V5KSB7XG4gICAgbGV0IGVudHJ5ID0gc3VwZXIuZ2V0KGtleSk7XG4gICAgaWYgKGVudHJ5KSB7XG4gICAgICBjbGVhclRpbWVvdXQoZW50cnkudGlkKTtcbiAgICAgIHN1cGVyLmRlbGV0ZShrZXkpO1xuICAgIH1cbiAgfVxuICBjbGVhcigpIHtcbiAgICBmb3IgKGxldCBlbnRyeSBvZiB0aGlzLnZhbHVlcygpKSB7XG4gICAgICBjbGVhclRpbWVvdXQoZW50cnkudGlkKTtcbiAgICB9XG4gICAgc3VwZXIuY2xlYXIoKTtcbiAgfVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@distube/ytdl-core/lib/cache.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@distube/ytdl-core/lib/format-utils.js":
/*!*************************************************************!*\
  !*** ./node_modules/@distube/ytdl-core/lib/format-utils.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("const utils = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/@distube/ytdl-core/lib/utils.js\");\nconst FORMATS = __webpack_require__(/*! ./formats */ \"(rsc)/./node_modules/@distube/ytdl-core/lib/formats.js\");\n\n// Use these to help sort formats, higher index is better.\nconst audioEncodingRanks = [\"mp4a\", \"mp3\", \"vorbis\", \"aac\", \"opus\", \"flac\"];\nconst videoEncodingRanks = [\"mp4v\", \"avc1\", \"Sorenson H.283\", \"MPEG-4 Visual\", \"VP8\", \"VP9\", \"H.264\"];\n\nconst getVideoBitrate = format => format.bitrate || 0;\nconst getVideoEncodingRank = format => videoEncodingRanks.findIndex(enc => format.codecs?.includes(enc));\nconst getAudioBitrate = format => format.audioBitrate || 0;\nconst getAudioEncodingRank = format => audioEncodingRanks.findIndex(enc => format.codecs?.includes(enc));\n\n/**\n * Sort formats by a list of functions.\n *\n * @param {Object} a\n * @param {Object} b\n * @param {Array.<Function>} sortBy\n * @returns {number}\n */\nconst sortFormatsBy = (a, b, sortBy) => {\n  let res = 0;\n  for (let fn of sortBy) {\n    res = fn(b) - fn(a);\n    if (res !== 0) {\n      break;\n    }\n  }\n  return res;\n};\n\nconst sortFormatsByVideo = (a, b) =>\n  sortFormatsBy(a, b, [format => parseInt(format.qualityLabel), getVideoBitrate, getVideoEncodingRank]);\n\nconst sortFormatsByAudio = (a, b) => sortFormatsBy(a, b, [getAudioBitrate, getAudioEncodingRank]);\n\n/**\n * Sort formats from highest quality to lowest.\n *\n * @param {Object} a\n * @param {Object} b\n * @returns {number}\n */\nexports.sortFormats = (a, b) =>\n  sortFormatsBy(a, b, [\n    // Formats with both video and audio are ranked highest.\n    format => +!!format.isHLS,\n    format => +!!format.isDashMPD,\n    format => +(format.contentLength > 0),\n    format => +(format.hasVideo && format.hasAudio),\n    format => +format.hasVideo,\n    format => parseInt(format.qualityLabel) || 0,\n    getVideoBitrate,\n    getAudioBitrate,\n    getVideoEncodingRank,\n    getAudioEncodingRank,\n  ]);\n\n/**\n * Choose a format depending on the given options.\n *\n * @param {Array.<Object>} formats\n * @param {Object} options\n * @returns {Object}\n * @throws {Error} when no format matches the filter/format rules\n */\nexports.chooseFormat = (formats, options) => {\n  if (typeof options.format === \"object\") {\n    if (!options.format.url) {\n      throw Error(\"Invalid format given, did you use `ytdl.getInfo()`?\");\n    }\n    return options.format;\n  }\n\n  if (options.filter) {\n    formats = exports.filterFormats(formats, options.filter);\n  }\n\n  // We currently only support HLS-Formats for livestreams\n  // So we (now) remove all non-HLS streams\n  if (formats.some(fmt => fmt.isHLS)) {\n    formats = formats.filter(fmt => fmt.isHLS || !fmt.isLive);\n  }\n\n  let format;\n  const quality = options.quality || \"highest\";\n  switch (quality) {\n    case \"highest\":\n      format = formats[0];\n      break;\n\n    case \"lowest\":\n      format = formats[formats.length - 1];\n      break;\n\n    case \"highestaudio\": {\n      formats = exports.filterFormats(formats, \"audio\");\n      formats.sort(sortFormatsByAudio);\n      // Filter for only the best audio format\n      const bestAudioFormat = formats[0];\n      formats = formats.filter(f => sortFormatsByAudio(bestAudioFormat, f) === 0);\n      // Check for the worst video quality for the best audio quality and pick according\n      // This does not loose default sorting of video encoding and bitrate\n      const worstVideoQuality = formats.map(f => parseInt(f.qualityLabel) || 0).sort((a, b) => a - b)[0];\n      format = formats.find(f => (parseInt(f.qualityLabel) || 0) === worstVideoQuality);\n      break;\n    }\n\n    case \"lowestaudio\":\n      formats = exports.filterFormats(formats, \"audio\");\n      formats.sort(sortFormatsByAudio);\n      format = formats[formats.length - 1];\n      break;\n\n    case \"highestvideo\": {\n      formats = exports.filterFormats(formats, \"video\");\n      formats.sort(sortFormatsByVideo);\n      // Filter for only the best video format\n      const bestVideoFormat = formats[0];\n      formats = formats.filter(f => sortFormatsByVideo(bestVideoFormat, f) === 0);\n      // Check for the worst audio quality for the best video quality and pick according\n      // This does not loose default sorting of audio encoding and bitrate\n      const worstAudioQuality = formats.map(f => f.audioBitrate || 0).sort((a, b) => a - b)[0];\n      format = formats.find(f => (f.audioBitrate || 0) === worstAudioQuality);\n      break;\n    }\n\n    case \"lowestvideo\":\n      formats = exports.filterFormats(formats, \"video\");\n      formats.sort(sortFormatsByVideo);\n      format = formats[formats.length - 1];\n      break;\n\n    default:\n      format = getFormatByQuality(quality, formats);\n      break;\n  }\n\n  if (!format) {\n    throw Error(`No such format found: ${quality}`);\n  }\n  return format;\n};\n\n/**\n * Gets a format based on quality or array of quality's\n *\n * @param {string|[string]} quality\n * @param {[Object]} formats\n * @returns {Object}\n */\nconst getFormatByQuality = (quality, formats) => {\n  let getFormat = itag => formats.find(format => `${format.itag}` === `${itag}`);\n  if (Array.isArray(quality)) {\n    return getFormat(quality.find(q => getFormat(q)));\n  } else {\n    return getFormat(quality);\n  }\n};\n\n/**\n * @param {Array.<Object>} formats\n * @param {Function} filter\n * @returns {Array.<Object>}\n */\nexports.filterFormats = (formats, filter) => {\n  let fn;\n  switch (filter) {\n    case \"videoandaudio\":\n    case \"audioandvideo\":\n      fn = format => format.hasVideo && format.hasAudio;\n      break;\n\n    case \"video\":\n      fn = format => format.hasVideo;\n      break;\n\n    case \"videoonly\":\n      fn = format => format.hasVideo && !format.hasAudio;\n      break;\n\n    case \"audio\":\n      fn = format => format.hasAudio;\n      break;\n\n    case \"audioonly\":\n      fn = format => !format.hasVideo && format.hasAudio;\n      break;\n\n    default:\n      if (typeof filter === \"function\") {\n        fn = filter;\n      } else {\n        throw TypeError(`Given filter (${filter}) is not supported`);\n      }\n  }\n  return formats.filter(format => !!format.url && fn(format));\n};\n\n/**\n * @param {Object} format\n * @returns {Object}\n */\nexports.addFormatMeta = format => {\n  format = Object.assign({}, FORMATS[format.itag], format);\n  format.hasVideo = !!format.qualityLabel;\n  format.hasAudio = !!format.audioBitrate;\n  format.container = format.mimeType ? format.mimeType.split(\";\")[0].split(\"/\")[1] : null;\n  format.codecs = format.mimeType ? utils.between(format.mimeType, 'codecs=\"', '\"') : null;\n  format.videoCodec = format.hasVideo && format.codecs ? format.codecs.split(\", \")[0] : null;\n  format.audioCodec = format.hasAudio && format.codecs ? format.codecs.split(\", \").slice(-1)[0] : null;\n  format.isLive = /\\bsource[/=]yt_live_broadcast\\b/.test(format.url);\n  format.isHLS = /\\/manifest\\/hls_(variant|playlist)\\//.test(format.url);\n  format.isDashMPD = /\\/manifest\\/dash\\//.test(format.url);\n  return format;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGRpc3R1YmUveXRkbC1jb3JlL2xpYi9mb3JtYXQtdXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQUEsY0FBYyxtQkFBTyxDQUFDLHFFQUFTO0FBQy9CLGdCQUFnQixtQkFBTyxDQUFDLHlFQUFXOztBQUVuQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLGtCQUFrQjtBQUM3QixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0JBQWdCO0FBQzNCLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2IsWUFBWSxPQUFPO0FBQ25CO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUNBQXlDLFFBQVE7QUFDakQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsVUFBVTtBQUNyQixhQUFhO0FBQ2I7QUFDQTtBQUNBLG9EQUFvRCxZQUFZLFNBQVMsS0FBSztBQUM5RTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsZ0JBQWdCO0FBQzNCLFdBQVcsVUFBVTtBQUNyQixhQUFhO0FBQ2I7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IseUNBQXlDLE9BQU87QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0EscUJBQXFCO0FBQ3JCLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0EsK0RBQStEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly95dC1kb3dubG9hZGVyLy4vbm9kZV9tb2R1bGVzL0BkaXN0dWJlL3l0ZGwtY29yZS9saWIvZm9ybWF0LXV0aWxzLmpzPzA1ZTAiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgdXRpbHMgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbmNvbnN0IEZPUk1BVFMgPSByZXF1aXJlKFwiLi9mb3JtYXRzXCIpO1xuXG4vLyBVc2UgdGhlc2UgdG8gaGVscCBzb3J0IGZvcm1hdHMsIGhpZ2hlciBpbmRleCBpcyBiZXR0ZXIuXG5jb25zdCBhdWRpb0VuY29kaW5nUmFua3MgPSBbXCJtcDRhXCIsIFwibXAzXCIsIFwidm9yYmlzXCIsIFwiYWFjXCIsIFwib3B1c1wiLCBcImZsYWNcIl07XG5jb25zdCB2aWRlb0VuY29kaW5nUmFua3MgPSBbXCJtcDR2XCIsIFwiYXZjMVwiLCBcIlNvcmVuc29uIEguMjgzXCIsIFwiTVBFRy00IFZpc3VhbFwiLCBcIlZQOFwiLCBcIlZQOVwiLCBcIkguMjY0XCJdO1xuXG5jb25zdCBnZXRWaWRlb0JpdHJhdGUgPSBmb3JtYXQgPT4gZm9ybWF0LmJpdHJhdGUgfHwgMDtcbmNvbnN0IGdldFZpZGVvRW5jb2RpbmdSYW5rID0gZm9ybWF0ID0+IHZpZGVvRW5jb2RpbmdSYW5rcy5maW5kSW5kZXgoZW5jID0+IGZvcm1hdC5jb2RlY3M/LmluY2x1ZGVzKGVuYykpO1xuY29uc3QgZ2V0QXVkaW9CaXRyYXRlID0gZm9ybWF0ID0+IGZvcm1hdC5hdWRpb0JpdHJhdGUgfHwgMDtcbmNvbnN0IGdldEF1ZGlvRW5jb2RpbmdSYW5rID0gZm9ybWF0ID0+IGF1ZGlvRW5jb2RpbmdSYW5rcy5maW5kSW5kZXgoZW5jID0+IGZvcm1hdC5jb2RlY3M/LmluY2x1ZGVzKGVuYykpO1xuXG4vKipcbiAqIFNvcnQgZm9ybWF0cyBieSBhIGxpc3Qgb2YgZnVuY3Rpb25zLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBhXG4gKiBAcGFyYW0ge09iamVjdH0gYlxuICogQHBhcmFtIHtBcnJheS48RnVuY3Rpb24+fSBzb3J0QnlcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmNvbnN0IHNvcnRGb3JtYXRzQnkgPSAoYSwgYiwgc29ydEJ5KSA9PiB7XG4gIGxldCByZXMgPSAwO1xuICBmb3IgKGxldCBmbiBvZiBzb3J0QnkpIHtcbiAgICByZXMgPSBmbihiKSAtIGZuKGEpO1xuICAgIGlmIChyZXMgIT09IDApIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzO1xufTtcblxuY29uc3Qgc29ydEZvcm1hdHNCeVZpZGVvID0gKGEsIGIpID0+XG4gIHNvcnRGb3JtYXRzQnkoYSwgYiwgW2Zvcm1hdCA9PiBwYXJzZUludChmb3JtYXQucXVhbGl0eUxhYmVsKSwgZ2V0VmlkZW9CaXRyYXRlLCBnZXRWaWRlb0VuY29kaW5nUmFua10pO1xuXG5jb25zdCBzb3J0Rm9ybWF0c0J5QXVkaW8gPSAoYSwgYikgPT4gc29ydEZvcm1hdHNCeShhLCBiLCBbZ2V0QXVkaW9CaXRyYXRlLCBnZXRBdWRpb0VuY29kaW5nUmFua10pO1xuXG4vKipcbiAqIFNvcnQgZm9ybWF0cyBmcm9tIGhpZ2hlc3QgcXVhbGl0eSB0byBsb3dlc3QuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGFcbiAqIEBwYXJhbSB7T2JqZWN0fSBiXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5leHBvcnRzLnNvcnRGb3JtYXRzID0gKGEsIGIpID0+XG4gIHNvcnRGb3JtYXRzQnkoYSwgYiwgW1xuICAgIC8vIEZvcm1hdHMgd2l0aCBib3RoIHZpZGVvIGFuZCBhdWRpbyBhcmUgcmFua2VkIGhpZ2hlc3QuXG4gICAgZm9ybWF0ID0+ICshIWZvcm1hdC5pc0hMUyxcbiAgICBmb3JtYXQgPT4gKyEhZm9ybWF0LmlzRGFzaE1QRCxcbiAgICBmb3JtYXQgPT4gKyhmb3JtYXQuY29udGVudExlbmd0aCA+IDApLFxuICAgIGZvcm1hdCA9PiArKGZvcm1hdC5oYXNWaWRlbyAmJiBmb3JtYXQuaGFzQXVkaW8pLFxuICAgIGZvcm1hdCA9PiArZm9ybWF0Lmhhc1ZpZGVvLFxuICAgIGZvcm1hdCA9PiBwYXJzZUludChmb3JtYXQucXVhbGl0eUxhYmVsKSB8fCAwLFxuICAgIGdldFZpZGVvQml0cmF0ZSxcbiAgICBnZXRBdWRpb0JpdHJhdGUsXG4gICAgZ2V0VmlkZW9FbmNvZGluZ1JhbmssXG4gICAgZ2V0QXVkaW9FbmNvZGluZ1JhbmssXG4gIF0pO1xuXG4vKipcbiAqIENob29zZSBhIGZvcm1hdCBkZXBlbmRpbmcgb24gdGhlIGdpdmVuIG9wdGlvbnMuXG4gKlxuICogQHBhcmFtIHtBcnJheS48T2JqZWN0Pn0gZm9ybWF0c1xuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKiBAdGhyb3dzIHtFcnJvcn0gd2hlbiBubyBmb3JtYXQgbWF0Y2hlcyB0aGUgZmlsdGVyL2Zvcm1hdCBydWxlc1xuICovXG5leHBvcnRzLmNob29zZUZvcm1hdCA9IChmb3JtYXRzLCBvcHRpb25zKSA9PiB7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucy5mb3JtYXQgPT09IFwib2JqZWN0XCIpIHtcbiAgICBpZiAoIW9wdGlvbnMuZm9ybWF0LnVybCkge1xuICAgICAgdGhyb3cgRXJyb3IoXCJJbnZhbGlkIGZvcm1hdCBnaXZlbiwgZGlkIHlvdSB1c2UgYHl0ZGwuZ2V0SW5mbygpYD9cIik7XG4gICAgfVxuICAgIHJldHVybiBvcHRpb25zLmZvcm1hdDtcbiAgfVxuXG4gIGlmIChvcHRpb25zLmZpbHRlcikge1xuICAgIGZvcm1hdHMgPSBleHBvcnRzLmZpbHRlckZvcm1hdHMoZm9ybWF0cywgb3B0aW9ucy5maWx0ZXIpO1xuICB9XG5cbiAgLy8gV2UgY3VycmVudGx5IG9ubHkgc3VwcG9ydCBITFMtRm9ybWF0cyBmb3IgbGl2ZXN0cmVhbXNcbiAgLy8gU28gd2UgKG5vdykgcmVtb3ZlIGFsbCBub24tSExTIHN0cmVhbXNcbiAgaWYgKGZvcm1hdHMuc29tZShmbXQgPT4gZm10LmlzSExTKSkge1xuICAgIGZvcm1hdHMgPSBmb3JtYXRzLmZpbHRlcihmbXQgPT4gZm10LmlzSExTIHx8ICFmbXQuaXNMaXZlKTtcbiAgfVxuXG4gIGxldCBmb3JtYXQ7XG4gIGNvbnN0IHF1YWxpdHkgPSBvcHRpb25zLnF1YWxpdHkgfHwgXCJoaWdoZXN0XCI7XG4gIHN3aXRjaCAocXVhbGl0eSkge1xuICAgIGNhc2UgXCJoaWdoZXN0XCI6XG4gICAgICBmb3JtYXQgPSBmb3JtYXRzWzBdO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFwibG93ZXN0XCI6XG4gICAgICBmb3JtYXQgPSBmb3JtYXRzW2Zvcm1hdHMubGVuZ3RoIC0gMV07XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgXCJoaWdoZXN0YXVkaW9cIjoge1xuICAgICAgZm9ybWF0cyA9IGV4cG9ydHMuZmlsdGVyRm9ybWF0cyhmb3JtYXRzLCBcImF1ZGlvXCIpO1xuICAgICAgZm9ybWF0cy5zb3J0KHNvcnRGb3JtYXRzQnlBdWRpbyk7XG4gICAgICAvLyBGaWx0ZXIgZm9yIG9ubHkgdGhlIGJlc3QgYXVkaW8gZm9ybWF0XG4gICAgICBjb25zdCBiZXN0QXVkaW9Gb3JtYXQgPSBmb3JtYXRzWzBdO1xuICAgICAgZm9ybWF0cyA9IGZvcm1hdHMuZmlsdGVyKGYgPT4gc29ydEZvcm1hdHNCeUF1ZGlvKGJlc3RBdWRpb0Zvcm1hdCwgZikgPT09IDApO1xuICAgICAgLy8gQ2hlY2sgZm9yIHRoZSB3b3JzdCB2aWRlbyBxdWFsaXR5IGZvciB0aGUgYmVzdCBhdWRpbyBxdWFsaXR5IGFuZCBwaWNrIGFjY29yZGluZ1xuICAgICAgLy8gVGhpcyBkb2VzIG5vdCBsb29zZSBkZWZhdWx0IHNvcnRpbmcgb2YgdmlkZW8gZW5jb2RpbmcgYW5kIGJpdHJhdGVcbiAgICAgIGNvbnN0IHdvcnN0VmlkZW9RdWFsaXR5ID0gZm9ybWF0cy5tYXAoZiA9PiBwYXJzZUludChmLnF1YWxpdHlMYWJlbCkgfHwgMCkuc29ydCgoYSwgYikgPT4gYSAtIGIpWzBdO1xuICAgICAgZm9ybWF0ID0gZm9ybWF0cy5maW5kKGYgPT4gKHBhcnNlSW50KGYucXVhbGl0eUxhYmVsKSB8fCAwKSA9PT0gd29yc3RWaWRlb1F1YWxpdHkpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgY2FzZSBcImxvd2VzdGF1ZGlvXCI6XG4gICAgICBmb3JtYXRzID0gZXhwb3J0cy5maWx0ZXJGb3JtYXRzKGZvcm1hdHMsIFwiYXVkaW9cIik7XG4gICAgICBmb3JtYXRzLnNvcnQoc29ydEZvcm1hdHNCeUF1ZGlvKTtcbiAgICAgIGZvcm1hdCA9IGZvcm1hdHNbZm9ybWF0cy5sZW5ndGggLSAxXTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBcImhpZ2hlc3R2aWRlb1wiOiB7XG4gICAgICBmb3JtYXRzID0gZXhwb3J0cy5maWx0ZXJGb3JtYXRzKGZvcm1hdHMsIFwidmlkZW9cIik7XG4gICAgICBmb3JtYXRzLnNvcnQoc29ydEZvcm1hdHNCeVZpZGVvKTtcbiAgICAgIC8vIEZpbHRlciBmb3Igb25seSB0aGUgYmVzdCB2aWRlbyBmb3JtYXRcbiAgICAgIGNvbnN0IGJlc3RWaWRlb0Zvcm1hdCA9IGZvcm1hdHNbMF07XG4gICAgICBmb3JtYXRzID0gZm9ybWF0cy5maWx0ZXIoZiA9PiBzb3J0Rm9ybWF0c0J5VmlkZW8oYmVzdFZpZGVvRm9ybWF0LCBmKSA9PT0gMCk7XG4gICAgICAvLyBDaGVjayBmb3IgdGhlIHdvcnN0IGF1ZGlvIHF1YWxpdHkgZm9yIHRoZSBiZXN0IHZpZGVvIHF1YWxpdHkgYW5kIHBpY2sgYWNjb3JkaW5nXG4gICAgICAvLyBUaGlzIGRvZXMgbm90IGxvb3NlIGRlZmF1bHQgc29ydGluZyBvZiBhdWRpbyBlbmNvZGluZyBhbmQgYml0cmF0ZVxuICAgICAgY29uc3Qgd29yc3RBdWRpb1F1YWxpdHkgPSBmb3JtYXRzLm1hcChmID0+IGYuYXVkaW9CaXRyYXRlIHx8IDApLnNvcnQoKGEsIGIpID0+IGEgLSBiKVswXTtcbiAgICAgIGZvcm1hdCA9IGZvcm1hdHMuZmluZChmID0+IChmLmF1ZGlvQml0cmF0ZSB8fCAwKSA9PT0gd29yc3RBdWRpb1F1YWxpdHkpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgY2FzZSBcImxvd2VzdHZpZGVvXCI6XG4gICAgICBmb3JtYXRzID0gZXhwb3J0cy5maWx0ZXJGb3JtYXRzKGZvcm1hdHMsIFwidmlkZW9cIik7XG4gICAgICBmb3JtYXRzLnNvcnQoc29ydEZvcm1hdHNCeVZpZGVvKTtcbiAgICAgIGZvcm1hdCA9IGZvcm1hdHNbZm9ybWF0cy5sZW5ndGggLSAxXTtcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIGZvcm1hdCA9IGdldEZvcm1hdEJ5UXVhbGl0eShxdWFsaXR5LCBmb3JtYXRzKTtcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgaWYgKCFmb3JtYXQpIHtcbiAgICB0aHJvdyBFcnJvcihgTm8gc3VjaCBmb3JtYXQgZm91bmQ6ICR7cXVhbGl0eX1gKTtcbiAgfVxuICByZXR1cm4gZm9ybWF0O1xufTtcblxuLyoqXG4gKiBHZXRzIGEgZm9ybWF0IGJhc2VkIG9uIHF1YWxpdHkgb3IgYXJyYXkgb2YgcXVhbGl0eSdzXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8W3N0cmluZ119IHF1YWxpdHlcbiAqIEBwYXJhbSB7W09iamVjdF19IGZvcm1hdHNcbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKi9cbmNvbnN0IGdldEZvcm1hdEJ5UXVhbGl0eSA9IChxdWFsaXR5LCBmb3JtYXRzKSA9PiB7XG4gIGxldCBnZXRGb3JtYXQgPSBpdGFnID0+IGZvcm1hdHMuZmluZChmb3JtYXQgPT4gYCR7Zm9ybWF0Lml0YWd9YCA9PT0gYCR7aXRhZ31gKTtcbiAgaWYgKEFycmF5LmlzQXJyYXkocXVhbGl0eSkpIHtcbiAgICByZXR1cm4gZ2V0Rm9ybWF0KHF1YWxpdHkuZmluZChxID0+IGdldEZvcm1hdChxKSkpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBnZXRGb3JtYXQocXVhbGl0eSk7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheS48T2JqZWN0Pn0gZm9ybWF0c1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZmlsdGVyXG4gKiBAcmV0dXJucyB7QXJyYXkuPE9iamVjdD59XG4gKi9cbmV4cG9ydHMuZmlsdGVyRm9ybWF0cyA9IChmb3JtYXRzLCBmaWx0ZXIpID0+IHtcbiAgbGV0IGZuO1xuICBzd2l0Y2ggKGZpbHRlcikge1xuICAgIGNhc2UgXCJ2aWRlb2FuZGF1ZGlvXCI6XG4gICAgY2FzZSBcImF1ZGlvYW5kdmlkZW9cIjpcbiAgICAgIGZuID0gZm9ybWF0ID0+IGZvcm1hdC5oYXNWaWRlbyAmJiBmb3JtYXQuaGFzQXVkaW87XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgXCJ2aWRlb1wiOlxuICAgICAgZm4gPSBmb3JtYXQgPT4gZm9ybWF0Lmhhc1ZpZGVvO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFwidmlkZW9vbmx5XCI6XG4gICAgICBmbiA9IGZvcm1hdCA9PiBmb3JtYXQuaGFzVmlkZW8gJiYgIWZvcm1hdC5oYXNBdWRpbztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBcImF1ZGlvXCI6XG4gICAgICBmbiA9IGZvcm1hdCA9PiBmb3JtYXQuaGFzQXVkaW87XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgXCJhdWRpb29ubHlcIjpcbiAgICAgIGZuID0gZm9ybWF0ID0+ICFmb3JtYXQuaGFzVmlkZW8gJiYgZm9ybWF0Lmhhc0F1ZGlvO1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgaWYgKHR5cGVvZiBmaWx0ZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBmbiA9IGZpbHRlcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IFR5cGVFcnJvcihgR2l2ZW4gZmlsdGVyICgke2ZpbHRlcn0pIGlzIG5vdCBzdXBwb3J0ZWRgKTtcbiAgICAgIH1cbiAgfVxuICByZXR1cm4gZm9ybWF0cy5maWx0ZXIoZm9ybWF0ID0+ICEhZm9ybWF0LnVybCAmJiBmbihmb3JtYXQpKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3R9IGZvcm1hdFxuICogQHJldHVybnMge09iamVjdH1cbiAqL1xuZXhwb3J0cy5hZGRGb3JtYXRNZXRhID0gZm9ybWF0ID0+IHtcbiAgZm9ybWF0ID0gT2JqZWN0LmFzc2lnbih7fSwgRk9STUFUU1tmb3JtYXQuaXRhZ10sIGZvcm1hdCk7XG4gIGZvcm1hdC5oYXNWaWRlbyA9ICEhZm9ybWF0LnF1YWxpdHlMYWJlbDtcbiAgZm9ybWF0Lmhhc0F1ZGlvID0gISFmb3JtYXQuYXVkaW9CaXRyYXRlO1xuICBmb3JtYXQuY29udGFpbmVyID0gZm9ybWF0Lm1pbWVUeXBlID8gZm9ybWF0Lm1pbWVUeXBlLnNwbGl0KFwiO1wiKVswXS5zcGxpdChcIi9cIilbMV0gOiBudWxsO1xuICBmb3JtYXQuY29kZWNzID0gZm9ybWF0Lm1pbWVUeXBlID8gdXRpbHMuYmV0d2Vlbihmb3JtYXQubWltZVR5cGUsICdjb2RlY3M9XCInLCAnXCInKSA6IG51bGw7XG4gIGZvcm1hdC52aWRlb0NvZGVjID0gZm9ybWF0Lmhhc1ZpZGVvICYmIGZvcm1hdC5jb2RlY3MgPyBmb3JtYXQuY29kZWNzLnNwbGl0KFwiLCBcIilbMF0gOiBudWxsO1xuICBmb3JtYXQuYXVkaW9Db2RlYyA9IGZvcm1hdC5oYXNBdWRpbyAmJiBmb3JtYXQuY29kZWNzID8gZm9ybWF0LmNvZGVjcy5zcGxpdChcIiwgXCIpLnNsaWNlKC0xKVswXSA6IG51bGw7XG4gIGZvcm1hdC5pc0xpdmUgPSAvXFxic291cmNlWy89XXl0X2xpdmVfYnJvYWRjYXN0XFxiLy50ZXN0KGZvcm1hdC51cmwpO1xuICBmb3JtYXQuaXNITFMgPSAvXFwvbWFuaWZlc3RcXC9obHNfKHZhcmlhbnR8cGxheWxpc3QpXFwvLy50ZXN0KGZvcm1hdC51cmwpO1xuICBmb3JtYXQuaXNEYXNoTVBEID0gL1xcL21hbmlmZXN0XFwvZGFzaFxcLy8udGVzdChmb3JtYXQudXJsKTtcbiAgcmV0dXJuIGZvcm1hdDtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@distube/ytdl-core/lib/format-utils.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@distube/ytdl-core/lib/formats.js":
/*!********************************************************!*\
  !*** ./node_modules/@distube/ytdl-core/lib/formats.js ***!
  \********************************************************/
/***/ ((module) => {

eval("/**\n * http://en.wikipedia.org/wiki/YouTube#Quality_and_formats\n */\nmodule.exports = {\n  5: {\n    mimeType: 'video/flv; codecs=\"Sorenson H.283, mp3\"',\n    qualityLabel: \"240p\",\n    bitrate: 250000,\n    audioBitrate: 64,\n  },\n\n  6: {\n    mimeType: 'video/flv; codecs=\"Sorenson H.263, mp3\"',\n    qualityLabel: \"270p\",\n    bitrate: 800000,\n    audioBitrate: 64,\n  },\n\n  13: {\n    mimeType: 'video/3gp; codecs=\"MPEG-4 Visual, aac\"',\n    qualityLabel: null,\n    bitrate: 500000,\n    audioBitrate: null,\n  },\n\n  17: {\n    mimeType: 'video/3gp; codecs=\"MPEG-4 Visual, aac\"',\n    qualityLabel: \"144p\",\n    bitrate: 50000,\n    audioBitrate: 24,\n  },\n\n  18: {\n    mimeType: 'video/mp4; codecs=\"H.264, aac\"',\n    qualityLabel: \"360p\",\n    bitrate: 500000,\n    audioBitrate: 96,\n  },\n\n  22: {\n    mimeType: 'video/mp4; codecs=\"H.264, aac\"',\n    qualityLabel: \"720p\",\n    bitrate: 2000000,\n    audioBitrate: 192,\n  },\n\n  34: {\n    mimeType: 'video/flv; codecs=\"H.264, aac\"',\n    qualityLabel: \"360p\",\n    bitrate: 500000,\n    audioBitrate: 128,\n  },\n\n  35: {\n    mimeType: 'video/flv; codecs=\"H.264, aac\"',\n    qualityLabel: \"480p\",\n    bitrate: 800000,\n    audioBitrate: 128,\n  },\n\n  36: {\n    mimeType: 'video/3gp; codecs=\"MPEG-4 Visual, aac\"',\n    qualityLabel: \"240p\",\n    bitrate: 175000,\n    audioBitrate: 32,\n  },\n\n  37: {\n    mimeType: 'video/mp4; codecs=\"H.264, aac\"',\n    qualityLabel: \"1080p\",\n    bitrate: 3000000,\n    audioBitrate: 192,\n  },\n\n  38: {\n    mimeType: 'video/mp4; codecs=\"H.264, aac\"',\n    qualityLabel: \"3072p\",\n    bitrate: 3500000,\n    audioBitrate: 192,\n  },\n\n  43: {\n    mimeType: 'video/webm; codecs=\"VP8, vorbis\"',\n    qualityLabel: \"360p\",\n    bitrate: 500000,\n    audioBitrate: 128,\n  },\n\n  44: {\n    mimeType: 'video/webm; codecs=\"VP8, vorbis\"',\n    qualityLabel: \"480p\",\n    bitrate: 1000000,\n    audioBitrate: 128,\n  },\n\n  45: {\n    mimeType: 'video/webm; codecs=\"VP8, vorbis\"',\n    qualityLabel: \"720p\",\n    bitrate: 2000000,\n    audioBitrate: 192,\n  },\n\n  46: {\n    mimeType: 'audio/webm; codecs=\"vp8, vorbis\"',\n    qualityLabel: \"1080p\",\n    bitrate: null,\n    audioBitrate: 192,\n  },\n\n  82: {\n    mimeType: 'video/mp4; codecs=\"H.264, aac\"',\n    qualityLabel: \"360p\",\n    bitrate: 500000,\n    audioBitrate: 96,\n  },\n\n  83: {\n    mimeType: 'video/mp4; codecs=\"H.264, aac\"',\n    qualityLabel: \"240p\",\n    bitrate: 500000,\n    audioBitrate: 96,\n  },\n\n  84: {\n    mimeType: 'video/mp4; codecs=\"H.264, aac\"',\n    qualityLabel: \"720p\",\n    bitrate: 2000000,\n    audioBitrate: 192,\n  },\n\n  85: {\n    mimeType: 'video/mp4; codecs=\"H.264, aac\"',\n    qualityLabel: \"1080p\",\n    bitrate: 3000000,\n    audioBitrate: 192,\n  },\n\n  91: {\n    mimeType: 'video/ts; codecs=\"H.264, aac\"',\n    qualityLabel: \"144p\",\n    bitrate: 100000,\n    audioBitrate: 48,\n  },\n\n  92: {\n    mimeType: 'video/ts; codecs=\"H.264, aac\"',\n    qualityLabel: \"240p\",\n    bitrate: 150000,\n    audioBitrate: 48,\n  },\n\n  93: {\n    mimeType: 'video/ts; codecs=\"H.264, aac\"',\n    qualityLabel: \"360p\",\n    bitrate: 500000,\n    audioBitrate: 128,\n  },\n\n  94: {\n    mimeType: 'video/ts; codecs=\"H.264, aac\"',\n    qualityLabel: \"480p\",\n    bitrate: 800000,\n    audioBitrate: 128,\n  },\n\n  95: {\n    mimeType: 'video/ts; codecs=\"H.264, aac\"',\n    qualityLabel: \"720p\",\n    bitrate: 1500000,\n    audioBitrate: 256,\n  },\n\n  96: {\n    mimeType: 'video/ts; codecs=\"H.264, aac\"',\n    qualityLabel: \"1080p\",\n    bitrate: 2500000,\n    audioBitrate: 256,\n  },\n\n  100: {\n    mimeType: 'audio/webm; codecs=\"VP8, vorbis\"',\n    qualityLabel: \"360p\",\n    bitrate: null,\n    audioBitrate: 128,\n  },\n\n  101: {\n    mimeType: 'audio/webm; codecs=\"VP8, vorbis\"',\n    qualityLabel: \"360p\",\n    bitrate: null,\n    audioBitrate: 192,\n  },\n\n  102: {\n    mimeType: 'audio/webm; codecs=\"VP8, vorbis\"',\n    qualityLabel: \"720p\",\n    bitrate: null,\n    audioBitrate: 192,\n  },\n\n  120: {\n    mimeType: 'video/flv; codecs=\"H.264, aac\"',\n    qualityLabel: \"720p\",\n    bitrate: 2000000,\n    audioBitrate: 128,\n  },\n\n  127: {\n    mimeType: 'audio/ts; codecs=\"aac\"',\n    qualityLabel: null,\n    bitrate: null,\n    audioBitrate: 96,\n  },\n\n  128: {\n    mimeType: 'audio/ts; codecs=\"aac\"',\n    qualityLabel: null,\n    bitrate: null,\n    audioBitrate: 96,\n  },\n\n  132: {\n    mimeType: 'video/ts; codecs=\"H.264, aac\"',\n    qualityLabel: \"240p\",\n    bitrate: 150000,\n    audioBitrate: 48,\n  },\n\n  133: {\n    mimeType: 'video/mp4; codecs=\"H.264\"',\n    qualityLabel: \"240p\",\n    bitrate: 200000,\n    audioBitrate: null,\n  },\n\n  134: {\n    mimeType: 'video/mp4; codecs=\"H.264\"',\n    qualityLabel: \"360p\",\n    bitrate: 300000,\n    audioBitrate: null,\n  },\n\n  135: {\n    mimeType: 'video/mp4; codecs=\"H.264\"',\n    qualityLabel: \"480p\",\n    bitrate: 500000,\n    audioBitrate: null,\n  },\n\n  136: {\n    mimeType: 'video/mp4; codecs=\"H.264\"',\n    qualityLabel: \"720p\",\n    bitrate: 1000000,\n    audioBitrate: null,\n  },\n\n  137: {\n    mimeType: 'video/mp4; codecs=\"H.264\"',\n    qualityLabel: \"1080p\",\n    bitrate: 2500000,\n    audioBitrate: null,\n  },\n\n  138: {\n    mimeType: 'video/mp4; codecs=\"H.264\"',\n    qualityLabel: \"4320p\",\n    bitrate: 13500000,\n    audioBitrate: null,\n  },\n\n  139: {\n    mimeType: 'audio/mp4; codecs=\"aac\"',\n    qualityLabel: null,\n    bitrate: null,\n    audioBitrate: 48,\n  },\n\n  140: {\n    mimeType: 'audio/m4a; codecs=\"aac\"',\n    qualityLabel: null,\n    bitrate: null,\n    audioBitrate: 128,\n  },\n\n  141: {\n    mimeType: 'audio/mp4; codecs=\"aac\"',\n    qualityLabel: null,\n    bitrate: null,\n    audioBitrate: 256,\n  },\n\n  151: {\n    mimeType: 'video/ts; codecs=\"H.264, aac\"',\n    qualityLabel: \"720p\",\n    bitrate: 50000,\n    audioBitrate: 24,\n  },\n\n  160: {\n    mimeType: 'video/mp4; codecs=\"H.264\"',\n    qualityLabel: \"144p\",\n    bitrate: 100000,\n    audioBitrate: null,\n  },\n\n  171: {\n    mimeType: 'audio/webm; codecs=\"vorbis\"',\n    qualityLabel: null,\n    bitrate: null,\n    audioBitrate: 128,\n  },\n\n  172: {\n    mimeType: 'audio/webm; codecs=\"vorbis\"',\n    qualityLabel: null,\n    bitrate: null,\n    audioBitrate: 192,\n  },\n\n  231: {\n    mimeType: 'video/ts; codecs=\"H.264, aac\"',\n    qualityLabel: \"480p\",\n    bitrate: 500000,\n    audioBitrate: null,\n  },\n\n  232: {\n    mimeType: 'video/ts; codecs=\"H.264, aac\"',\n    qualityLabel: \"720p\",\n    bitrate: 800000,\n    audioBitrate: null,\n  },\n\n  242: {\n    mimeType: 'video/webm; codecs=\"VP9\"',\n    qualityLabel: \"240p\",\n    bitrate: 100000,\n    audioBitrate: null,\n  },\n\n  243: {\n    mimeType: 'video/webm; codecs=\"VP9\"',\n    qualityLabel: \"360p\",\n    bitrate: 250000,\n    audioBitrate: null,\n  },\n\n  244: {\n    mimeType: 'video/webm; codecs=\"VP9\"',\n    qualityLabel: \"480p\",\n    bitrate: 500000,\n    audioBitrate: null,\n  },\n\n  247: {\n    mimeType: 'video/webm; codecs=\"VP9\"',\n    qualityLabel: \"720p\",\n    bitrate: 700000,\n    audioBitrate: null,\n  },\n\n  248: {\n    mimeType: 'video/webm; codecs=\"VP9\"',\n    qualityLabel: \"1080p\",\n    bitrate: 1500000,\n    audioBitrate: null,\n  },\n\n  249: {\n    mimeType: 'audio/webm; codecs=\"opus\"',\n    qualityLabel: null,\n    bitrate: null,\n    audioBitrate: 48,\n  },\n\n  250: {\n    mimeType: 'audio/webm; codecs=\"opus\"',\n    qualityLabel: null,\n    bitrate: null,\n    audioBitrate: 64,\n  },\n\n  251: {\n    mimeType: 'audio/webm; codecs=\"opus\"',\n    qualityLabel: null,\n    bitrate: null,\n    audioBitrate: 160,\n  },\n\n  264: {\n    mimeType: 'video/mp4; codecs=\"H.264\"',\n    qualityLabel: \"1440p\",\n    bitrate: 4000000,\n    audioBitrate: null,\n  },\n\n  266: {\n    mimeType: 'video/mp4; codecs=\"H.264\"',\n    qualityLabel: \"2160p\",\n    bitrate: 12500000,\n    audioBitrate: null,\n  },\n\n  270: {\n    mimeType: 'video/mp4; codecs=\"H.264\"',\n    qualityLabel: \"1080p\",\n    bitrate: 2500000,\n    audioBitrate: null,\n  },\n\n  271: {\n    mimeType: 'video/webm; codecs=\"VP9\"',\n    qualityLabel: \"1440p\",\n    bitrate: 9000000,\n    audioBitrate: null,\n  },\n\n  272: {\n    mimeType: 'video/webm; codecs=\"VP9\"',\n    qualityLabel: \"4320p\",\n    bitrate: 20000000,\n    audioBitrate: null,\n  },\n\n  278: {\n    mimeType: 'video/webm; codecs=\"VP9\"',\n    qualityLabel: \"144p 30fps\",\n    bitrate: 80000,\n    audioBitrate: null,\n  },\n\n  298: {\n    mimeType: 'video/mp4; codecs=\"H.264\"',\n    qualityLabel: \"720p\",\n    bitrate: 3000000,\n    audioBitrate: null,\n  },\n\n  299: {\n    mimeType: 'video/mp4; codecs=\"H.264\"',\n    qualityLabel: \"1080p\",\n    bitrate: 5500000,\n    audioBitrate: null,\n  },\n\n  300: {\n    mimeType: 'video/ts; codecs=\"H.264, aac\"',\n    qualityLabel: \"720p\",\n    bitrate: 1318000,\n    audioBitrate: 48,\n  },\n\n  301: {\n    mimeType: 'video/ts; codecs=\"H.264, aac\"',\n    qualityLabel: \"1080p\",\n    bitrate: 3000000,\n    audioBitrate: 128,\n  },\n\n  302: {\n    mimeType: 'video/webm; codecs=\"VP9\"',\n    qualityLabel: \"720p HFR\",\n    bitrate: 2500000,\n    audioBitrate: null,\n  },\n\n  303: {\n    mimeType: 'video/webm; codecs=\"VP9\"',\n    qualityLabel: \"1080p HFR\",\n    bitrate: 5000000,\n    audioBitrate: null,\n  },\n\n  308: {\n    mimeType: 'video/webm; codecs=\"VP9\"',\n    qualityLabel: \"1440p HFR\",\n    bitrate: 10000000,\n    audioBitrate: null,\n  },\n\n  311: {\n    mimeType: 'video/webm; codecs=\"VP9\"',\n    qualityLabel: \"720p\",\n    bitrate: 1250000,\n    audioBitrate: null,\n  },\n\n  312: {\n    mimeType: 'video/mp4; codecs=\"H.264\"',\n    qualityLabel: \"1080p\",\n    bitrate: 2500000,\n    audioBitrate: null,\n  },\n\n  313: {\n    mimeType: 'video/webm; codecs=\"VP9\"',\n    qualityLabel: \"2160p\",\n    bitrate: 13000000,\n    audioBitrate: null,\n  },\n\n  315: {\n    mimeType: 'video/webm; codecs=\"VP9\"',\n    qualityLabel: \"2160p HFR\",\n    bitrate: 20000000,\n    audioBitrate: null,\n  },\n\n  330: {\n    mimeType: 'video/webm; codecs=\"VP9\"',\n    qualityLabel: \"144p HDR, HFR\",\n    bitrate: 80000,\n    audioBitrate: null,\n  },\n\n  331: {\n    mimeType: 'video/webm; codecs=\"VP9\"',\n    qualityLabel: \"240p HDR, HFR\",\n    bitrate: 100000,\n    audioBitrate: null,\n  },\n\n  332: {\n    mimeType: 'video/webm; codecs=\"VP9\"',\n    qualityLabel: \"360p HDR, HFR\",\n    bitrate: 250000,\n    audioBitrate: null,\n  },\n\n  333: {\n    mimeType: 'video/webm; codecs=\"VP9\"',\n    qualityLabel: \"240p HDR, HFR\",\n    bitrate: 500000,\n    audioBitrate: null,\n  },\n\n  334: {\n    mimeType: 'video/webm; codecs=\"VP9\"',\n    qualityLabel: \"720p HDR, HFR\",\n    bitrate: 1000000,\n    audioBitrate: null,\n  },\n\n  335: {\n    mimeType: 'video/webm; codecs=\"VP9\"',\n    qualityLabel: \"1080p HDR, HFR\",\n    bitrate: 1500000,\n    audioBitrate: null,\n  },\n\n  336: {\n    mimeType: 'video/webm; codecs=\"VP9\"',\n    qualityLabel: \"1440p HDR, HFR\",\n    bitrate: 5000000,\n    audioBitrate: null,\n  },\n\n  337: {\n    mimeType: 'video/webm; codecs=\"VP9\"',\n    qualityLabel: \"2160p HDR, HFR\",\n    bitrate: 12000000,\n    audioBitrate: null,\n  },\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGRpc3R1YmUveXRkbC1jb3JlL2xpYi9mb3JtYXRzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly95dC1kb3dubG9hZGVyLy4vbm9kZV9tb2R1bGVzL0BkaXN0dWJlL3l0ZGwtY29yZS9saWIvZm9ybWF0cy5qcz9hODg0Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Zb3VUdWJlI1F1YWxpdHlfYW5kX2Zvcm1hdHNcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIDU6IHtcbiAgICBtaW1lVHlwZTogJ3ZpZGVvL2ZsdjsgY29kZWNzPVwiU29yZW5zb24gSC4yODMsIG1wM1wiJyxcbiAgICBxdWFsaXR5TGFiZWw6IFwiMjQwcFwiLFxuICAgIGJpdHJhdGU6IDI1MDAwMCxcbiAgICBhdWRpb0JpdHJhdGU6IDY0LFxuICB9LFxuXG4gIDY6IHtcbiAgICBtaW1lVHlwZTogJ3ZpZGVvL2ZsdjsgY29kZWNzPVwiU29yZW5zb24gSC4yNjMsIG1wM1wiJyxcbiAgICBxdWFsaXR5TGFiZWw6IFwiMjcwcFwiLFxuICAgIGJpdHJhdGU6IDgwMDAwMCxcbiAgICBhdWRpb0JpdHJhdGU6IDY0LFxuICB9LFxuXG4gIDEzOiB7XG4gICAgbWltZVR5cGU6ICd2aWRlby8zZ3A7IGNvZGVjcz1cIk1QRUctNCBWaXN1YWwsIGFhY1wiJyxcbiAgICBxdWFsaXR5TGFiZWw6IG51bGwsXG4gICAgYml0cmF0ZTogNTAwMDAwLFxuICAgIGF1ZGlvQml0cmF0ZTogbnVsbCxcbiAgfSxcblxuICAxNzoge1xuICAgIG1pbWVUeXBlOiAndmlkZW8vM2dwOyBjb2RlY3M9XCJNUEVHLTQgVmlzdWFsLCBhYWNcIicsXG4gICAgcXVhbGl0eUxhYmVsOiBcIjE0NHBcIixcbiAgICBiaXRyYXRlOiA1MDAwMCxcbiAgICBhdWRpb0JpdHJhdGU6IDI0LFxuICB9LFxuXG4gIDE4OiB7XG4gICAgbWltZVR5cGU6ICd2aWRlby9tcDQ7IGNvZGVjcz1cIkguMjY0LCBhYWNcIicsXG4gICAgcXVhbGl0eUxhYmVsOiBcIjM2MHBcIixcbiAgICBiaXRyYXRlOiA1MDAwMDAsXG4gICAgYXVkaW9CaXRyYXRlOiA5NixcbiAgfSxcblxuICAyMjoge1xuICAgIG1pbWVUeXBlOiAndmlkZW8vbXA0OyBjb2RlY3M9XCJILjI2NCwgYWFjXCInLFxuICAgIHF1YWxpdHlMYWJlbDogXCI3MjBwXCIsXG4gICAgYml0cmF0ZTogMjAwMDAwMCxcbiAgICBhdWRpb0JpdHJhdGU6IDE5MixcbiAgfSxcblxuICAzNDoge1xuICAgIG1pbWVUeXBlOiAndmlkZW8vZmx2OyBjb2RlY3M9XCJILjI2NCwgYWFjXCInLFxuICAgIHF1YWxpdHlMYWJlbDogXCIzNjBwXCIsXG4gICAgYml0cmF0ZTogNTAwMDAwLFxuICAgIGF1ZGlvQml0cmF0ZTogMTI4LFxuICB9LFxuXG4gIDM1OiB7XG4gICAgbWltZVR5cGU6ICd2aWRlby9mbHY7IGNvZGVjcz1cIkguMjY0LCBhYWNcIicsXG4gICAgcXVhbGl0eUxhYmVsOiBcIjQ4MHBcIixcbiAgICBiaXRyYXRlOiA4MDAwMDAsXG4gICAgYXVkaW9CaXRyYXRlOiAxMjgsXG4gIH0sXG5cbiAgMzY6IHtcbiAgICBtaW1lVHlwZTogJ3ZpZGVvLzNncDsgY29kZWNzPVwiTVBFRy00IFZpc3VhbCwgYWFjXCInLFxuICAgIHF1YWxpdHlMYWJlbDogXCIyNDBwXCIsXG4gICAgYml0cmF0ZTogMTc1MDAwLFxuICAgIGF1ZGlvQml0cmF0ZTogMzIsXG4gIH0sXG5cbiAgMzc6IHtcbiAgICBtaW1lVHlwZTogJ3ZpZGVvL21wNDsgY29kZWNzPVwiSC4yNjQsIGFhY1wiJyxcbiAgICBxdWFsaXR5TGFiZWw6IFwiMTA4MHBcIixcbiAgICBiaXRyYXRlOiAzMDAwMDAwLFxuICAgIGF1ZGlvQml0cmF0ZTogMTkyLFxuICB9LFxuXG4gIDM4OiB7XG4gICAgbWltZVR5cGU6ICd2aWRlby9tcDQ7IGNvZGVjcz1cIkguMjY0LCBhYWNcIicsXG4gICAgcXVhbGl0eUxhYmVsOiBcIjMwNzJwXCIsXG4gICAgYml0cmF0ZTogMzUwMDAwMCxcbiAgICBhdWRpb0JpdHJhdGU6IDE5MixcbiAgfSxcblxuICA0Mzoge1xuICAgIG1pbWVUeXBlOiAndmlkZW8vd2VibTsgY29kZWNzPVwiVlA4LCB2b3JiaXNcIicsXG4gICAgcXVhbGl0eUxhYmVsOiBcIjM2MHBcIixcbiAgICBiaXRyYXRlOiA1MDAwMDAsXG4gICAgYXVkaW9CaXRyYXRlOiAxMjgsXG4gIH0sXG5cbiAgNDQ6IHtcbiAgICBtaW1lVHlwZTogJ3ZpZGVvL3dlYm07IGNvZGVjcz1cIlZQOCwgdm9yYmlzXCInLFxuICAgIHF1YWxpdHlMYWJlbDogXCI0ODBwXCIsXG4gICAgYml0cmF0ZTogMTAwMDAwMCxcbiAgICBhdWRpb0JpdHJhdGU6IDEyOCxcbiAgfSxcblxuICA0NToge1xuICAgIG1pbWVUeXBlOiAndmlkZW8vd2VibTsgY29kZWNzPVwiVlA4LCB2b3JiaXNcIicsXG4gICAgcXVhbGl0eUxhYmVsOiBcIjcyMHBcIixcbiAgICBiaXRyYXRlOiAyMDAwMDAwLFxuICAgIGF1ZGlvQml0cmF0ZTogMTkyLFxuICB9LFxuXG4gIDQ2OiB7XG4gICAgbWltZVR5cGU6ICdhdWRpby93ZWJtOyBjb2RlY3M9XCJ2cDgsIHZvcmJpc1wiJyxcbiAgICBxdWFsaXR5TGFiZWw6IFwiMTA4MHBcIixcbiAgICBiaXRyYXRlOiBudWxsLFxuICAgIGF1ZGlvQml0cmF0ZTogMTkyLFxuICB9LFxuXG4gIDgyOiB7XG4gICAgbWltZVR5cGU6ICd2aWRlby9tcDQ7IGNvZGVjcz1cIkguMjY0LCBhYWNcIicsXG4gICAgcXVhbGl0eUxhYmVsOiBcIjM2MHBcIixcbiAgICBiaXRyYXRlOiA1MDAwMDAsXG4gICAgYXVkaW9CaXRyYXRlOiA5NixcbiAgfSxcblxuICA4Mzoge1xuICAgIG1pbWVUeXBlOiAndmlkZW8vbXA0OyBjb2RlY3M9XCJILjI2NCwgYWFjXCInLFxuICAgIHF1YWxpdHlMYWJlbDogXCIyNDBwXCIsXG4gICAgYml0cmF0ZTogNTAwMDAwLFxuICAgIGF1ZGlvQml0cmF0ZTogOTYsXG4gIH0sXG5cbiAgODQ6IHtcbiAgICBtaW1lVHlwZTogJ3ZpZGVvL21wNDsgY29kZWNzPVwiSC4yNjQsIGFhY1wiJyxcbiAgICBxdWFsaXR5TGFiZWw6IFwiNzIwcFwiLFxuICAgIGJpdHJhdGU6IDIwMDAwMDAsXG4gICAgYXVkaW9CaXRyYXRlOiAxOTIsXG4gIH0sXG5cbiAgODU6IHtcbiAgICBtaW1lVHlwZTogJ3ZpZGVvL21wNDsgY29kZWNzPVwiSC4yNjQsIGFhY1wiJyxcbiAgICBxdWFsaXR5TGFiZWw6IFwiMTA4MHBcIixcbiAgICBiaXRyYXRlOiAzMDAwMDAwLFxuICAgIGF1ZGlvQml0cmF0ZTogMTkyLFxuICB9LFxuXG4gIDkxOiB7XG4gICAgbWltZVR5cGU6ICd2aWRlby90czsgY29kZWNzPVwiSC4yNjQsIGFhY1wiJyxcbiAgICBxdWFsaXR5TGFiZWw6IFwiMTQ0cFwiLFxuICAgIGJpdHJhdGU6IDEwMDAwMCxcbiAgICBhdWRpb0JpdHJhdGU6IDQ4LFxuICB9LFxuXG4gIDkyOiB7XG4gICAgbWltZVR5cGU6ICd2aWRlby90czsgY29kZWNzPVwiSC4yNjQsIGFhY1wiJyxcbiAgICBxdWFsaXR5TGFiZWw6IFwiMjQwcFwiLFxuICAgIGJpdHJhdGU6IDE1MDAwMCxcbiAgICBhdWRpb0JpdHJhdGU6IDQ4LFxuICB9LFxuXG4gIDkzOiB7XG4gICAgbWltZVR5cGU6ICd2aWRlby90czsgY29kZWNzPVwiSC4yNjQsIGFhY1wiJyxcbiAgICBxdWFsaXR5TGFiZWw6IFwiMzYwcFwiLFxuICAgIGJpdHJhdGU6IDUwMDAwMCxcbiAgICBhdWRpb0JpdHJhdGU6IDEyOCxcbiAgfSxcblxuICA5NDoge1xuICAgIG1pbWVUeXBlOiAndmlkZW8vdHM7IGNvZGVjcz1cIkguMjY0LCBhYWNcIicsXG4gICAgcXVhbGl0eUxhYmVsOiBcIjQ4MHBcIixcbiAgICBiaXRyYXRlOiA4MDAwMDAsXG4gICAgYXVkaW9CaXRyYXRlOiAxMjgsXG4gIH0sXG5cbiAgOTU6IHtcbiAgICBtaW1lVHlwZTogJ3ZpZGVvL3RzOyBjb2RlY3M9XCJILjI2NCwgYWFjXCInLFxuICAgIHF1YWxpdHlMYWJlbDogXCI3MjBwXCIsXG4gICAgYml0cmF0ZTogMTUwMDAwMCxcbiAgICBhdWRpb0JpdHJhdGU6IDI1NixcbiAgfSxcblxuICA5Njoge1xuICAgIG1pbWVUeXBlOiAndmlkZW8vdHM7IGNvZGVjcz1cIkguMjY0LCBhYWNcIicsXG4gICAgcXVhbGl0eUxhYmVsOiBcIjEwODBwXCIsXG4gICAgYml0cmF0ZTogMjUwMDAwMCxcbiAgICBhdWRpb0JpdHJhdGU6IDI1NixcbiAgfSxcblxuICAxMDA6IHtcbiAgICBtaW1lVHlwZTogJ2F1ZGlvL3dlYm07IGNvZGVjcz1cIlZQOCwgdm9yYmlzXCInLFxuICAgIHF1YWxpdHlMYWJlbDogXCIzNjBwXCIsXG4gICAgYml0cmF0ZTogbnVsbCxcbiAgICBhdWRpb0JpdHJhdGU6IDEyOCxcbiAgfSxcblxuICAxMDE6IHtcbiAgICBtaW1lVHlwZTogJ2F1ZGlvL3dlYm07IGNvZGVjcz1cIlZQOCwgdm9yYmlzXCInLFxuICAgIHF1YWxpdHlMYWJlbDogXCIzNjBwXCIsXG4gICAgYml0cmF0ZTogbnVsbCxcbiAgICBhdWRpb0JpdHJhdGU6IDE5MixcbiAgfSxcblxuICAxMDI6IHtcbiAgICBtaW1lVHlwZTogJ2F1ZGlvL3dlYm07IGNvZGVjcz1cIlZQOCwgdm9yYmlzXCInLFxuICAgIHF1YWxpdHlMYWJlbDogXCI3MjBwXCIsXG4gICAgYml0cmF0ZTogbnVsbCxcbiAgICBhdWRpb0JpdHJhdGU6IDE5MixcbiAgfSxcblxuICAxMjA6IHtcbiAgICBtaW1lVHlwZTogJ3ZpZGVvL2ZsdjsgY29kZWNzPVwiSC4yNjQsIGFhY1wiJyxcbiAgICBxdWFsaXR5TGFiZWw6IFwiNzIwcFwiLFxuICAgIGJpdHJhdGU6IDIwMDAwMDAsXG4gICAgYXVkaW9CaXRyYXRlOiAxMjgsXG4gIH0sXG5cbiAgMTI3OiB7XG4gICAgbWltZVR5cGU6ICdhdWRpby90czsgY29kZWNzPVwiYWFjXCInLFxuICAgIHF1YWxpdHlMYWJlbDogbnVsbCxcbiAgICBiaXRyYXRlOiBudWxsLFxuICAgIGF1ZGlvQml0cmF0ZTogOTYsXG4gIH0sXG5cbiAgMTI4OiB7XG4gICAgbWltZVR5cGU6ICdhdWRpby90czsgY29kZWNzPVwiYWFjXCInLFxuICAgIHF1YWxpdHlMYWJlbDogbnVsbCxcbiAgICBiaXRyYXRlOiBudWxsLFxuICAgIGF1ZGlvQml0cmF0ZTogOTYsXG4gIH0sXG5cbiAgMTMyOiB7XG4gICAgbWltZVR5cGU6ICd2aWRlby90czsgY29kZWNzPVwiSC4yNjQsIGFhY1wiJyxcbiAgICBxdWFsaXR5TGFiZWw6IFwiMjQwcFwiLFxuICAgIGJpdHJhdGU6IDE1MDAwMCxcbiAgICBhdWRpb0JpdHJhdGU6IDQ4LFxuICB9LFxuXG4gIDEzMzoge1xuICAgIG1pbWVUeXBlOiAndmlkZW8vbXA0OyBjb2RlY3M9XCJILjI2NFwiJyxcbiAgICBxdWFsaXR5TGFiZWw6IFwiMjQwcFwiLFxuICAgIGJpdHJhdGU6IDIwMDAwMCxcbiAgICBhdWRpb0JpdHJhdGU6IG51bGwsXG4gIH0sXG5cbiAgMTM0OiB7XG4gICAgbWltZVR5cGU6ICd2aWRlby9tcDQ7IGNvZGVjcz1cIkguMjY0XCInLFxuICAgIHF1YWxpdHlMYWJlbDogXCIzNjBwXCIsXG4gICAgYml0cmF0ZTogMzAwMDAwLFxuICAgIGF1ZGlvQml0cmF0ZTogbnVsbCxcbiAgfSxcblxuICAxMzU6IHtcbiAgICBtaW1lVHlwZTogJ3ZpZGVvL21wNDsgY29kZWNzPVwiSC4yNjRcIicsXG4gICAgcXVhbGl0eUxhYmVsOiBcIjQ4MHBcIixcbiAgICBiaXRyYXRlOiA1MDAwMDAsXG4gICAgYXVkaW9CaXRyYXRlOiBudWxsLFxuICB9LFxuXG4gIDEzNjoge1xuICAgIG1pbWVUeXBlOiAndmlkZW8vbXA0OyBjb2RlY3M9XCJILjI2NFwiJyxcbiAgICBxdWFsaXR5TGFiZWw6IFwiNzIwcFwiLFxuICAgIGJpdHJhdGU6IDEwMDAwMDAsXG4gICAgYXVkaW9CaXRyYXRlOiBudWxsLFxuICB9LFxuXG4gIDEzNzoge1xuICAgIG1pbWVUeXBlOiAndmlkZW8vbXA0OyBjb2RlY3M9XCJILjI2NFwiJyxcbiAgICBxdWFsaXR5TGFiZWw6IFwiMTA4MHBcIixcbiAgICBiaXRyYXRlOiAyNTAwMDAwLFxuICAgIGF1ZGlvQml0cmF0ZTogbnVsbCxcbiAgfSxcblxuICAxMzg6IHtcbiAgICBtaW1lVHlwZTogJ3ZpZGVvL21wNDsgY29kZWNzPVwiSC4yNjRcIicsXG4gICAgcXVhbGl0eUxhYmVsOiBcIjQzMjBwXCIsXG4gICAgYml0cmF0ZTogMTM1MDAwMDAsXG4gICAgYXVkaW9CaXRyYXRlOiBudWxsLFxuICB9LFxuXG4gIDEzOToge1xuICAgIG1pbWVUeXBlOiAnYXVkaW8vbXA0OyBjb2RlY3M9XCJhYWNcIicsXG4gICAgcXVhbGl0eUxhYmVsOiBudWxsLFxuICAgIGJpdHJhdGU6IG51bGwsXG4gICAgYXVkaW9CaXRyYXRlOiA0OCxcbiAgfSxcblxuICAxNDA6IHtcbiAgICBtaW1lVHlwZTogJ2F1ZGlvL200YTsgY29kZWNzPVwiYWFjXCInLFxuICAgIHF1YWxpdHlMYWJlbDogbnVsbCxcbiAgICBiaXRyYXRlOiBudWxsLFxuICAgIGF1ZGlvQml0cmF0ZTogMTI4LFxuICB9LFxuXG4gIDE0MToge1xuICAgIG1pbWVUeXBlOiAnYXVkaW8vbXA0OyBjb2RlY3M9XCJhYWNcIicsXG4gICAgcXVhbGl0eUxhYmVsOiBudWxsLFxuICAgIGJpdHJhdGU6IG51bGwsXG4gICAgYXVkaW9CaXRyYXRlOiAyNTYsXG4gIH0sXG5cbiAgMTUxOiB7XG4gICAgbWltZVR5cGU6ICd2aWRlby90czsgY29kZWNzPVwiSC4yNjQsIGFhY1wiJyxcbiAgICBxdWFsaXR5TGFiZWw6IFwiNzIwcFwiLFxuICAgIGJpdHJhdGU6IDUwMDAwLFxuICAgIGF1ZGlvQml0cmF0ZTogMjQsXG4gIH0sXG5cbiAgMTYwOiB7XG4gICAgbWltZVR5cGU6ICd2aWRlby9tcDQ7IGNvZGVjcz1cIkguMjY0XCInLFxuICAgIHF1YWxpdHlMYWJlbDogXCIxNDRwXCIsXG4gICAgYml0cmF0ZTogMTAwMDAwLFxuICAgIGF1ZGlvQml0cmF0ZTogbnVsbCxcbiAgfSxcblxuICAxNzE6IHtcbiAgICBtaW1lVHlwZTogJ2F1ZGlvL3dlYm07IGNvZGVjcz1cInZvcmJpc1wiJyxcbiAgICBxdWFsaXR5TGFiZWw6IG51bGwsXG4gICAgYml0cmF0ZTogbnVsbCxcbiAgICBhdWRpb0JpdHJhdGU6IDEyOCxcbiAgfSxcblxuICAxNzI6IHtcbiAgICBtaW1lVHlwZTogJ2F1ZGlvL3dlYm07IGNvZGVjcz1cInZvcmJpc1wiJyxcbiAgICBxdWFsaXR5TGFiZWw6IG51bGwsXG4gICAgYml0cmF0ZTogbnVsbCxcbiAgICBhdWRpb0JpdHJhdGU6IDE5MixcbiAgfSxcblxuICAyMzE6IHtcbiAgICBtaW1lVHlwZTogJ3ZpZGVvL3RzOyBjb2RlY3M9XCJILjI2NCwgYWFjXCInLFxuICAgIHF1YWxpdHlMYWJlbDogXCI0ODBwXCIsXG4gICAgYml0cmF0ZTogNTAwMDAwLFxuICAgIGF1ZGlvQml0cmF0ZTogbnVsbCxcbiAgfSxcblxuICAyMzI6IHtcbiAgICBtaW1lVHlwZTogJ3ZpZGVvL3RzOyBjb2RlY3M9XCJILjI2NCwgYWFjXCInLFxuICAgIHF1YWxpdHlMYWJlbDogXCI3MjBwXCIsXG4gICAgYml0cmF0ZTogODAwMDAwLFxuICAgIGF1ZGlvQml0cmF0ZTogbnVsbCxcbiAgfSxcblxuICAyNDI6IHtcbiAgICBtaW1lVHlwZTogJ3ZpZGVvL3dlYm07IGNvZGVjcz1cIlZQOVwiJyxcbiAgICBxdWFsaXR5TGFiZWw6IFwiMjQwcFwiLFxuICAgIGJpdHJhdGU6IDEwMDAwMCxcbiAgICBhdWRpb0JpdHJhdGU6IG51bGwsXG4gIH0sXG5cbiAgMjQzOiB7XG4gICAgbWltZVR5cGU6ICd2aWRlby93ZWJtOyBjb2RlY3M9XCJWUDlcIicsXG4gICAgcXVhbGl0eUxhYmVsOiBcIjM2MHBcIixcbiAgICBiaXRyYXRlOiAyNTAwMDAsXG4gICAgYXVkaW9CaXRyYXRlOiBudWxsLFxuICB9LFxuXG4gIDI0NDoge1xuICAgIG1pbWVUeXBlOiAndmlkZW8vd2VibTsgY29kZWNzPVwiVlA5XCInLFxuICAgIHF1YWxpdHlMYWJlbDogXCI0ODBwXCIsXG4gICAgYml0cmF0ZTogNTAwMDAwLFxuICAgIGF1ZGlvQml0cmF0ZTogbnVsbCxcbiAgfSxcblxuICAyNDc6IHtcbiAgICBtaW1lVHlwZTogJ3ZpZGVvL3dlYm07IGNvZGVjcz1cIlZQOVwiJyxcbiAgICBxdWFsaXR5TGFiZWw6IFwiNzIwcFwiLFxuICAgIGJpdHJhdGU6IDcwMDAwMCxcbiAgICBhdWRpb0JpdHJhdGU6IG51bGwsXG4gIH0sXG5cbiAgMjQ4OiB7XG4gICAgbWltZVR5cGU6ICd2aWRlby93ZWJtOyBjb2RlY3M9XCJWUDlcIicsXG4gICAgcXVhbGl0eUxhYmVsOiBcIjEwODBwXCIsXG4gICAgYml0cmF0ZTogMTUwMDAwMCxcbiAgICBhdWRpb0JpdHJhdGU6IG51bGwsXG4gIH0sXG5cbiAgMjQ5OiB7XG4gICAgbWltZVR5cGU6ICdhdWRpby93ZWJtOyBjb2RlY3M9XCJvcHVzXCInLFxuICAgIHF1YWxpdHlMYWJlbDogbnVsbCxcbiAgICBiaXRyYXRlOiBudWxsLFxuICAgIGF1ZGlvQml0cmF0ZTogNDgsXG4gIH0sXG5cbiAgMjUwOiB7XG4gICAgbWltZVR5cGU6ICdhdWRpby93ZWJtOyBjb2RlY3M9XCJvcHVzXCInLFxuICAgIHF1YWxpdHlMYWJlbDogbnVsbCxcbiAgICBiaXRyYXRlOiBudWxsLFxuICAgIGF1ZGlvQml0cmF0ZTogNjQsXG4gIH0sXG5cbiAgMjUxOiB7XG4gICAgbWltZVR5cGU6ICdhdWRpby93ZWJtOyBjb2RlY3M9XCJvcHVzXCInLFxuICAgIHF1YWxpdHlMYWJlbDogbnVsbCxcbiAgICBiaXRyYXRlOiBudWxsLFxuICAgIGF1ZGlvQml0cmF0ZTogMTYwLFxuICB9LFxuXG4gIDI2NDoge1xuICAgIG1pbWVUeXBlOiAndmlkZW8vbXA0OyBjb2RlY3M9XCJILjI2NFwiJyxcbiAgICBxdWFsaXR5TGFiZWw6IFwiMTQ0MHBcIixcbiAgICBiaXRyYXRlOiA0MDAwMDAwLFxuICAgIGF1ZGlvQml0cmF0ZTogbnVsbCxcbiAgfSxcblxuICAyNjY6IHtcbiAgICBtaW1lVHlwZTogJ3ZpZGVvL21wNDsgY29kZWNzPVwiSC4yNjRcIicsXG4gICAgcXVhbGl0eUxhYmVsOiBcIjIxNjBwXCIsXG4gICAgYml0cmF0ZTogMTI1MDAwMDAsXG4gICAgYXVkaW9CaXRyYXRlOiBudWxsLFxuICB9LFxuXG4gIDI3MDoge1xuICAgIG1pbWVUeXBlOiAndmlkZW8vbXA0OyBjb2RlY3M9XCJILjI2NFwiJyxcbiAgICBxdWFsaXR5TGFiZWw6IFwiMTA4MHBcIixcbiAgICBiaXRyYXRlOiAyNTAwMDAwLFxuICAgIGF1ZGlvQml0cmF0ZTogbnVsbCxcbiAgfSxcblxuICAyNzE6IHtcbiAgICBtaW1lVHlwZTogJ3ZpZGVvL3dlYm07IGNvZGVjcz1cIlZQOVwiJyxcbiAgICBxdWFsaXR5TGFiZWw6IFwiMTQ0MHBcIixcbiAgICBiaXRyYXRlOiA5MDAwMDAwLFxuICAgIGF1ZGlvQml0cmF0ZTogbnVsbCxcbiAgfSxcblxuICAyNzI6IHtcbiAgICBtaW1lVHlwZTogJ3ZpZGVvL3dlYm07IGNvZGVjcz1cIlZQOVwiJyxcbiAgICBxdWFsaXR5TGFiZWw6IFwiNDMyMHBcIixcbiAgICBiaXRyYXRlOiAyMDAwMDAwMCxcbiAgICBhdWRpb0JpdHJhdGU6IG51bGwsXG4gIH0sXG5cbiAgMjc4OiB7XG4gICAgbWltZVR5cGU6ICd2aWRlby93ZWJtOyBjb2RlY3M9XCJWUDlcIicsXG4gICAgcXVhbGl0eUxhYmVsOiBcIjE0NHAgMzBmcHNcIixcbiAgICBiaXRyYXRlOiA4MDAwMCxcbiAgICBhdWRpb0JpdHJhdGU6IG51bGwsXG4gIH0sXG5cbiAgMjk4OiB7XG4gICAgbWltZVR5cGU6ICd2aWRlby9tcDQ7IGNvZGVjcz1cIkguMjY0XCInLFxuICAgIHF1YWxpdHlMYWJlbDogXCI3MjBwXCIsXG4gICAgYml0cmF0ZTogMzAwMDAwMCxcbiAgICBhdWRpb0JpdHJhdGU6IG51bGwsXG4gIH0sXG5cbiAgMjk5OiB7XG4gICAgbWltZVR5cGU6ICd2aWRlby9tcDQ7IGNvZGVjcz1cIkguMjY0XCInLFxuICAgIHF1YWxpdHlMYWJlbDogXCIxMDgwcFwiLFxuICAgIGJpdHJhdGU6IDU1MDAwMDAsXG4gICAgYXVkaW9CaXRyYXRlOiBudWxsLFxuICB9LFxuXG4gIDMwMDoge1xuICAgIG1pbWVUeXBlOiAndmlkZW8vdHM7IGNvZGVjcz1cIkguMjY0LCBhYWNcIicsXG4gICAgcXVhbGl0eUxhYmVsOiBcIjcyMHBcIixcbiAgICBiaXRyYXRlOiAxMzE4MDAwLFxuICAgIGF1ZGlvQml0cmF0ZTogNDgsXG4gIH0sXG5cbiAgMzAxOiB7XG4gICAgbWltZVR5cGU6ICd2aWRlby90czsgY29kZWNzPVwiSC4yNjQsIGFhY1wiJyxcbiAgICBxdWFsaXR5TGFiZWw6IFwiMTA4MHBcIixcbiAgICBiaXRyYXRlOiAzMDAwMDAwLFxuICAgIGF1ZGlvQml0cmF0ZTogMTI4LFxuICB9LFxuXG4gIDMwMjoge1xuICAgIG1pbWVUeXBlOiAndmlkZW8vd2VibTsgY29kZWNzPVwiVlA5XCInLFxuICAgIHF1YWxpdHlMYWJlbDogXCI3MjBwIEhGUlwiLFxuICAgIGJpdHJhdGU6IDI1MDAwMDAsXG4gICAgYXVkaW9CaXRyYXRlOiBudWxsLFxuICB9LFxuXG4gIDMwMzoge1xuICAgIG1pbWVUeXBlOiAndmlkZW8vd2VibTsgY29kZWNzPVwiVlA5XCInLFxuICAgIHF1YWxpdHlMYWJlbDogXCIxMDgwcCBIRlJcIixcbiAgICBiaXRyYXRlOiA1MDAwMDAwLFxuICAgIGF1ZGlvQml0cmF0ZTogbnVsbCxcbiAgfSxcblxuICAzMDg6IHtcbiAgICBtaW1lVHlwZTogJ3ZpZGVvL3dlYm07IGNvZGVjcz1cIlZQOVwiJyxcbiAgICBxdWFsaXR5TGFiZWw6IFwiMTQ0MHAgSEZSXCIsXG4gICAgYml0cmF0ZTogMTAwMDAwMDAsXG4gICAgYXVkaW9CaXRyYXRlOiBudWxsLFxuICB9LFxuXG4gIDMxMToge1xuICAgIG1pbWVUeXBlOiAndmlkZW8vd2VibTsgY29kZWNzPVwiVlA5XCInLFxuICAgIHF1YWxpdHlMYWJlbDogXCI3MjBwXCIsXG4gICAgYml0cmF0ZTogMTI1MDAwMCxcbiAgICBhdWRpb0JpdHJhdGU6IG51bGwsXG4gIH0sXG5cbiAgMzEyOiB7XG4gICAgbWltZVR5cGU6ICd2aWRlby9tcDQ7IGNvZGVjcz1cIkguMjY0XCInLFxuICAgIHF1YWxpdHlMYWJlbDogXCIxMDgwcFwiLFxuICAgIGJpdHJhdGU6IDI1MDAwMDAsXG4gICAgYXVkaW9CaXRyYXRlOiBudWxsLFxuICB9LFxuXG4gIDMxMzoge1xuICAgIG1pbWVUeXBlOiAndmlkZW8vd2VibTsgY29kZWNzPVwiVlA5XCInLFxuICAgIHF1YWxpdHlMYWJlbDogXCIyMTYwcFwiLFxuICAgIGJpdHJhdGU6IDEzMDAwMDAwLFxuICAgIGF1ZGlvQml0cmF0ZTogbnVsbCxcbiAgfSxcblxuICAzMTU6IHtcbiAgICBtaW1lVHlwZTogJ3ZpZGVvL3dlYm07IGNvZGVjcz1cIlZQOVwiJyxcbiAgICBxdWFsaXR5TGFiZWw6IFwiMjE2MHAgSEZSXCIsXG4gICAgYml0cmF0ZTogMjAwMDAwMDAsXG4gICAgYXVkaW9CaXRyYXRlOiBudWxsLFxuICB9LFxuXG4gIDMzMDoge1xuICAgIG1pbWVUeXBlOiAndmlkZW8vd2VibTsgY29kZWNzPVwiVlA5XCInLFxuICAgIHF1YWxpdHlMYWJlbDogXCIxNDRwIEhEUiwgSEZSXCIsXG4gICAgYml0cmF0ZTogODAwMDAsXG4gICAgYXVkaW9CaXRyYXRlOiBudWxsLFxuICB9LFxuXG4gIDMzMToge1xuICAgIG1pbWVUeXBlOiAndmlkZW8vd2VibTsgY29kZWNzPVwiVlA5XCInLFxuICAgIHF1YWxpdHlMYWJlbDogXCIyNDBwIEhEUiwgSEZSXCIsXG4gICAgYml0cmF0ZTogMTAwMDAwLFxuICAgIGF1ZGlvQml0cmF0ZTogbnVsbCxcbiAgfSxcblxuICAzMzI6IHtcbiAgICBtaW1lVHlwZTogJ3ZpZGVvL3dlYm07IGNvZGVjcz1cIlZQOVwiJyxcbiAgICBxdWFsaXR5TGFiZWw6IFwiMzYwcCBIRFIsIEhGUlwiLFxuICAgIGJpdHJhdGU6IDI1MDAwMCxcbiAgICBhdWRpb0JpdHJhdGU6IG51bGwsXG4gIH0sXG5cbiAgMzMzOiB7XG4gICAgbWltZVR5cGU6ICd2aWRlby93ZWJtOyBjb2RlY3M9XCJWUDlcIicsXG4gICAgcXVhbGl0eUxhYmVsOiBcIjI0MHAgSERSLCBIRlJcIixcbiAgICBiaXRyYXRlOiA1MDAwMDAsXG4gICAgYXVkaW9CaXRyYXRlOiBudWxsLFxuICB9LFxuXG4gIDMzNDoge1xuICAgIG1pbWVUeXBlOiAndmlkZW8vd2VibTsgY29kZWNzPVwiVlA5XCInLFxuICAgIHF1YWxpdHlMYWJlbDogXCI3MjBwIEhEUiwgSEZSXCIsXG4gICAgYml0cmF0ZTogMTAwMDAwMCxcbiAgICBhdWRpb0JpdHJhdGU6IG51bGwsXG4gIH0sXG5cbiAgMzM1OiB7XG4gICAgbWltZVR5cGU6ICd2aWRlby93ZWJtOyBjb2RlY3M9XCJWUDlcIicsXG4gICAgcXVhbGl0eUxhYmVsOiBcIjEwODBwIEhEUiwgSEZSXCIsXG4gICAgYml0cmF0ZTogMTUwMDAwMCxcbiAgICBhdWRpb0JpdHJhdGU6IG51bGwsXG4gIH0sXG5cbiAgMzM2OiB7XG4gICAgbWltZVR5cGU6ICd2aWRlby93ZWJtOyBjb2RlY3M9XCJWUDlcIicsXG4gICAgcXVhbGl0eUxhYmVsOiBcIjE0NDBwIEhEUiwgSEZSXCIsXG4gICAgYml0cmF0ZTogNTAwMDAwMCxcbiAgICBhdWRpb0JpdHJhdGU6IG51bGwsXG4gIH0sXG5cbiAgMzM3OiB7XG4gICAgbWltZVR5cGU6ICd2aWRlby93ZWJtOyBjb2RlY3M9XCJWUDlcIicsXG4gICAgcXVhbGl0eUxhYmVsOiBcIjIxNjBwIEhEUiwgSEZSXCIsXG4gICAgYml0cmF0ZTogMTIwMDAwMDAsXG4gICAgYXVkaW9CaXRyYXRlOiBudWxsLFxuICB9LFxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@distube/ytdl-core/lib/formats.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@distube/ytdl-core/lib/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@distube/ytdl-core/lib/index.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const PassThrough = (__webpack_require__(/*! stream */ \"stream\").PassThrough);\nconst getInfo = __webpack_require__(/*! ./info */ \"(rsc)/./node_modules/@distube/ytdl-core/lib/info.js\");\nconst utils = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/@distube/ytdl-core/lib/utils.js\");\nconst formatUtils = __webpack_require__(/*! ./format-utils */ \"(rsc)/./node_modules/@distube/ytdl-core/lib/format-utils.js\");\nconst urlUtils = __webpack_require__(/*! ./url-utils */ \"(rsc)/./node_modules/@distube/ytdl-core/lib/url-utils.js\");\nconst miniget = __webpack_require__(/*! miniget */ \"(rsc)/./node_modules/miniget/dist/index.js\");\nconst m3u8stream = __webpack_require__(/*! m3u8stream */ \"(rsc)/./node_modules/m3u8stream/dist/index.js\");\nconst { parseTimestamp } = __webpack_require__(/*! m3u8stream */ \"(rsc)/./node_modules/m3u8stream/dist/index.js\");\nconst agent = __webpack_require__(/*! ./agent */ \"(rsc)/./node_modules/@distube/ytdl-core/lib/agent.js\");\n\n/**\n * @param {string} link\n * @param {!Object} options\n * @returns {ReadableStream}\n */\nconst ytdl = (link, options) => {\n  const stream = createStream(options);\n  ytdl.getInfo(link, options).then(\n    info => {\n      downloadFromInfoCallback(stream, info, options);\n    },\n    stream.emit.bind(stream, \"error\"),\n  );\n  return stream;\n};\nmodule.exports = ytdl;\n\nytdl.getBasicInfo = getInfo.getBasicInfo;\nytdl.getInfo = getInfo.getInfo;\nytdl.chooseFormat = formatUtils.chooseFormat;\nytdl.filterFormats = formatUtils.filterFormats;\nytdl.validateID = urlUtils.validateID;\nytdl.validateURL = urlUtils.validateURL;\nytdl.getURLVideoID = urlUtils.getURLVideoID;\nytdl.getVideoID = urlUtils.getVideoID;\nytdl.createAgent = agent.createAgent;\nytdl.createProxyAgent = agent.createProxyAgent;\nytdl.cache = {\n  info: getInfo.cache,\n  watch: getInfo.watchPageCache,\n};\nytdl.version = (__webpack_require__(/*! ../package.json */ \"(rsc)/./node_modules/@distube/ytdl-core/package.json\").version);\n\nconst createStream = options => {\n  const stream = new PassThrough({ highWaterMark: options?.highWaterMark || 1024 * 512 });\n  stream._destroy = () => {\n    stream.destroyed = true;\n  };\n  return stream;\n};\n\nconst pipeAndSetEvents = (req, stream, end) => {\n  // Forward events from the request to the stream.\n  [\"abort\", \"request\", \"response\", \"error\", \"redirect\", \"retry\", \"reconnect\"].forEach(event => {\n    req.prependListener(event, stream.emit.bind(stream, event));\n  });\n  req.pipe(stream, { end });\n};\n\n/**\n * Chooses a format to download.\n *\n * @param {stream.Readable} stream\n * @param {Object} info\n * @param {Object} options\n */\nconst downloadFromInfoCallback = (stream, info, options) => {\n  options = options || {};\n\n  let err = utils.playError(info.player_response);\n  if (err) {\n    stream.emit(\"error\", err);\n    return;\n  }\n\n  if (!info.formats.length) {\n    stream.emit(\"error\", Error(\"This video is unavailable\"));\n    return;\n  }\n\n  let format;\n  try {\n    format = formatUtils.chooseFormat(info.formats, options);\n  } catch (e) {\n    stream.emit(\"error\", e);\n    return;\n  }\n  stream.emit(\"info\", info, format);\n  if (stream.destroyed) {\n    return;\n  }\n\n  let contentLength,\n    downloaded = 0;\n  const ondata = chunk => {\n    downloaded += chunk.length;\n    stream.emit(\"progress\", chunk.length, downloaded, contentLength);\n  };\n\n  utils.applyDefaultHeaders(options);\n  if (options.IPv6Block) {\n    options.requestOptions = Object.assign({}, options.requestOptions, {\n      localAddress: utils.getRandomIPv6(options.IPv6Block),\n    });\n  }\n\n  if (options.agent) {\n    // Set agent on both the miniget and m3u8stream requests\n    options.requestOptions.agent = options.agent.agent;\n\n    if (options.agent.jar) {\n      utils.setPropInsensitive(\n        options.requestOptions.headers,\n        \"cookie\",\n        options.agent.jar.getCookieStringSync(\"https://www.youtube.com\"),\n      );\n    }\n    if (options.agent.localAddress) {\n      options.requestOptions.localAddress = options.agent.localAddress;\n    }\n  }\n\n  // Download the file in chunks, in this case the default is 10MB,\n  // anything over this will cause youtube to throttle the download\n  const dlChunkSize = typeof options.dlChunkSize === \"number\" ? options.dlChunkSize : 1024 * 1024 * 10;\n  let req;\n  let shouldEnd = true;\n\n  if (format.isHLS || format.isDashMPD) {\n    req = m3u8stream(format.url, {\n      chunkReadahead: +info.live_chunk_readahead,\n      begin: options.begin || (format.isLive && Date.now()),\n      liveBuffer: options.liveBuffer,\n      // Now we have passed not only custom \"dispatcher\" with undici ProxyAgent, but also \"agent\" field which is compatible for node http\n      requestOptions: options.requestOptions,\n      parser: format.isDashMPD ? \"dash-mpd\" : \"m3u8\",\n      id: format.itag,\n    });\n\n    req.on(\"progress\", (segment, totalSegments) => {\n      stream.emit(\"progress\", segment.size, segment.num, totalSegments);\n    });\n    pipeAndSetEvents(req, stream, shouldEnd);\n  } else {\n    const requestOptions = Object.assign({}, options.requestOptions, {\n      maxReconnects: 6,\n      maxRetries: 3,\n      backoff: { inc: 500, max: 10000 },\n    });\n\n    let shouldBeChunked = dlChunkSize !== 0 && (!format.hasAudio || !format.hasVideo);\n\n    if (shouldBeChunked) {\n      let start = options.range?.start || 0;\n      let end = start + dlChunkSize;\n      const rangeEnd = options.range?.end;\n\n      contentLength = options.range\n        ? (rangeEnd ? rangeEnd + 1 : parseInt(format.contentLength)) - start\n        : parseInt(format.contentLength);\n\n      const getNextChunk = () => {\n        if (stream.destroyed) return;\n        if (!rangeEnd && end >= contentLength) end = 0;\n        if (rangeEnd && end > rangeEnd) end = rangeEnd;\n        shouldEnd = !end || end === rangeEnd;\n\n        requestOptions.headers = Object.assign({}, requestOptions.headers, {\n          Range: `bytes=${start}-${end || \"\"}`,\n        });\n        req = miniget(format.url, requestOptions);\n        req.on(\"data\", ondata);\n        req.on(\"end\", () => {\n          if (stream.destroyed) return;\n          if (end && end !== rangeEnd) {\n            start = end + 1;\n            end += dlChunkSize;\n            getNextChunk();\n          }\n        });\n        pipeAndSetEvents(req, stream, shouldEnd);\n      };\n      getNextChunk();\n    } else {\n      // Audio only and video only formats don't support begin\n      if (options.begin) {\n        format.url += `&begin=${parseTimestamp(options.begin)}`;\n      }\n      if (options.range?.start || options.range?.end) {\n        requestOptions.headers = Object.assign({}, requestOptions.headers, {\n          Range: `bytes=${options.range.start || \"0\"}-${options.range.end || \"\"}`,\n        });\n      }\n      req = miniget(format.url, requestOptions);\n      req.on(\"response\", res => {\n        if (stream.destroyed) return;\n        contentLength = contentLength || parseInt(res.headers[\"content-length\"]);\n      });\n      req.on(\"data\", ondata);\n      pipeAndSetEvents(req, stream, shouldEnd);\n    }\n  }\n\n  stream._destroy = () => {\n    stream.destroyed = true;\n    if (req) {\n      req.destroy();\n      req.end();\n    }\n  };\n};\n\n/**\n * Can be used to download video after its `info` is gotten through\n * `ytdl.getInfo()`. In case the user might want to look at the\n * `info` object before deciding to download.\n *\n * @param {Object} info\n * @param {!Object} options\n * @returns {ReadableStream}\n */\nytdl.downloadFromInfo = (info, options) => {\n  const stream = createStream(options);\n  if (!info.full) {\n    throw Error(\"Cannot use `ytdl.downloadFromInfo()` when called with info from `ytdl.getBasicInfo()`\");\n  }\n  setImmediate(() => {\n    downloadFromInfoCallback(stream, info, options);\n  });\n  return stream;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGRpc3R1YmUveXRkbC1jb3JlL2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxvQkFBb0IseURBQTZCO0FBQ2pELGdCQUFnQixtQkFBTyxDQUFDLG1FQUFRO0FBQ2hDLGNBQWMsbUJBQU8sQ0FBQyxxRUFBUztBQUMvQixvQkFBb0IsbUJBQU8sQ0FBQyxtRkFBZ0I7QUFDNUMsaUJBQWlCLG1CQUFPLENBQUMsNkVBQWE7QUFDdEMsZ0JBQWdCLG1CQUFPLENBQUMsMkRBQVM7QUFDakMsbUJBQW1CLG1CQUFPLENBQUMsaUVBQVk7QUFDdkMsUUFBUSxpQkFBaUIsRUFBRSxtQkFBTyxDQUFDLGlFQUFZO0FBQy9DLGNBQWMsbUJBQU8sQ0FBQyxxRUFBUzs7QUFFL0I7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw0R0FBa0M7O0FBRWpEO0FBQ0EsbUNBQW1DLHFEQUFxRDtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILHFCQUFxQixLQUFLO0FBQzFCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsSUFBSTtBQUNKLDJDQUEyQztBQUMzQztBQUNBO0FBQ0EsaUJBQWlCLHNCQUFzQjtBQUN2QyxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlEQUFpRDtBQUNqRCwwQkFBMEIsTUFBTSxHQUFHLFVBQVU7QUFDN0MsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLGdDQUFnQyw4QkFBOEI7QUFDOUQ7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRCwwQkFBMEIsMkJBQTJCLEdBQUcsd0JBQXdCO0FBQ2hGLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3l0LWRvd25sb2FkZXIvLi9ub2RlX21vZHVsZXMvQGRpc3R1YmUveXRkbC1jb3JlL2xpYi9pbmRleC5qcz8zNjY5Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IFBhc3NUaHJvdWdoID0gcmVxdWlyZShcInN0cmVhbVwiKS5QYXNzVGhyb3VnaDtcbmNvbnN0IGdldEluZm8gPSByZXF1aXJlKFwiLi9pbmZvXCIpO1xuY29uc3QgdXRpbHMgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbmNvbnN0IGZvcm1hdFV0aWxzID0gcmVxdWlyZShcIi4vZm9ybWF0LXV0aWxzXCIpO1xuY29uc3QgdXJsVXRpbHMgPSByZXF1aXJlKFwiLi91cmwtdXRpbHNcIik7XG5jb25zdCBtaW5pZ2V0ID0gcmVxdWlyZShcIm1pbmlnZXRcIik7XG5jb25zdCBtM3U4c3RyZWFtID0gcmVxdWlyZShcIm0zdThzdHJlYW1cIik7XG5jb25zdCB7IHBhcnNlVGltZXN0YW1wIH0gPSByZXF1aXJlKFwibTN1OHN0cmVhbVwiKTtcbmNvbnN0IGFnZW50ID0gcmVxdWlyZShcIi4vYWdlbnRcIik7XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGxpbmtcbiAqIEBwYXJhbSB7IU9iamVjdH0gb3B0aW9uc1xuICogQHJldHVybnMge1JlYWRhYmxlU3RyZWFtfVxuICovXG5jb25zdCB5dGRsID0gKGxpbmssIG9wdGlvbnMpID0+IHtcbiAgY29uc3Qgc3RyZWFtID0gY3JlYXRlU3RyZWFtKG9wdGlvbnMpO1xuICB5dGRsLmdldEluZm8obGluaywgb3B0aW9ucykudGhlbihcbiAgICBpbmZvID0+IHtcbiAgICAgIGRvd25sb2FkRnJvbUluZm9DYWxsYmFjayhzdHJlYW0sIGluZm8sIG9wdGlvbnMpO1xuICAgIH0sXG4gICAgc3RyZWFtLmVtaXQuYmluZChzdHJlYW0sIFwiZXJyb3JcIiksXG4gICk7XG4gIHJldHVybiBzdHJlYW07XG59O1xubW9kdWxlLmV4cG9ydHMgPSB5dGRsO1xuXG55dGRsLmdldEJhc2ljSW5mbyA9IGdldEluZm8uZ2V0QmFzaWNJbmZvO1xueXRkbC5nZXRJbmZvID0gZ2V0SW5mby5nZXRJbmZvO1xueXRkbC5jaG9vc2VGb3JtYXQgPSBmb3JtYXRVdGlscy5jaG9vc2VGb3JtYXQ7XG55dGRsLmZpbHRlckZvcm1hdHMgPSBmb3JtYXRVdGlscy5maWx0ZXJGb3JtYXRzO1xueXRkbC52YWxpZGF0ZUlEID0gdXJsVXRpbHMudmFsaWRhdGVJRDtcbnl0ZGwudmFsaWRhdGVVUkwgPSB1cmxVdGlscy52YWxpZGF0ZVVSTDtcbnl0ZGwuZ2V0VVJMVmlkZW9JRCA9IHVybFV0aWxzLmdldFVSTFZpZGVvSUQ7XG55dGRsLmdldFZpZGVvSUQgPSB1cmxVdGlscy5nZXRWaWRlb0lEO1xueXRkbC5jcmVhdGVBZ2VudCA9IGFnZW50LmNyZWF0ZUFnZW50O1xueXRkbC5jcmVhdGVQcm94eUFnZW50ID0gYWdlbnQuY3JlYXRlUHJveHlBZ2VudDtcbnl0ZGwuY2FjaGUgPSB7XG4gIGluZm86IGdldEluZm8uY2FjaGUsXG4gIHdhdGNoOiBnZXRJbmZvLndhdGNoUGFnZUNhY2hlLFxufTtcbnl0ZGwudmVyc2lvbiA9IHJlcXVpcmUoXCIuLi9wYWNrYWdlLmpzb25cIikudmVyc2lvbjtcblxuY29uc3QgY3JlYXRlU3RyZWFtID0gb3B0aW9ucyA9PiB7XG4gIGNvbnN0IHN0cmVhbSA9IG5ldyBQYXNzVGhyb3VnaCh7IGhpZ2hXYXRlck1hcms6IG9wdGlvbnM/LmhpZ2hXYXRlck1hcmsgfHwgMTAyNCAqIDUxMiB9KTtcbiAgc3RyZWFtLl9kZXN0cm95ID0gKCkgPT4ge1xuICAgIHN0cmVhbS5kZXN0cm95ZWQgPSB0cnVlO1xuICB9O1xuICByZXR1cm4gc3RyZWFtO1xufTtcblxuY29uc3QgcGlwZUFuZFNldEV2ZW50cyA9IChyZXEsIHN0cmVhbSwgZW5kKSA9PiB7XG4gIC8vIEZvcndhcmQgZXZlbnRzIGZyb20gdGhlIHJlcXVlc3QgdG8gdGhlIHN0cmVhbS5cbiAgW1wiYWJvcnRcIiwgXCJyZXF1ZXN0XCIsIFwicmVzcG9uc2VcIiwgXCJlcnJvclwiLCBcInJlZGlyZWN0XCIsIFwicmV0cnlcIiwgXCJyZWNvbm5lY3RcIl0uZm9yRWFjaChldmVudCA9PiB7XG4gICAgcmVxLnByZXBlbmRMaXN0ZW5lcihldmVudCwgc3RyZWFtLmVtaXQuYmluZChzdHJlYW0sIGV2ZW50KSk7XG4gIH0pO1xuICByZXEucGlwZShzdHJlYW0sIHsgZW5kIH0pO1xufTtcblxuLyoqXG4gKiBDaG9vc2VzIGEgZm9ybWF0IHRvIGRvd25sb2FkLlxuICpcbiAqIEBwYXJhbSB7c3RyZWFtLlJlYWRhYmxlfSBzdHJlYW1cbiAqIEBwYXJhbSB7T2JqZWN0fSBpbmZvXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICovXG5jb25zdCBkb3dubG9hZEZyb21JbmZvQ2FsbGJhY2sgPSAoc3RyZWFtLCBpbmZvLCBvcHRpb25zKSA9PiB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIGxldCBlcnIgPSB1dGlscy5wbGF5RXJyb3IoaW5mby5wbGF5ZXJfcmVzcG9uc2UpO1xuICBpZiAoZXJyKSB7XG4gICAgc3RyZWFtLmVtaXQoXCJlcnJvclwiLCBlcnIpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICghaW5mby5mb3JtYXRzLmxlbmd0aCkge1xuICAgIHN0cmVhbS5lbWl0KFwiZXJyb3JcIiwgRXJyb3IoXCJUaGlzIHZpZGVvIGlzIHVuYXZhaWxhYmxlXCIpKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBsZXQgZm9ybWF0O1xuICB0cnkge1xuICAgIGZvcm1hdCA9IGZvcm1hdFV0aWxzLmNob29zZUZvcm1hdChpbmZvLmZvcm1hdHMsIG9wdGlvbnMpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgc3RyZWFtLmVtaXQoXCJlcnJvclwiLCBlKTtcbiAgICByZXR1cm47XG4gIH1cbiAgc3RyZWFtLmVtaXQoXCJpbmZvXCIsIGluZm8sIGZvcm1hdCk7XG4gIGlmIChzdHJlYW0uZGVzdHJveWVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgbGV0IGNvbnRlbnRMZW5ndGgsXG4gICAgZG93bmxvYWRlZCA9IDA7XG4gIGNvbnN0IG9uZGF0YSA9IGNodW5rID0+IHtcbiAgICBkb3dubG9hZGVkICs9IGNodW5rLmxlbmd0aDtcbiAgICBzdHJlYW0uZW1pdChcInByb2dyZXNzXCIsIGNodW5rLmxlbmd0aCwgZG93bmxvYWRlZCwgY29udGVudExlbmd0aCk7XG4gIH07XG5cbiAgdXRpbHMuYXBwbHlEZWZhdWx0SGVhZGVycyhvcHRpb25zKTtcbiAgaWYgKG9wdGlvbnMuSVB2NkJsb2NrKSB7XG4gICAgb3B0aW9ucy5yZXF1ZXN0T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMucmVxdWVzdE9wdGlvbnMsIHtcbiAgICAgIGxvY2FsQWRkcmVzczogdXRpbHMuZ2V0UmFuZG9tSVB2NihvcHRpb25zLklQdjZCbG9jayksXG4gICAgfSk7XG4gIH1cblxuICBpZiAob3B0aW9ucy5hZ2VudCkge1xuICAgIC8vIFNldCBhZ2VudCBvbiBib3RoIHRoZSBtaW5pZ2V0IGFuZCBtM3U4c3RyZWFtIHJlcXVlc3RzXG4gICAgb3B0aW9ucy5yZXF1ZXN0T3B0aW9ucy5hZ2VudCA9IG9wdGlvbnMuYWdlbnQuYWdlbnQ7XG5cbiAgICBpZiAob3B0aW9ucy5hZ2VudC5qYXIpIHtcbiAgICAgIHV0aWxzLnNldFByb3BJbnNlbnNpdGl2ZShcbiAgICAgICAgb3B0aW9ucy5yZXF1ZXN0T3B0aW9ucy5oZWFkZXJzLFxuICAgICAgICBcImNvb2tpZVwiLFxuICAgICAgICBvcHRpb25zLmFnZW50Lmphci5nZXRDb29raWVTdHJpbmdTeW5jKFwiaHR0cHM6Ly93d3cueW91dHViZS5jb21cIiksXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5hZ2VudC5sb2NhbEFkZHJlc3MpIHtcbiAgICAgIG9wdGlvbnMucmVxdWVzdE9wdGlvbnMubG9jYWxBZGRyZXNzID0gb3B0aW9ucy5hZ2VudC5sb2NhbEFkZHJlc3M7XG4gICAgfVxuICB9XG5cbiAgLy8gRG93bmxvYWQgdGhlIGZpbGUgaW4gY2h1bmtzLCBpbiB0aGlzIGNhc2UgdGhlIGRlZmF1bHQgaXMgMTBNQixcbiAgLy8gYW55dGhpbmcgb3ZlciB0aGlzIHdpbGwgY2F1c2UgeW91dHViZSB0byB0aHJvdHRsZSB0aGUgZG93bmxvYWRcbiAgY29uc3QgZGxDaHVua1NpemUgPSB0eXBlb2Ygb3B0aW9ucy5kbENodW5rU2l6ZSA9PT0gXCJudW1iZXJcIiA/IG9wdGlvbnMuZGxDaHVua1NpemUgOiAxMDI0ICogMTAyNCAqIDEwO1xuICBsZXQgcmVxO1xuICBsZXQgc2hvdWxkRW5kID0gdHJ1ZTtcblxuICBpZiAoZm9ybWF0LmlzSExTIHx8IGZvcm1hdC5pc0Rhc2hNUEQpIHtcbiAgICByZXEgPSBtM3U4c3RyZWFtKGZvcm1hdC51cmwsIHtcbiAgICAgIGNodW5rUmVhZGFoZWFkOiAraW5mby5saXZlX2NodW5rX3JlYWRhaGVhZCxcbiAgICAgIGJlZ2luOiBvcHRpb25zLmJlZ2luIHx8IChmb3JtYXQuaXNMaXZlICYmIERhdGUubm93KCkpLFxuICAgICAgbGl2ZUJ1ZmZlcjogb3B0aW9ucy5saXZlQnVmZmVyLFxuICAgICAgLy8gTm93IHdlIGhhdmUgcGFzc2VkIG5vdCBvbmx5IGN1c3RvbSBcImRpc3BhdGNoZXJcIiB3aXRoIHVuZGljaSBQcm94eUFnZW50LCBidXQgYWxzbyBcImFnZW50XCIgZmllbGQgd2hpY2ggaXMgY29tcGF0aWJsZSBmb3Igbm9kZSBodHRwXG4gICAgICByZXF1ZXN0T3B0aW9uczogb3B0aW9ucy5yZXF1ZXN0T3B0aW9ucyxcbiAgICAgIHBhcnNlcjogZm9ybWF0LmlzRGFzaE1QRCA/IFwiZGFzaC1tcGRcIiA6IFwibTN1OFwiLFxuICAgICAgaWQ6IGZvcm1hdC5pdGFnLFxuICAgIH0pO1xuXG4gICAgcmVxLm9uKFwicHJvZ3Jlc3NcIiwgKHNlZ21lbnQsIHRvdGFsU2VnbWVudHMpID0+IHtcbiAgICAgIHN0cmVhbS5lbWl0KFwicHJvZ3Jlc3NcIiwgc2VnbWVudC5zaXplLCBzZWdtZW50Lm51bSwgdG90YWxTZWdtZW50cyk7XG4gICAgfSk7XG4gICAgcGlwZUFuZFNldEV2ZW50cyhyZXEsIHN0cmVhbSwgc2hvdWxkRW5kKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCByZXF1ZXN0T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMucmVxdWVzdE9wdGlvbnMsIHtcbiAgICAgIG1heFJlY29ubmVjdHM6IDYsXG4gICAgICBtYXhSZXRyaWVzOiAzLFxuICAgICAgYmFja29mZjogeyBpbmM6IDUwMCwgbWF4OiAxMDAwMCB9LFxuICAgIH0pO1xuXG4gICAgbGV0IHNob3VsZEJlQ2h1bmtlZCA9IGRsQ2h1bmtTaXplICE9PSAwICYmICghZm9ybWF0Lmhhc0F1ZGlvIHx8ICFmb3JtYXQuaGFzVmlkZW8pO1xuXG4gICAgaWYgKHNob3VsZEJlQ2h1bmtlZCkge1xuICAgICAgbGV0IHN0YXJ0ID0gb3B0aW9ucy5yYW5nZT8uc3RhcnQgfHwgMDtcbiAgICAgIGxldCBlbmQgPSBzdGFydCArIGRsQ2h1bmtTaXplO1xuICAgICAgY29uc3QgcmFuZ2VFbmQgPSBvcHRpb25zLnJhbmdlPy5lbmQ7XG5cbiAgICAgIGNvbnRlbnRMZW5ndGggPSBvcHRpb25zLnJhbmdlXG4gICAgICAgID8gKHJhbmdlRW5kID8gcmFuZ2VFbmQgKyAxIDogcGFyc2VJbnQoZm9ybWF0LmNvbnRlbnRMZW5ndGgpKSAtIHN0YXJ0XG4gICAgICAgIDogcGFyc2VJbnQoZm9ybWF0LmNvbnRlbnRMZW5ndGgpO1xuXG4gICAgICBjb25zdCBnZXROZXh0Q2h1bmsgPSAoKSA9PiB7XG4gICAgICAgIGlmIChzdHJlYW0uZGVzdHJveWVkKSByZXR1cm47XG4gICAgICAgIGlmICghcmFuZ2VFbmQgJiYgZW5kID49IGNvbnRlbnRMZW5ndGgpIGVuZCA9IDA7XG4gICAgICAgIGlmIChyYW5nZUVuZCAmJiBlbmQgPiByYW5nZUVuZCkgZW5kID0gcmFuZ2VFbmQ7XG4gICAgICAgIHNob3VsZEVuZCA9ICFlbmQgfHwgZW5kID09PSByYW5nZUVuZDtcblxuICAgICAgICByZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0gT2JqZWN0LmFzc2lnbih7fSwgcmVxdWVzdE9wdGlvbnMuaGVhZGVycywge1xuICAgICAgICAgIFJhbmdlOiBgYnl0ZXM9JHtzdGFydH0tJHtlbmQgfHwgXCJcIn1gLFxuICAgICAgICB9KTtcbiAgICAgICAgcmVxID0gbWluaWdldChmb3JtYXQudXJsLCByZXF1ZXN0T3B0aW9ucyk7XG4gICAgICAgIHJlcS5vbihcImRhdGFcIiwgb25kYXRhKTtcbiAgICAgICAgcmVxLm9uKFwiZW5kXCIsICgpID0+IHtcbiAgICAgICAgICBpZiAoc3RyZWFtLmRlc3Ryb3llZCkgcmV0dXJuO1xuICAgICAgICAgIGlmIChlbmQgJiYgZW5kICE9PSByYW5nZUVuZCkge1xuICAgICAgICAgICAgc3RhcnQgPSBlbmQgKyAxO1xuICAgICAgICAgICAgZW5kICs9IGRsQ2h1bmtTaXplO1xuICAgICAgICAgICAgZ2V0TmV4dENodW5rKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcGlwZUFuZFNldEV2ZW50cyhyZXEsIHN0cmVhbSwgc2hvdWxkRW5kKTtcbiAgICAgIH07XG4gICAgICBnZXROZXh0Q2h1bmsoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQXVkaW8gb25seSBhbmQgdmlkZW8gb25seSBmb3JtYXRzIGRvbid0IHN1cHBvcnQgYmVnaW5cbiAgICAgIGlmIChvcHRpb25zLmJlZ2luKSB7XG4gICAgICAgIGZvcm1hdC51cmwgKz0gYCZiZWdpbj0ke3BhcnNlVGltZXN0YW1wKG9wdGlvbnMuYmVnaW4pfWA7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5yYW5nZT8uc3RhcnQgfHwgb3B0aW9ucy5yYW5nZT8uZW5kKSB7XG4gICAgICAgIHJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSBPYmplY3QuYXNzaWduKHt9LCByZXF1ZXN0T3B0aW9ucy5oZWFkZXJzLCB7XG4gICAgICAgICAgUmFuZ2U6IGBieXRlcz0ke29wdGlvbnMucmFuZ2Uuc3RhcnQgfHwgXCIwXCJ9LSR7b3B0aW9ucy5yYW5nZS5lbmQgfHwgXCJcIn1gLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJlcSA9IG1pbmlnZXQoZm9ybWF0LnVybCwgcmVxdWVzdE9wdGlvbnMpO1xuICAgICAgcmVxLm9uKFwicmVzcG9uc2VcIiwgcmVzID0+IHtcbiAgICAgICAgaWYgKHN0cmVhbS5kZXN0cm95ZWQpIHJldHVybjtcbiAgICAgICAgY29udGVudExlbmd0aCA9IGNvbnRlbnRMZW5ndGggfHwgcGFyc2VJbnQocmVzLmhlYWRlcnNbXCJjb250ZW50LWxlbmd0aFwiXSk7XG4gICAgICB9KTtcbiAgICAgIHJlcS5vbihcImRhdGFcIiwgb25kYXRhKTtcbiAgICAgIHBpcGVBbmRTZXRFdmVudHMocmVxLCBzdHJlYW0sIHNob3VsZEVuZCk7XG4gICAgfVxuICB9XG5cbiAgc3RyZWFtLl9kZXN0cm95ID0gKCkgPT4ge1xuICAgIHN0cmVhbS5kZXN0cm95ZWQgPSB0cnVlO1xuICAgIGlmIChyZXEpIHtcbiAgICAgIHJlcS5kZXN0cm95KCk7XG4gICAgICByZXEuZW5kKCk7XG4gICAgfVxuICB9O1xufTtcblxuLyoqXG4gKiBDYW4gYmUgdXNlZCB0byBkb3dubG9hZCB2aWRlbyBhZnRlciBpdHMgYGluZm9gIGlzIGdvdHRlbiB0aHJvdWdoXG4gKiBgeXRkbC5nZXRJbmZvKClgLiBJbiBjYXNlIHRoZSB1c2VyIG1pZ2h0IHdhbnQgdG8gbG9vayBhdCB0aGVcbiAqIGBpbmZvYCBvYmplY3QgYmVmb3JlIGRlY2lkaW5nIHRvIGRvd25sb2FkLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBpbmZvXG4gKiBAcGFyYW0geyFPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm5zIHtSZWFkYWJsZVN0cmVhbX1cbiAqL1xueXRkbC5kb3dubG9hZEZyb21JbmZvID0gKGluZm8sIG9wdGlvbnMpID0+IHtcbiAgY29uc3Qgc3RyZWFtID0gY3JlYXRlU3RyZWFtKG9wdGlvbnMpO1xuICBpZiAoIWluZm8uZnVsbCkge1xuICAgIHRocm93IEVycm9yKFwiQ2Fubm90IHVzZSBgeXRkbC5kb3dubG9hZEZyb21JbmZvKClgIHdoZW4gY2FsbGVkIHdpdGggaW5mbyBmcm9tIGB5dGRsLmdldEJhc2ljSW5mbygpYFwiKTtcbiAgfVxuICBzZXRJbW1lZGlhdGUoKCkgPT4ge1xuICAgIGRvd25sb2FkRnJvbUluZm9DYWxsYmFjayhzdHJlYW0sIGluZm8sIG9wdGlvbnMpO1xuICB9KTtcbiAgcmV0dXJuIHN0cmVhbTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@distube/ytdl-core/lib/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@distube/ytdl-core/lib/info-extras.js":
/*!************************************************************!*\
  !*** ./node_modules/@distube/ytdl-core/lib/info-extras.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("const utils = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/@distube/ytdl-core/lib/utils.js\");\nconst qs = __webpack_require__(/*! querystring */ \"querystring\");\nconst { parseTimestamp } = __webpack_require__(/*! m3u8stream */ \"(rsc)/./node_modules/m3u8stream/dist/index.js\");\n\nconst BASE_URL = \"https://www.youtube.com/watch?v=\";\nconst TITLE_TO_CATEGORY = {\n  song: { name: \"Music\", url: \"https://music.youtube.com/\" },\n};\n\nconst getText = obj => obj?.runs?.[0]?.text ?? obj?.simpleText;\n\n/**\n * Get video media.\n *\n * @param {Object} info\n * @returns {Object}\n */\nexports.getMedia = info => {\n  let media = {};\n  let results = [];\n  try {\n    results = info.response.contents.twoColumnWatchNextResults.results.results.contents;\n  } catch (err) {\n    // Do nothing\n  }\n\n  let result = results.find(v => v.videoSecondaryInfoRenderer);\n  if (!result) {\n    return {};\n  }\n\n  try {\n    let metadataRows = (result.metadataRowContainer || result.videoSecondaryInfoRenderer.metadataRowContainer)\n      .metadataRowContainerRenderer.rows;\n    for (let row of metadataRows) {\n      if (row.metadataRowRenderer) {\n        let title = getText(row.metadataRowRenderer.title).toLowerCase();\n        let contents = row.metadataRowRenderer.contents[0];\n        media[title] = getText(contents);\n        let runs = contents.runs;\n        if (runs?.[0]?.navigationEndpoint) {\n          media[`${title}_url`] = new URL(\n            runs[0].navigationEndpoint.commandMetadata.webCommandMetadata.url,\n            BASE_URL,\n          ).toString();\n        }\n        if (title in TITLE_TO_CATEGORY) {\n          media.category = TITLE_TO_CATEGORY[title].name;\n          media.category_url = TITLE_TO_CATEGORY[title].url;\n        }\n      } else if (row.richMetadataRowRenderer) {\n        let contents = row.richMetadataRowRenderer.contents;\n        let boxArt = contents.filter(\n          meta => meta.richMetadataRenderer.style === \"RICH_METADATA_RENDERER_STYLE_BOX_ART\",\n        );\n        for (let { richMetadataRenderer } of boxArt) {\n          let meta = richMetadataRenderer;\n          media.year = getText(meta.subtitle);\n          let type = getText(meta.callToAction).split(\" \")[1];\n          media[type] = getText(meta.title);\n          media[`${type}_url`] = new URL(meta.endpoint.commandMetadata.webCommandMetadata.url, BASE_URL).toString();\n          media.thumbnails = meta.thumbnail.thumbnails;\n        }\n        let topic = contents.filter(meta => meta.richMetadataRenderer.style === \"RICH_METADATA_RENDERER_STYLE_TOPIC\");\n        for (let { richMetadataRenderer } of topic) {\n          let meta = richMetadataRenderer;\n          media.category = getText(meta.title);\n          media.category_url = new URL(meta.endpoint.commandMetadata.webCommandMetadata.url, BASE_URL).toString();\n        }\n      }\n    }\n  } catch (err) {\n    // Do nothing.\n  }\n\n  return media;\n};\n\nconst isVerified = badges => !!badges?.find(b => b.metadataBadgeRenderer.tooltip === \"Verified\");\n\n/**\n * Get video author.\n *\n * @param {Object} info\n * @returns {Object}\n */\nexports.getAuthor = info => {\n  let channelId,\n    thumbnails = [],\n    subscriberCount,\n    verified = false;\n  try {\n    let results = info.response.contents.twoColumnWatchNextResults.results.results.contents;\n    let v = results.find(v2 => v2?.videoSecondaryInfoRenderer?.owner?.videoOwnerRenderer);\n    let videoOwnerRenderer = v.videoSecondaryInfoRenderer.owner.videoOwnerRenderer;\n    channelId = videoOwnerRenderer.navigationEndpoint.browseEndpoint.browseId;\n    thumbnails = videoOwnerRenderer.thumbnail.thumbnails.map(thumbnail => {\n      thumbnail.url = new URL(thumbnail.url, BASE_URL).toString();\n      return thumbnail;\n    });\n    subscriberCount = utils.parseAbbreviatedNumber(getText(videoOwnerRenderer.subscriberCountText));\n    verified = isVerified(videoOwnerRenderer.badges);\n  } catch (err) {\n    // Do nothing.\n  }\n  try {\n    let videoDetails = info.player_response.microformat?.playerMicroformatRenderer;\n    let id = videoDetails?.channelId || channelId || info.player_response.videoDetails.channelId;\n    let author = {\n      id: id,\n      name: videoDetails?.ownerChannelName ?? info.player_response.videoDetails.author,\n      user: videoDetails?.ownerProfileUrl.split(\"/\").slice(-1)[0] ?? null,\n      channel_url: `https://www.youtube.com/channel/${id}`,\n      external_channel_url: videoDetails ? `https://www.youtube.com/channel/${videoDetails.externalChannelId}` : \"\",\n      user_url: videoDetails ? new URL(videoDetails.ownerProfileUrl, BASE_URL).toString() : \"\",\n      thumbnails,\n      verified,\n      subscriber_count: subscriberCount,\n    };\n    if (thumbnails.length) {\n      utils.deprecate(author, \"avatar\", author.thumbnails[0].url, \"author.avatar\", \"author.thumbnails[0].url\");\n    }\n    return author;\n  } catch (err) {\n    return {};\n  }\n};\n\nconst parseRelatedVideo = (details, rvsParams) => {\n  if (!details) return;\n  try {\n    let viewCount = getText(details.viewCountText);\n    let shortViewCount = getText(details.shortViewCountText);\n    let rvsDetails = rvsParams.find(elem => elem.id === details.videoId);\n    if (!/^\\d/.test(shortViewCount)) {\n      shortViewCount = rvsDetails?.short_view_count_text || \"\";\n    }\n    viewCount = (/^\\d/.test(viewCount) ? viewCount : shortViewCount).split(\" \")[0];\n    let browseEndpoint = details.shortBylineText.runs[0].navigationEndpoint.browseEndpoint;\n    let channelId = browseEndpoint.browseId;\n    let name = getText(details.shortBylineText);\n    let user = (browseEndpoint.canonicalBaseUrl || \"\").split(\"/\").slice(-1)[0];\n    let video = {\n      id: details.videoId,\n      title: getText(details.title),\n      published: getText(details.publishedTimeText),\n      author: {\n        id: channelId,\n        name,\n        user,\n        channel_url: `https://www.youtube.com/channel/${channelId}`,\n        user_url: `https://www.youtube.com/user/${user}`,\n        thumbnails: details.channelThumbnail.thumbnails.map(thumbnail => {\n          thumbnail.url = new URL(thumbnail.url, BASE_URL).toString();\n          return thumbnail;\n        }),\n        verified: isVerified(details.ownerBadges),\n\n        [Symbol.toPrimitive]() {\n          console.warn(\n            `\\`relatedVideo.author\\` will be removed in a near future release, ` +\n              `use \\`relatedVideo.author.name\\` instead.`,\n          );\n          return video.author.name;\n        },\n      },\n      short_view_count_text: shortViewCount.split(\" \")[0],\n      view_count: viewCount.replace(/,/g, \"\"),\n      length_seconds: details.lengthText\n        ? Math.floor(parseTimestamp(getText(details.lengthText)) / 1000)\n        : rvsParams\n          ? `${rvsParams.length_seconds}`\n          : undefined,\n      thumbnails: details.thumbnail.thumbnails,\n      richThumbnails: details.richThumbnail\n        ? details.richThumbnail.movingThumbnailRenderer.movingThumbnailDetails.thumbnails\n        : [],\n      isLive: !!details.badges?.find(b => b.metadataBadgeRenderer.label === \"LIVE NOW\"),\n    };\n\n    utils.deprecate(\n      video,\n      \"author_thumbnail\",\n      video.author.thumbnails[0].url,\n      \"relatedVideo.author_thumbnail\",\n      \"relatedVideo.author.thumbnails[0].url\",\n    );\n    utils.deprecate(video, \"ucid\", video.author.id, \"relatedVideo.ucid\", \"relatedVideo.author.id\");\n    utils.deprecate(\n      video,\n      \"video_thumbnail\",\n      video.thumbnails[0].url,\n      \"relatedVideo.video_thumbnail\",\n      \"relatedVideo.thumbnails[0].url\",\n    );\n    return video;\n  } catch (err) {\n    // Skip.\n  }\n};\n\n/**\n * Get related videos.\n *\n * @param {Object} info\n * @returns {Array.<Object>}\n */\nexports.getRelatedVideos = info => {\n  let rvsParams = [],\n    secondaryResults = [];\n  try {\n    rvsParams = info.response.webWatchNextResponseExtensionData.relatedVideoArgs.split(\",\").map(e => qs.parse(e));\n  } catch (err) {\n    // Do nothing.\n  }\n  try {\n    secondaryResults = info.response.contents.twoColumnWatchNextResults.secondaryResults.secondaryResults.results;\n  } catch (err) {\n    return [];\n  }\n  let videos = [];\n  for (let result of secondaryResults || []) {\n    let details = result.compactVideoRenderer;\n    if (details) {\n      let video = parseRelatedVideo(details, rvsParams);\n      if (video) videos.push(video);\n    } else {\n      let autoplay = result.compactAutoplayRenderer || result.itemSectionRenderer;\n      if (!autoplay || !Array.isArray(autoplay.contents)) continue;\n      for (let content of autoplay.contents) {\n        let video = parseRelatedVideo(content.compactVideoRenderer, rvsParams);\n        if (video) videos.push(video);\n      }\n    }\n  }\n  return videos;\n};\n\n/**\n * Get like count.\n *\n * @param {Object} info\n * @returns {number}\n */\nexports.getLikes = info => {\n  try {\n    let contents = info.response.contents.twoColumnWatchNextResults.results.results.contents;\n    let video = contents.find(r => r.videoPrimaryInfoRenderer);\n    let buttons = video.videoPrimaryInfoRenderer.videoActions.menuRenderer.topLevelButtons;\n    let accessibilityText = buttons.find(b => b.segmentedLikeDislikeButtonViewModel).segmentedLikeDislikeButtonViewModel\n      .likeButtonViewModel.likeButtonViewModel.toggleButtonViewModel.toggleButtonViewModel.defaultButtonViewModel\n      .buttonViewModel.accessibilityText;\n    return parseInt(accessibilityText.match(/[\\d,.]+/)[0].replace(/\\D+/g, \"\"));\n  } catch (err) {\n    return null;\n  }\n};\n\n/**\n * Cleans up a few fields on `videoDetails`.\n *\n * @param {Object} videoDetails\n * @param {Object} info\n * @returns {Object}\n */\nexports.cleanVideoDetails = (videoDetails, info) => {\n  videoDetails.thumbnails = videoDetails.thumbnail.thumbnails;\n  delete videoDetails.thumbnail;\n  utils.deprecate(\n    videoDetails,\n    \"thumbnail\",\n    { thumbnails: videoDetails.thumbnails },\n    \"videoDetails.thumbnail.thumbnails\",\n    \"videoDetails.thumbnails\",\n  );\n  videoDetails.description = videoDetails.shortDescription || getText(videoDetails.description);\n  delete videoDetails.shortDescription;\n  utils.deprecate(\n    videoDetails,\n    \"shortDescription\",\n    videoDetails.description,\n    \"videoDetails.shortDescription\",\n    \"videoDetails.description\",\n  );\n\n  // Use more reliable `lengthSeconds` from `playerMicroformatRenderer`.\n  videoDetails.lengthSeconds =\n    info.player_response.microformat?.playerMicroformatRenderer?.lengthSeconds ||\n    info.player_response.videoDetails.lengthSeconds;\n  return videoDetails;\n};\n\n/**\n * Get storyboards info.\n *\n * @param {Object} info\n * @returns {Array.<Object>}\n */\nexports.getStoryboards = info => {\n  const parts = info.player_response?.storyboards?.playerStoryboardSpecRenderer?.spec?.split(\"|\");\n\n  if (!parts) return [];\n\n  const url = new URL(parts.shift());\n\n  return parts.map((part, i) => {\n    let [thumbnailWidth, thumbnailHeight, thumbnailCount, columns, rows, interval, nameReplacement, sigh] =\n      part.split(\"#\");\n\n    url.searchParams.set(\"sigh\", sigh);\n\n    thumbnailCount = parseInt(thumbnailCount, 10);\n    columns = parseInt(columns, 10);\n    rows = parseInt(rows, 10);\n\n    const storyboardCount = Math.ceil(thumbnailCount / (columns * rows));\n\n    return {\n      templateUrl: url.toString().replace(\"$L\", i).replace(\"$N\", nameReplacement),\n      thumbnailWidth: parseInt(thumbnailWidth, 10),\n      thumbnailHeight: parseInt(thumbnailHeight, 10),\n      thumbnailCount,\n      interval: parseInt(interval, 10),\n      columns,\n      rows,\n      storyboardCount,\n    };\n  });\n};\n\n/**\n * Get chapters info.\n *\n * @param {Object} info\n * @returns {Array.<Object>}\n */\nexports.getChapters = info => {\n  const playerOverlayRenderer = info.response?.playerOverlays?.playerOverlayRenderer;\n  const playerBar = playerOverlayRenderer?.decoratedPlayerBarRenderer?.decoratedPlayerBarRenderer?.playerBar;\n  const markersMap = playerBar?.multiMarkersPlayerBarRenderer?.markersMap;\n  const marker = Array.isArray(markersMap) && markersMap.find(m => Array.isArray(m.value?.chapters));\n  if (!marker) return [];\n  const chapters = marker.value.chapters;\n\n  return chapters.map(chapter => ({\n    title: getText(chapter.chapterRenderer.title),\n    start_time: chapter.chapterRenderer.timeRangeStartMillis / 1000,\n  }));\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGRpc3R1YmUveXRkbC1jb3JlL2xpYi9pbmZvLWV4dHJhcy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxjQUFjLG1CQUFPLENBQUMscUVBQVM7QUFDL0IsV0FBVyxtQkFBTyxDQUFDLGdDQUFhO0FBQ2hDLFFBQVEsaUJBQWlCLEVBQUUsbUJBQU8sQ0FBQyxpRUFBWTs7QUFFL0M7QUFDQTtBQUNBLFVBQVUsa0RBQWtEO0FBQzVEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixNQUFNO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsdUJBQXVCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLEtBQUs7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHVCQUF1QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELEdBQUc7QUFDekQsOEVBQThFLCtCQUErQjtBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELFVBQVU7QUFDbEUsa0RBQWtELEtBQUs7QUFDdkQ7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUseUJBQXlCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxxQ0FBcUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0Esc0JBQXNCO0FBQ3RCOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8veXQtZG93bmxvYWRlci8uL25vZGVfbW9kdWxlcy9AZGlzdHViZS95dGRsLWNvcmUvbGliL2luZm8tZXh0cmFzLmpzP2RiOGYiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgdXRpbHMgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbmNvbnN0IHFzID0gcmVxdWlyZShcInF1ZXJ5c3RyaW5nXCIpO1xuY29uc3QgeyBwYXJzZVRpbWVzdGFtcCB9ID0gcmVxdWlyZShcIm0zdThzdHJlYW1cIik7XG5cbmNvbnN0IEJBU0VfVVJMID0gXCJodHRwczovL3d3dy55b3V0dWJlLmNvbS93YXRjaD92PVwiO1xuY29uc3QgVElUTEVfVE9fQ0FURUdPUlkgPSB7XG4gIHNvbmc6IHsgbmFtZTogXCJNdXNpY1wiLCB1cmw6IFwiaHR0cHM6Ly9tdXNpYy55b3V0dWJlLmNvbS9cIiB9LFxufTtcblxuY29uc3QgZ2V0VGV4dCA9IG9iaiA9PiBvYmo/LnJ1bnM/LlswXT8udGV4dCA/PyBvYmo/LnNpbXBsZVRleHQ7XG5cbi8qKlxuICogR2V0IHZpZGVvIG1lZGlhLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBpbmZvXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICovXG5leHBvcnRzLmdldE1lZGlhID0gaW5mbyA9PiB7XG4gIGxldCBtZWRpYSA9IHt9O1xuICBsZXQgcmVzdWx0cyA9IFtdO1xuICB0cnkge1xuICAgIHJlc3VsdHMgPSBpbmZvLnJlc3BvbnNlLmNvbnRlbnRzLnR3b0NvbHVtbldhdGNoTmV4dFJlc3VsdHMucmVzdWx0cy5yZXN1bHRzLmNvbnRlbnRzO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyBEbyBub3RoaW5nXG4gIH1cblxuICBsZXQgcmVzdWx0ID0gcmVzdWx0cy5maW5kKHYgPT4gdi52aWRlb1NlY29uZGFyeUluZm9SZW5kZXJlcik7XG4gIGlmICghcmVzdWx0KSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG5cbiAgdHJ5IHtcbiAgICBsZXQgbWV0YWRhdGFSb3dzID0gKHJlc3VsdC5tZXRhZGF0YVJvd0NvbnRhaW5lciB8fCByZXN1bHQudmlkZW9TZWNvbmRhcnlJbmZvUmVuZGVyZXIubWV0YWRhdGFSb3dDb250YWluZXIpXG4gICAgICAubWV0YWRhdGFSb3dDb250YWluZXJSZW5kZXJlci5yb3dzO1xuICAgIGZvciAobGV0IHJvdyBvZiBtZXRhZGF0YVJvd3MpIHtcbiAgICAgIGlmIChyb3cubWV0YWRhdGFSb3dSZW5kZXJlcikge1xuICAgICAgICBsZXQgdGl0bGUgPSBnZXRUZXh0KHJvdy5tZXRhZGF0YVJvd1JlbmRlcmVyLnRpdGxlKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBsZXQgY29udGVudHMgPSByb3cubWV0YWRhdGFSb3dSZW5kZXJlci5jb250ZW50c1swXTtcbiAgICAgICAgbWVkaWFbdGl0bGVdID0gZ2V0VGV4dChjb250ZW50cyk7XG4gICAgICAgIGxldCBydW5zID0gY29udGVudHMucnVucztcbiAgICAgICAgaWYgKHJ1bnM/LlswXT8ubmF2aWdhdGlvbkVuZHBvaW50KSB7XG4gICAgICAgICAgbWVkaWFbYCR7dGl0bGV9X3VybGBdID0gbmV3IFVSTChcbiAgICAgICAgICAgIHJ1bnNbMF0ubmF2aWdhdGlvbkVuZHBvaW50LmNvbW1hbmRNZXRhZGF0YS53ZWJDb21tYW5kTWV0YWRhdGEudXJsLFxuICAgICAgICAgICAgQkFTRV9VUkwsXG4gICAgICAgICAgKS50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aXRsZSBpbiBUSVRMRV9UT19DQVRFR09SWSkge1xuICAgICAgICAgIG1lZGlhLmNhdGVnb3J5ID0gVElUTEVfVE9fQ0FURUdPUllbdGl0bGVdLm5hbWU7XG4gICAgICAgICAgbWVkaWEuY2F0ZWdvcnlfdXJsID0gVElUTEVfVE9fQ0FURUdPUllbdGl0bGVdLnVybDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChyb3cucmljaE1ldGFkYXRhUm93UmVuZGVyZXIpIHtcbiAgICAgICAgbGV0IGNvbnRlbnRzID0gcm93LnJpY2hNZXRhZGF0YVJvd1JlbmRlcmVyLmNvbnRlbnRzO1xuICAgICAgICBsZXQgYm94QXJ0ID0gY29udGVudHMuZmlsdGVyKFxuICAgICAgICAgIG1ldGEgPT4gbWV0YS5yaWNoTWV0YWRhdGFSZW5kZXJlci5zdHlsZSA9PT0gXCJSSUNIX01FVEFEQVRBX1JFTkRFUkVSX1NUWUxFX0JPWF9BUlRcIixcbiAgICAgICAgKTtcbiAgICAgICAgZm9yIChsZXQgeyByaWNoTWV0YWRhdGFSZW5kZXJlciB9IG9mIGJveEFydCkge1xuICAgICAgICAgIGxldCBtZXRhID0gcmljaE1ldGFkYXRhUmVuZGVyZXI7XG4gICAgICAgICAgbWVkaWEueWVhciA9IGdldFRleHQobWV0YS5zdWJ0aXRsZSk7XG4gICAgICAgICAgbGV0IHR5cGUgPSBnZXRUZXh0KG1ldGEuY2FsbFRvQWN0aW9uKS5zcGxpdChcIiBcIilbMV07XG4gICAgICAgICAgbWVkaWFbdHlwZV0gPSBnZXRUZXh0KG1ldGEudGl0bGUpO1xuICAgICAgICAgIG1lZGlhW2Ake3R5cGV9X3VybGBdID0gbmV3IFVSTChtZXRhLmVuZHBvaW50LmNvbW1hbmRNZXRhZGF0YS53ZWJDb21tYW5kTWV0YWRhdGEudXJsLCBCQVNFX1VSTCkudG9TdHJpbmcoKTtcbiAgICAgICAgICBtZWRpYS50aHVtYm5haWxzID0gbWV0YS50aHVtYm5haWwudGh1bWJuYWlscztcbiAgICAgICAgfVxuICAgICAgICBsZXQgdG9waWMgPSBjb250ZW50cy5maWx0ZXIobWV0YSA9PiBtZXRhLnJpY2hNZXRhZGF0YVJlbmRlcmVyLnN0eWxlID09PSBcIlJJQ0hfTUVUQURBVEFfUkVOREVSRVJfU1RZTEVfVE9QSUNcIik7XG4gICAgICAgIGZvciAobGV0IHsgcmljaE1ldGFkYXRhUmVuZGVyZXIgfSBvZiB0b3BpYykge1xuICAgICAgICAgIGxldCBtZXRhID0gcmljaE1ldGFkYXRhUmVuZGVyZXI7XG4gICAgICAgICAgbWVkaWEuY2F0ZWdvcnkgPSBnZXRUZXh0KG1ldGEudGl0bGUpO1xuICAgICAgICAgIG1lZGlhLmNhdGVnb3J5X3VybCA9IG5ldyBVUkwobWV0YS5lbmRwb2ludC5jb21tYW5kTWV0YWRhdGEud2ViQ29tbWFuZE1ldGFkYXRhLnVybCwgQkFTRV9VUkwpLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIERvIG5vdGhpbmcuXG4gIH1cblxuICByZXR1cm4gbWVkaWE7XG59O1xuXG5jb25zdCBpc1ZlcmlmaWVkID0gYmFkZ2VzID0+ICEhYmFkZ2VzPy5maW5kKGIgPT4gYi5tZXRhZGF0YUJhZGdlUmVuZGVyZXIudG9vbHRpcCA9PT0gXCJWZXJpZmllZFwiKTtcblxuLyoqXG4gKiBHZXQgdmlkZW8gYXV0aG9yLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBpbmZvXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICovXG5leHBvcnRzLmdldEF1dGhvciA9IGluZm8gPT4ge1xuICBsZXQgY2hhbm5lbElkLFxuICAgIHRodW1ibmFpbHMgPSBbXSxcbiAgICBzdWJzY3JpYmVyQ291bnQsXG4gICAgdmVyaWZpZWQgPSBmYWxzZTtcbiAgdHJ5IHtcbiAgICBsZXQgcmVzdWx0cyA9IGluZm8ucmVzcG9uc2UuY29udGVudHMudHdvQ29sdW1uV2F0Y2hOZXh0UmVzdWx0cy5yZXN1bHRzLnJlc3VsdHMuY29udGVudHM7XG4gICAgbGV0IHYgPSByZXN1bHRzLmZpbmQodjIgPT4gdjI/LnZpZGVvU2Vjb25kYXJ5SW5mb1JlbmRlcmVyPy5vd25lcj8udmlkZW9Pd25lclJlbmRlcmVyKTtcbiAgICBsZXQgdmlkZW9Pd25lclJlbmRlcmVyID0gdi52aWRlb1NlY29uZGFyeUluZm9SZW5kZXJlci5vd25lci52aWRlb093bmVyUmVuZGVyZXI7XG4gICAgY2hhbm5lbElkID0gdmlkZW9Pd25lclJlbmRlcmVyLm5hdmlnYXRpb25FbmRwb2ludC5icm93c2VFbmRwb2ludC5icm93c2VJZDtcbiAgICB0aHVtYm5haWxzID0gdmlkZW9Pd25lclJlbmRlcmVyLnRodW1ibmFpbC50aHVtYm5haWxzLm1hcCh0aHVtYm5haWwgPT4ge1xuICAgICAgdGh1bWJuYWlsLnVybCA9IG5ldyBVUkwodGh1bWJuYWlsLnVybCwgQkFTRV9VUkwpLnRvU3RyaW5nKCk7XG4gICAgICByZXR1cm4gdGh1bWJuYWlsO1xuICAgIH0pO1xuICAgIHN1YnNjcmliZXJDb3VudCA9IHV0aWxzLnBhcnNlQWJicmV2aWF0ZWROdW1iZXIoZ2V0VGV4dCh2aWRlb093bmVyUmVuZGVyZXIuc3Vic2NyaWJlckNvdW50VGV4dCkpO1xuICAgIHZlcmlmaWVkID0gaXNWZXJpZmllZCh2aWRlb093bmVyUmVuZGVyZXIuYmFkZ2VzKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLy8gRG8gbm90aGluZy5cbiAgfVxuICB0cnkge1xuICAgIGxldCB2aWRlb0RldGFpbHMgPSBpbmZvLnBsYXllcl9yZXNwb25zZS5taWNyb2Zvcm1hdD8ucGxheWVyTWljcm9mb3JtYXRSZW5kZXJlcjtcbiAgICBsZXQgaWQgPSB2aWRlb0RldGFpbHM/LmNoYW5uZWxJZCB8fCBjaGFubmVsSWQgfHwgaW5mby5wbGF5ZXJfcmVzcG9uc2UudmlkZW9EZXRhaWxzLmNoYW5uZWxJZDtcbiAgICBsZXQgYXV0aG9yID0ge1xuICAgICAgaWQ6IGlkLFxuICAgICAgbmFtZTogdmlkZW9EZXRhaWxzPy5vd25lckNoYW5uZWxOYW1lID8/IGluZm8ucGxheWVyX3Jlc3BvbnNlLnZpZGVvRGV0YWlscy5hdXRob3IsXG4gICAgICB1c2VyOiB2aWRlb0RldGFpbHM/Lm93bmVyUHJvZmlsZVVybC5zcGxpdChcIi9cIikuc2xpY2UoLTEpWzBdID8/IG51bGwsXG4gICAgICBjaGFubmVsX3VybDogYGh0dHBzOi8vd3d3LnlvdXR1YmUuY29tL2NoYW5uZWwvJHtpZH1gLFxuICAgICAgZXh0ZXJuYWxfY2hhbm5lbF91cmw6IHZpZGVvRGV0YWlscyA/IGBodHRwczovL3d3dy55b3V0dWJlLmNvbS9jaGFubmVsLyR7dmlkZW9EZXRhaWxzLmV4dGVybmFsQ2hhbm5lbElkfWAgOiBcIlwiLFxuICAgICAgdXNlcl91cmw6IHZpZGVvRGV0YWlscyA/IG5ldyBVUkwodmlkZW9EZXRhaWxzLm93bmVyUHJvZmlsZVVybCwgQkFTRV9VUkwpLnRvU3RyaW5nKCkgOiBcIlwiLFxuICAgICAgdGh1bWJuYWlscyxcbiAgICAgIHZlcmlmaWVkLFxuICAgICAgc3Vic2NyaWJlcl9jb3VudDogc3Vic2NyaWJlckNvdW50LFxuICAgIH07XG4gICAgaWYgKHRodW1ibmFpbHMubGVuZ3RoKSB7XG4gICAgICB1dGlscy5kZXByZWNhdGUoYXV0aG9yLCBcImF2YXRhclwiLCBhdXRob3IudGh1bWJuYWlsc1swXS51cmwsIFwiYXV0aG9yLmF2YXRhclwiLCBcImF1dGhvci50aHVtYm5haWxzWzBdLnVybFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGF1dGhvcjtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG59O1xuXG5jb25zdCBwYXJzZVJlbGF0ZWRWaWRlbyA9IChkZXRhaWxzLCBydnNQYXJhbXMpID0+IHtcbiAgaWYgKCFkZXRhaWxzKSByZXR1cm47XG4gIHRyeSB7XG4gICAgbGV0IHZpZXdDb3VudCA9IGdldFRleHQoZGV0YWlscy52aWV3Q291bnRUZXh0KTtcbiAgICBsZXQgc2hvcnRWaWV3Q291bnQgPSBnZXRUZXh0KGRldGFpbHMuc2hvcnRWaWV3Q291bnRUZXh0KTtcbiAgICBsZXQgcnZzRGV0YWlscyA9IHJ2c1BhcmFtcy5maW5kKGVsZW0gPT4gZWxlbS5pZCA9PT0gZGV0YWlscy52aWRlb0lkKTtcbiAgICBpZiAoIS9eXFxkLy50ZXN0KHNob3J0Vmlld0NvdW50KSkge1xuICAgICAgc2hvcnRWaWV3Q291bnQgPSBydnNEZXRhaWxzPy5zaG9ydF92aWV3X2NvdW50X3RleHQgfHwgXCJcIjtcbiAgICB9XG4gICAgdmlld0NvdW50ID0gKC9eXFxkLy50ZXN0KHZpZXdDb3VudCkgPyB2aWV3Q291bnQgOiBzaG9ydFZpZXdDb3VudCkuc3BsaXQoXCIgXCIpWzBdO1xuICAgIGxldCBicm93c2VFbmRwb2ludCA9IGRldGFpbHMuc2hvcnRCeWxpbmVUZXh0LnJ1bnNbMF0ubmF2aWdhdGlvbkVuZHBvaW50LmJyb3dzZUVuZHBvaW50O1xuICAgIGxldCBjaGFubmVsSWQgPSBicm93c2VFbmRwb2ludC5icm93c2VJZDtcbiAgICBsZXQgbmFtZSA9IGdldFRleHQoZGV0YWlscy5zaG9ydEJ5bGluZVRleHQpO1xuICAgIGxldCB1c2VyID0gKGJyb3dzZUVuZHBvaW50LmNhbm9uaWNhbEJhc2VVcmwgfHwgXCJcIikuc3BsaXQoXCIvXCIpLnNsaWNlKC0xKVswXTtcbiAgICBsZXQgdmlkZW8gPSB7XG4gICAgICBpZDogZGV0YWlscy52aWRlb0lkLFxuICAgICAgdGl0bGU6IGdldFRleHQoZGV0YWlscy50aXRsZSksXG4gICAgICBwdWJsaXNoZWQ6IGdldFRleHQoZGV0YWlscy5wdWJsaXNoZWRUaW1lVGV4dCksXG4gICAgICBhdXRob3I6IHtcbiAgICAgICAgaWQ6IGNoYW5uZWxJZCxcbiAgICAgICAgbmFtZSxcbiAgICAgICAgdXNlcixcbiAgICAgICAgY2hhbm5lbF91cmw6IGBodHRwczovL3d3dy55b3V0dWJlLmNvbS9jaGFubmVsLyR7Y2hhbm5lbElkfWAsXG4gICAgICAgIHVzZXJfdXJsOiBgaHR0cHM6Ly93d3cueW91dHViZS5jb20vdXNlci8ke3VzZXJ9YCxcbiAgICAgICAgdGh1bWJuYWlsczogZGV0YWlscy5jaGFubmVsVGh1bWJuYWlsLnRodW1ibmFpbHMubWFwKHRodW1ibmFpbCA9PiB7XG4gICAgICAgICAgdGh1bWJuYWlsLnVybCA9IG5ldyBVUkwodGh1bWJuYWlsLnVybCwgQkFTRV9VUkwpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgcmV0dXJuIHRodW1ibmFpbDtcbiAgICAgICAgfSksXG4gICAgICAgIHZlcmlmaWVkOiBpc1ZlcmlmaWVkKGRldGFpbHMub3duZXJCYWRnZXMpLFxuXG4gICAgICAgIFtTeW1ib2wudG9QcmltaXRpdmVdKCkge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgIGBcXGByZWxhdGVkVmlkZW8uYXV0aG9yXFxgIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIG5lYXIgZnV0dXJlIHJlbGVhc2UsIGAgK1xuICAgICAgICAgICAgICBgdXNlIFxcYHJlbGF0ZWRWaWRlby5hdXRob3IubmFtZVxcYCBpbnN0ZWFkLmAsXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm4gdmlkZW8uYXV0aG9yLm5hbWU7XG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgICAgc2hvcnRfdmlld19jb3VudF90ZXh0OiBzaG9ydFZpZXdDb3VudC5zcGxpdChcIiBcIilbMF0sXG4gICAgICB2aWV3X2NvdW50OiB2aWV3Q291bnQucmVwbGFjZSgvLC9nLCBcIlwiKSxcbiAgICAgIGxlbmd0aF9zZWNvbmRzOiBkZXRhaWxzLmxlbmd0aFRleHRcbiAgICAgICAgPyBNYXRoLmZsb29yKHBhcnNlVGltZXN0YW1wKGdldFRleHQoZGV0YWlscy5sZW5ndGhUZXh0KSkgLyAxMDAwKVxuICAgICAgICA6IHJ2c1BhcmFtc1xuICAgICAgICAgID8gYCR7cnZzUGFyYW1zLmxlbmd0aF9zZWNvbmRzfWBcbiAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgIHRodW1ibmFpbHM6IGRldGFpbHMudGh1bWJuYWlsLnRodW1ibmFpbHMsXG4gICAgICByaWNoVGh1bWJuYWlsczogZGV0YWlscy5yaWNoVGh1bWJuYWlsXG4gICAgICAgID8gZGV0YWlscy5yaWNoVGh1bWJuYWlsLm1vdmluZ1RodW1ibmFpbFJlbmRlcmVyLm1vdmluZ1RodW1ibmFpbERldGFpbHMudGh1bWJuYWlsc1xuICAgICAgICA6IFtdLFxuICAgICAgaXNMaXZlOiAhIWRldGFpbHMuYmFkZ2VzPy5maW5kKGIgPT4gYi5tZXRhZGF0YUJhZGdlUmVuZGVyZXIubGFiZWwgPT09IFwiTElWRSBOT1dcIiksXG4gICAgfTtcblxuICAgIHV0aWxzLmRlcHJlY2F0ZShcbiAgICAgIHZpZGVvLFxuICAgICAgXCJhdXRob3JfdGh1bWJuYWlsXCIsXG4gICAgICB2aWRlby5hdXRob3IudGh1bWJuYWlsc1swXS51cmwsXG4gICAgICBcInJlbGF0ZWRWaWRlby5hdXRob3JfdGh1bWJuYWlsXCIsXG4gICAgICBcInJlbGF0ZWRWaWRlby5hdXRob3IudGh1bWJuYWlsc1swXS51cmxcIixcbiAgICApO1xuICAgIHV0aWxzLmRlcHJlY2F0ZSh2aWRlbywgXCJ1Y2lkXCIsIHZpZGVvLmF1dGhvci5pZCwgXCJyZWxhdGVkVmlkZW8udWNpZFwiLCBcInJlbGF0ZWRWaWRlby5hdXRob3IuaWRcIik7XG4gICAgdXRpbHMuZGVwcmVjYXRlKFxuICAgICAgdmlkZW8sXG4gICAgICBcInZpZGVvX3RodW1ibmFpbFwiLFxuICAgICAgdmlkZW8udGh1bWJuYWlsc1swXS51cmwsXG4gICAgICBcInJlbGF0ZWRWaWRlby52aWRlb190aHVtYm5haWxcIixcbiAgICAgIFwicmVsYXRlZFZpZGVvLnRodW1ibmFpbHNbMF0udXJsXCIsXG4gICAgKTtcbiAgICByZXR1cm4gdmlkZW87XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIFNraXAuXG4gIH1cbn07XG5cbi8qKlxuICogR2V0IHJlbGF0ZWQgdmlkZW9zLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBpbmZvXG4gKiBAcmV0dXJucyB7QXJyYXkuPE9iamVjdD59XG4gKi9cbmV4cG9ydHMuZ2V0UmVsYXRlZFZpZGVvcyA9IGluZm8gPT4ge1xuICBsZXQgcnZzUGFyYW1zID0gW10sXG4gICAgc2Vjb25kYXJ5UmVzdWx0cyA9IFtdO1xuICB0cnkge1xuICAgIHJ2c1BhcmFtcyA9IGluZm8ucmVzcG9uc2Uud2ViV2F0Y2hOZXh0UmVzcG9uc2VFeHRlbnNpb25EYXRhLnJlbGF0ZWRWaWRlb0FyZ3Muc3BsaXQoXCIsXCIpLm1hcChlID0+IHFzLnBhcnNlKGUpKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLy8gRG8gbm90aGluZy5cbiAgfVxuICB0cnkge1xuICAgIHNlY29uZGFyeVJlc3VsdHMgPSBpbmZvLnJlc3BvbnNlLmNvbnRlbnRzLnR3b0NvbHVtbldhdGNoTmV4dFJlc3VsdHMuc2Vjb25kYXJ5UmVzdWx0cy5zZWNvbmRhcnlSZXN1bHRzLnJlc3VsdHM7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBsZXQgdmlkZW9zID0gW107XG4gIGZvciAobGV0IHJlc3VsdCBvZiBzZWNvbmRhcnlSZXN1bHRzIHx8IFtdKSB7XG4gICAgbGV0IGRldGFpbHMgPSByZXN1bHQuY29tcGFjdFZpZGVvUmVuZGVyZXI7XG4gICAgaWYgKGRldGFpbHMpIHtcbiAgICAgIGxldCB2aWRlbyA9IHBhcnNlUmVsYXRlZFZpZGVvKGRldGFpbHMsIHJ2c1BhcmFtcyk7XG4gICAgICBpZiAodmlkZW8pIHZpZGVvcy5wdXNoKHZpZGVvKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGF1dG9wbGF5ID0gcmVzdWx0LmNvbXBhY3RBdXRvcGxheVJlbmRlcmVyIHx8IHJlc3VsdC5pdGVtU2VjdGlvblJlbmRlcmVyO1xuICAgICAgaWYgKCFhdXRvcGxheSB8fCAhQXJyYXkuaXNBcnJheShhdXRvcGxheS5jb250ZW50cykpIGNvbnRpbnVlO1xuICAgICAgZm9yIChsZXQgY29udGVudCBvZiBhdXRvcGxheS5jb250ZW50cykge1xuICAgICAgICBsZXQgdmlkZW8gPSBwYXJzZVJlbGF0ZWRWaWRlbyhjb250ZW50LmNvbXBhY3RWaWRlb1JlbmRlcmVyLCBydnNQYXJhbXMpO1xuICAgICAgICBpZiAodmlkZW8pIHZpZGVvcy5wdXNoKHZpZGVvKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZpZGVvcztcbn07XG5cbi8qKlxuICogR2V0IGxpa2UgY291bnQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGluZm9cbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydHMuZ2V0TGlrZXMgPSBpbmZvID0+IHtcbiAgdHJ5IHtcbiAgICBsZXQgY29udGVudHMgPSBpbmZvLnJlc3BvbnNlLmNvbnRlbnRzLnR3b0NvbHVtbldhdGNoTmV4dFJlc3VsdHMucmVzdWx0cy5yZXN1bHRzLmNvbnRlbnRzO1xuICAgIGxldCB2aWRlbyA9IGNvbnRlbnRzLmZpbmQociA9PiByLnZpZGVvUHJpbWFyeUluZm9SZW5kZXJlcik7XG4gICAgbGV0IGJ1dHRvbnMgPSB2aWRlby52aWRlb1ByaW1hcnlJbmZvUmVuZGVyZXIudmlkZW9BY3Rpb25zLm1lbnVSZW5kZXJlci50b3BMZXZlbEJ1dHRvbnM7XG4gICAgbGV0IGFjY2Vzc2liaWxpdHlUZXh0ID0gYnV0dG9ucy5maW5kKGIgPT4gYi5zZWdtZW50ZWRMaWtlRGlzbGlrZUJ1dHRvblZpZXdNb2RlbCkuc2VnbWVudGVkTGlrZURpc2xpa2VCdXR0b25WaWV3TW9kZWxcbiAgICAgIC5saWtlQnV0dG9uVmlld01vZGVsLmxpa2VCdXR0b25WaWV3TW9kZWwudG9nZ2xlQnV0dG9uVmlld01vZGVsLnRvZ2dsZUJ1dHRvblZpZXdNb2RlbC5kZWZhdWx0QnV0dG9uVmlld01vZGVsXG4gICAgICAuYnV0dG9uVmlld01vZGVsLmFjY2Vzc2liaWxpdHlUZXh0O1xuICAgIHJldHVybiBwYXJzZUludChhY2Nlc3NpYmlsaXR5VGV4dC5tYXRjaCgvW1xcZCwuXSsvKVswXS5yZXBsYWNlKC9cXEQrL2csIFwiXCIpKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn07XG5cbi8qKlxuICogQ2xlYW5zIHVwIGEgZmV3IGZpZWxkcyBvbiBgdmlkZW9EZXRhaWxzYC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmlkZW9EZXRhaWxzXG4gKiBAcGFyYW0ge09iamVjdH0gaW5mb1xuICogQHJldHVybnMge09iamVjdH1cbiAqL1xuZXhwb3J0cy5jbGVhblZpZGVvRGV0YWlscyA9ICh2aWRlb0RldGFpbHMsIGluZm8pID0+IHtcbiAgdmlkZW9EZXRhaWxzLnRodW1ibmFpbHMgPSB2aWRlb0RldGFpbHMudGh1bWJuYWlsLnRodW1ibmFpbHM7XG4gIGRlbGV0ZSB2aWRlb0RldGFpbHMudGh1bWJuYWlsO1xuICB1dGlscy5kZXByZWNhdGUoXG4gICAgdmlkZW9EZXRhaWxzLFxuICAgIFwidGh1bWJuYWlsXCIsXG4gICAgeyB0aHVtYm5haWxzOiB2aWRlb0RldGFpbHMudGh1bWJuYWlscyB9LFxuICAgIFwidmlkZW9EZXRhaWxzLnRodW1ibmFpbC50aHVtYm5haWxzXCIsXG4gICAgXCJ2aWRlb0RldGFpbHMudGh1bWJuYWlsc1wiLFxuICApO1xuICB2aWRlb0RldGFpbHMuZGVzY3JpcHRpb24gPSB2aWRlb0RldGFpbHMuc2hvcnREZXNjcmlwdGlvbiB8fCBnZXRUZXh0KHZpZGVvRGV0YWlscy5kZXNjcmlwdGlvbik7XG4gIGRlbGV0ZSB2aWRlb0RldGFpbHMuc2hvcnREZXNjcmlwdGlvbjtcbiAgdXRpbHMuZGVwcmVjYXRlKFxuICAgIHZpZGVvRGV0YWlscyxcbiAgICBcInNob3J0RGVzY3JpcHRpb25cIixcbiAgICB2aWRlb0RldGFpbHMuZGVzY3JpcHRpb24sXG4gICAgXCJ2aWRlb0RldGFpbHMuc2hvcnREZXNjcmlwdGlvblwiLFxuICAgIFwidmlkZW9EZXRhaWxzLmRlc2NyaXB0aW9uXCIsXG4gICk7XG5cbiAgLy8gVXNlIG1vcmUgcmVsaWFibGUgYGxlbmd0aFNlY29uZHNgIGZyb20gYHBsYXllck1pY3JvZm9ybWF0UmVuZGVyZXJgLlxuICB2aWRlb0RldGFpbHMubGVuZ3RoU2Vjb25kcyA9XG4gICAgaW5mby5wbGF5ZXJfcmVzcG9uc2UubWljcm9mb3JtYXQ/LnBsYXllck1pY3JvZm9ybWF0UmVuZGVyZXI/Lmxlbmd0aFNlY29uZHMgfHxcbiAgICBpbmZvLnBsYXllcl9yZXNwb25zZS52aWRlb0RldGFpbHMubGVuZ3RoU2Vjb25kcztcbiAgcmV0dXJuIHZpZGVvRGV0YWlscztcbn07XG5cbi8qKlxuICogR2V0IHN0b3J5Ym9hcmRzIGluZm8uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGluZm9cbiAqIEByZXR1cm5zIHtBcnJheS48T2JqZWN0Pn1cbiAqL1xuZXhwb3J0cy5nZXRTdG9yeWJvYXJkcyA9IGluZm8gPT4ge1xuICBjb25zdCBwYXJ0cyA9IGluZm8ucGxheWVyX3Jlc3BvbnNlPy5zdG9yeWJvYXJkcz8ucGxheWVyU3Rvcnlib2FyZFNwZWNSZW5kZXJlcj8uc3BlYz8uc3BsaXQoXCJ8XCIpO1xuXG4gIGlmICghcGFydHMpIHJldHVybiBbXTtcblxuICBjb25zdCB1cmwgPSBuZXcgVVJMKHBhcnRzLnNoaWZ0KCkpO1xuXG4gIHJldHVybiBwYXJ0cy5tYXAoKHBhcnQsIGkpID0+IHtcbiAgICBsZXQgW3RodW1ibmFpbFdpZHRoLCB0aHVtYm5haWxIZWlnaHQsIHRodW1ibmFpbENvdW50LCBjb2x1bW5zLCByb3dzLCBpbnRlcnZhbCwgbmFtZVJlcGxhY2VtZW50LCBzaWdoXSA9XG4gICAgICBwYXJ0LnNwbGl0KFwiI1wiKTtcblxuICAgIHVybC5zZWFyY2hQYXJhbXMuc2V0KFwic2lnaFwiLCBzaWdoKTtcblxuICAgIHRodW1ibmFpbENvdW50ID0gcGFyc2VJbnQodGh1bWJuYWlsQ291bnQsIDEwKTtcbiAgICBjb2x1bW5zID0gcGFyc2VJbnQoY29sdW1ucywgMTApO1xuICAgIHJvd3MgPSBwYXJzZUludChyb3dzLCAxMCk7XG5cbiAgICBjb25zdCBzdG9yeWJvYXJkQ291bnQgPSBNYXRoLmNlaWwodGh1bWJuYWlsQ291bnQgLyAoY29sdW1ucyAqIHJvd3MpKTtcblxuICAgIHJldHVybiB7XG4gICAgICB0ZW1wbGF0ZVVybDogdXJsLnRvU3RyaW5nKCkucmVwbGFjZShcIiRMXCIsIGkpLnJlcGxhY2UoXCIkTlwiLCBuYW1lUmVwbGFjZW1lbnQpLFxuICAgICAgdGh1bWJuYWlsV2lkdGg6IHBhcnNlSW50KHRodW1ibmFpbFdpZHRoLCAxMCksXG4gICAgICB0aHVtYm5haWxIZWlnaHQ6IHBhcnNlSW50KHRodW1ibmFpbEhlaWdodCwgMTApLFxuICAgICAgdGh1bWJuYWlsQ291bnQsXG4gICAgICBpbnRlcnZhbDogcGFyc2VJbnQoaW50ZXJ2YWwsIDEwKSxcbiAgICAgIGNvbHVtbnMsXG4gICAgICByb3dzLFxuICAgICAgc3Rvcnlib2FyZENvdW50LFxuICAgIH07XG4gIH0pO1xufTtcblxuLyoqXG4gKiBHZXQgY2hhcHRlcnMgaW5mby5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gaW5mb1xuICogQHJldHVybnMge0FycmF5LjxPYmplY3Q+fVxuICovXG5leHBvcnRzLmdldENoYXB0ZXJzID0gaW5mbyA9PiB7XG4gIGNvbnN0IHBsYXllck92ZXJsYXlSZW5kZXJlciA9IGluZm8ucmVzcG9uc2U/LnBsYXllck92ZXJsYXlzPy5wbGF5ZXJPdmVybGF5UmVuZGVyZXI7XG4gIGNvbnN0IHBsYXllckJhciA9IHBsYXllck92ZXJsYXlSZW5kZXJlcj8uZGVjb3JhdGVkUGxheWVyQmFyUmVuZGVyZXI/LmRlY29yYXRlZFBsYXllckJhclJlbmRlcmVyPy5wbGF5ZXJCYXI7XG4gIGNvbnN0IG1hcmtlcnNNYXAgPSBwbGF5ZXJCYXI/Lm11bHRpTWFya2Vyc1BsYXllckJhclJlbmRlcmVyPy5tYXJrZXJzTWFwO1xuICBjb25zdCBtYXJrZXIgPSBBcnJheS5pc0FycmF5KG1hcmtlcnNNYXApICYmIG1hcmtlcnNNYXAuZmluZChtID0+IEFycmF5LmlzQXJyYXkobS52YWx1ZT8uY2hhcHRlcnMpKTtcbiAgaWYgKCFtYXJrZXIpIHJldHVybiBbXTtcbiAgY29uc3QgY2hhcHRlcnMgPSBtYXJrZXIudmFsdWUuY2hhcHRlcnM7XG5cbiAgcmV0dXJuIGNoYXB0ZXJzLm1hcChjaGFwdGVyID0+ICh7XG4gICAgdGl0bGU6IGdldFRleHQoY2hhcHRlci5jaGFwdGVyUmVuZGVyZXIudGl0bGUpLFxuICAgIHN0YXJ0X3RpbWU6IGNoYXB0ZXIuY2hhcHRlclJlbmRlcmVyLnRpbWVSYW5nZVN0YXJ0TWlsbGlzIC8gMTAwMCxcbiAgfSkpO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@distube/ytdl-core/lib/info-extras.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@distube/ytdl-core/lib/info.js":
/*!*****************************************************!*\
  !*** ./node_modules/@distube/ytdl-core/lib/info.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/* eslint-disable no-unused-vars */\nconst sax = __webpack_require__(/*! sax */ \"(rsc)/./node_modules/sax/lib/sax.js\");\n\nconst utils = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/@distube/ytdl-core/lib/utils.js\");\n// Forces Node JS version of setTimeout for Electron based applications\nconst { setTimeout } = __webpack_require__(/*! timers */ \"timers\");\nconst formatUtils = __webpack_require__(/*! ./format-utils */ \"(rsc)/./node_modules/@distube/ytdl-core/lib/format-utils.js\");\nconst urlUtils = __webpack_require__(/*! ./url-utils */ \"(rsc)/./node_modules/@distube/ytdl-core/lib/url-utils.js\");\nconst extras = __webpack_require__(/*! ./info-extras */ \"(rsc)/./node_modules/@distube/ytdl-core/lib/info-extras.js\");\nconst Cache = __webpack_require__(/*! ./cache */ \"(rsc)/./node_modules/@distube/ytdl-core/lib/cache.js\");\nconst sig = __webpack_require__(/*! ./sig */ \"(rsc)/./node_modules/@distube/ytdl-core/lib/sig.js\");\n\nconst BASE_URL = \"https://www.youtube.com/watch?v=\";\n\n// Cached for storing basic/full info.\nexports.cache = new Cache();\nexports.watchPageCache = new Cache();\n\n// List of URLs that show up in `notice_url` for age restricted videos.\nconst AGE_RESTRICTED_URLS = [\"support.google.com/youtube/?p=age_restrictions\", \"youtube.com/t/community_guidelines\"];\n\n/**\n * Gets info from a video without getting additional formats.\n *\n * @param {string} id\n * @param {Object} options\n * @returns {Promise<Object>}\n */\nexports.getBasicInfo = async (id, options) => {\n  utils.applyIPv6Rotations(options);\n  utils.applyDefaultHeaders(options);\n  utils.applyDefaultAgent(options);\n  utils.applyOldLocalAddress(options);\n  const retryOptions = Object.assign({}, options.requestOptions);\n  const { jar, dispatcher } = options.agent;\n  utils.setPropInsensitive(\n    options.requestOptions.headers,\n    \"cookie\",\n    jar.getCookieStringSync(\"https://www.youtube.com\"),\n  );\n  options.requestOptions.dispatcher = dispatcher;\n  const info = await retryFunc(getWatchHTMLPage, [id, options], retryOptions);\n\n  const playErr = utils.playError(info.player_response);\n  if (playErr) throw playErr;\n\n  Object.assign(info, {\n    // Replace with formats from iosPlayerResponse\n    // formats: parseFormats(info.player_response),\n    related_videos: extras.getRelatedVideos(info),\n  });\n\n  // Add additional properties to info.\n  const media = extras.getMedia(info);\n  const additional = {\n    author: extras.getAuthor(info),\n    media,\n    likes: extras.getLikes(info),\n    age_restricted: !!(\n      media && AGE_RESTRICTED_URLS.some(url => Object.values(media).some(v => typeof v === \"string\" && v.includes(url)))\n    ),\n\n    // Give the standard link to the video.\n    video_url: BASE_URL + id,\n    storyboards: extras.getStoryboards(info),\n    chapters: extras.getChapters(info),\n  };\n\n  info.videoDetails = extras.cleanVideoDetails(\n    Object.assign(\n      {},\n      info.player_response?.microformat?.playerMicroformatRenderer,\n      info.player_response?.videoDetails,\n      additional,\n    ),\n    info,\n  );\n\n  return info;\n};\n\nconst getWatchHTMLURL = (id, options) =>\n  `${BASE_URL + id}&hl=${options.lang || \"en\"}&bpctr=${Math.ceil(Date.now() / 1000)}&has_verified=1`;\nconst getWatchHTMLPageBody = (id, options) => {\n  const url = getWatchHTMLURL(id, options);\n  return exports.watchPageCache.getOrSet(url, () => utils.request(url, options));\n};\n\nconst EMBED_URL = \"https://www.youtube.com/embed/\";\nconst getEmbedPageBody = (id, options) => {\n  const embedUrl = `${EMBED_URL + id}?hl=${options.lang || \"en\"}`;\n  return utils.request(embedUrl, options);\n};\n\nconst getHTML5player = body => {\n  const html5playerRes =\n    /<script\\s+src=\"([^\"]+)\"(?:\\s+type=\"text\\/javascript\")?\\s+name=\"player_ias\\/base\"\\s*>|\"jsUrl\":\"([^\"]+)\"/.exec(body);\n  return html5playerRes?.[1] || html5playerRes?.[2];\n};\n\n/**\n * Given a function, calls it with `args` until it's successful,\n * or until it encounters an unrecoverable error.\n * Currently, any error from miniget is considered unrecoverable. Errors such as\n * too many redirects, invalid URL, status code 404, status code 502.\n *\n * @param {Function} func\n * @param {Array.<Object>} args\n * @param {Object} options\n * @param {number} options.maxRetries\n * @param {Object} options.backoff\n * @param {number} options.backoff.inc\n */\nconst retryFunc = async (func, args, options) => {\n  let currentTry = 0,\n    result;\n  if (!options.maxRetries) options.maxRetries = 3;\n  if (!options.backoff) options.backoff = { inc: 500, max: 5000 };\n  while (currentTry <= options.maxRetries) {\n    try {\n      result = await func(...args);\n      break;\n    } catch (err) {\n      if (err?.statusCode < 500 || currentTry >= options.maxRetries) throw err;\n      const wait = Math.min(++currentTry * options.backoff.inc, options.backoff.max);\n      await new Promise(resolve => setTimeout(resolve, wait));\n    }\n  }\n  return result;\n};\n\nconst jsonClosingChars = /^[)\\]}'\\s]+/;\nconst parseJSON = (source, varName, json) => {\n  if (!json || typeof json === \"object\") {\n    return json;\n  } else {\n    try {\n      json = json.replace(jsonClosingChars, \"\");\n      return JSON.parse(json);\n    } catch (err) {\n      throw Error(`Error parsing ${varName} in ${source}: ${err.message}`);\n    }\n  }\n};\n\nconst findJSON = (source, varName, body, left, right, prependJSON) => {\n  const jsonStr = utils.between(body, left, right);\n  if (!jsonStr) {\n    throw Error(`Could not find ${varName} in ${source}`);\n  }\n  return parseJSON(source, varName, utils.cutAfterJS(`${prependJSON}${jsonStr}`));\n};\n\nconst findPlayerResponse = (source, info) => {\n  if (!info) return {};\n  const player_response =\n    info.args?.player_response || info.player_response || info.playerResponse || info.embedded_player_response;\n  return parseJSON(source, \"player_response\", player_response);\n};\n\nconst getWatchHTMLPage = async (id, options) => {\n  const body = await getWatchHTMLPageBody(id, options);\n  const info = { page: \"watch\" };\n  try {\n    try {\n      info.player_response =\n        utils.tryParseBetween(body, \"var ytInitialPlayerResponse = \", \"}};\", \"\", \"}}\") ||\n        utils.tryParseBetween(body, \"var ytInitialPlayerResponse = \", \";var\") ||\n        utils.tryParseBetween(body, \"var ytInitialPlayerResponse = \", \";</script>\") ||\n        findJSON(\"watch.html\", \"player_response\", body, /\\bytInitialPlayerResponse\\s*=\\s*\\{/i, \"</script>\", \"{\");\n    } catch (_e) {\n      let args = findJSON(\"watch.html\", \"player_response\", body, /\\bytplayer\\.config\\s*=\\s*{/, \"</script>\", \"{\");\n      info.player_response = findPlayerResponse(\"watch.html\", args);\n    }\n\n    info.response =\n      utils.tryParseBetween(body, \"var ytInitialData = \", \"}};\", \"\", \"}}\") ||\n      utils.tryParseBetween(body, \"var ytInitialData = \", \";</script>\") ||\n      utils.tryParseBetween(body, 'window[\"ytInitialData\"] = ', \"}};\", \"\", \"}}\") ||\n      utils.tryParseBetween(body, 'window[\"ytInitialData\"] = ', \";</script>\") ||\n      findJSON(\"watch.html\", \"response\", body, /\\bytInitialData(\"\\])?\\s*=\\s*\\{/i, \"</script>\", \"{\");\n    info.html5player = getHTML5player(body);\n  } catch (_) {\n    throw Error(\n      \"Error when parsing watch.html, maybe YouTube made a change.\\n\" +\n        `Please report this issue with the \"${utils.saveDebugFile(\n          \"watch.html\",\n          body,\n        )}\" file on https://github.com/distubejs/ytdl-core/issues.`,\n    );\n  }\n  return info;\n};\n\n/**\n * @param {Object} player_response\n * @returns {Array.<Object>}\n */\nconst parseFormats = player_response => {\n  return (player_response?.streamingData?.formats || [])?.concat(player_response?.streamingData?.adaptiveFormats || []);\n};\n\nconst parseAdditionalManifests = (player_response, options) => {\n  const streamingData = player_response?.streamingData,\n    manifests = [];\n  if (streamingData) {\n    if (streamingData.dashManifestUrl) {\n      manifests.push(getDashManifest(streamingData.dashManifestUrl, options));\n    }\n    if (streamingData.hlsManifestUrl) {\n      manifests.push(getM3U8(streamingData.hlsManifestUrl, options));\n    }\n  }\n  return manifests;\n};\n\n// TODO: Clean up this function for readability and support more clients\n/**\n * Gets info from a video additional formats and deciphered URLs.\n *\n * @param {string} id\n * @param {Object} options\n * @returns {Promise<Object>}\n */\nexports.getInfo = async (id, options) => {\n  // Initialize request options\n  utils.applyIPv6Rotations(options);\n  utils.applyDefaultHeaders(options);\n  utils.applyDefaultAgent(options);\n  utils.applyOldLocalAddress(options);\n  utils.applyPlayerClients(options);\n\n  const info = await exports.getBasicInfo(id, options);\n\n  info.html5player =\n    info.html5player ||\n    getHTML5player(await getWatchHTMLPageBody(id, options)) ||\n    getHTML5player(await getEmbedPageBody(id, options));\n\n  if (!info.html5player) {\n    throw Error(\"Unable to find html5player file\");\n  }\n\n  info.html5player = new URL(info.html5player, BASE_URL).toString();\n\n  const formatPromises = [];\n\n  try {\n    const clientPromises = [];\n\n    if (options.playerClients.includes(\"WEB_EMBEDDED\")) clientPromises.push(fetchWebEmbeddedPlayer(id, info, options));\n    if (options.playerClients.includes(\"TV\")) clientPromises.push(fetchTvPlayer(id, info, options));\n    if (options.playerClients.includes(\"IOS\")) clientPromises.push(fetchIosJsonPlayer(id, options));\n    if (options.playerClients.includes(\"ANDROID\")) clientPromises.push(fetchAndroidJsonPlayer(id, options));\n\n    if (clientPromises.length > 0) {\n      const responses = await Promise.allSettled(clientPromises);\n      const successfulResponses = responses\n        .filter(r => r.status === \"fulfilled\")\n        .map(r => r.value)\n        .filter(r => r);\n\n      for (const response of successfulResponses) {\n        const formats = parseFormats(response);\n        if (formats && formats.length > 0) {\n          formatPromises.push(sig.decipherFormats(formats, info.html5player, options));\n        }\n\n        const manifestPromises = parseAdditionalManifests(response, options);\n        formatPromises.push(...manifestPromises);\n      }\n    }\n\n    if (options.playerClients.includes(\"WEB\")) {\n      bestPlayerResponse = info.player_response;\n\n      const formats = parseFormats(info.player_response);\n      if (formats && formats.length > 0) {\n        formatPromises.push(sig.decipherFormats(formats, info.html5player, options));\n      }\n\n      const manifestPromises = parseAdditionalManifests(info.player_response, options);\n      formatPromises.push(...manifestPromises);\n    }\n  } catch (error) {\n    console.error(\"Error fetching formats:\", error);\n\n    const formats = parseFormats(info.player_response);\n    if (formats && formats.length > 0) {\n      formatPromises.push(sig.decipherFormats(formats, info.html5player, options));\n    }\n\n    const manifestPromises = parseAdditionalManifests(info.player_response, options);\n    formatPromises.push(...manifestPromises);\n  }\n\n  if (formatPromises.length === 0) {\n    throw new Error(\"Failed to find any playable formats\");\n  }\n\n  const results = await Promise.all(formatPromises);\n  info.formats = Object.values(Object.assign({}, ...results));\n\n  info.formats = info.formats.filter(format => format && format.url && format.mimeType);\n\n  if (info.formats.length === 0) {\n    throw new Error(\"No playable formats found\");\n  }\n\n  info.formats = info.formats.map(format => {\n    const enhancedFormat = formatUtils.addFormatMeta(format);\n\n    if (!enhancedFormat.audioBitrate && enhancedFormat.hasAudio) {\n      enhancedFormat.audioBitrate = estimateAudioBitrate(enhancedFormat);\n    }\n\n    if (\n      !enhancedFormat.isHLS &&\n      enhancedFormat.mimeType &&\n      (enhancedFormat.mimeType.includes(\"hls\") ||\n        enhancedFormat.mimeType.includes(\"x-mpegURL\") ||\n        enhancedFormat.mimeType.includes(\"application/vnd.apple.mpegurl\"))\n    ) {\n      enhancedFormat.isHLS = true;\n    }\n\n    return enhancedFormat;\n  });\n\n  info.formats.sort(formatUtils.sortFormats);\n\n  const bestFormat =\n    info.formats.find(format => format.hasVideo && format.hasAudio) ||\n    info.formats.find(format => format.hasVideo) ||\n    info.formats.find(format => format.hasAudio) ||\n    info.formats[0];\n\n  info.bestFormat = bestFormat;\n  info.videoUrl = bestFormat.url;\n  info.selectedFormat = bestFormat;\n  info.full = true;\n\n  return info;\n};\n\nconst getPlaybackContext = async (html5player, options) => {\n  const body = await utils.request(html5player, options);\n  const mo = body.match(/(signatureTimestamp|sts):(\\d+)/);\n  return {\n    contentPlaybackContext: {\n      html5Preference: \"HTML5_PREF_WANTS\",\n      signatureTimestamp: mo?.[2],\n    },\n  };\n};\n\nconst getVisitorData = (info, _options) => {\n  for (const respKey of [\"player_response\", \"response\"]) {\n    try {\n      return info[respKey].responseContext.serviceTrackingParams\n          .find(x => x.service === \"GFEEDBACK\").params\n          .find(x => x.key === \"visitor_data\").value;\n    }\n    catch { /* not present */ }\n  }\n  return undefined;\n};\n\nconst LOCALE = { hl: \"en\", timeZone: \"UTC\", utcOffsetMinutes: 0 },\n  CHECK_FLAGS = { contentCheckOk: true, racyCheckOk: true };\n\nconst WEB_EMBEDDED_CONTEXT = {\n  client: {\n    clientName: \"WEB_EMBEDDED_PLAYER\",\n    clientVersion: \"1.20240723.01.00\",\n    ...LOCALE,\n  },\n};\n\nconst TVHTML5_CONTEXT = {\n  client: {\n    clientName: \"TVHTML5\",\n    clientVersion: \"7.20240724.13.00\",\n    ...LOCALE,\n  },\n};\n\nconst fetchWebEmbeddedPlayer = async (videoId, info, options) => {\n  const payload = {\n    context: WEB_EMBEDDED_CONTEXT,\n    videoId,\n    playbackContext: await getPlaybackContext(info.html5player, options),\n    ...CHECK_FLAGS,\n  };\n  return await playerAPI(videoId, payload, options);\n};\nconst fetchTvPlayer = async (videoId, info, options) => {\n  const payload = {\n    context: TVHTML5_CONTEXT,\n    videoId,\n    playbackContext: await getPlaybackContext(info.html5player, options),\n    ...CHECK_FLAGS,\n  };\n\n  options.visitorId = getVisitorData(info, options);\n\n  return await playerAPI(videoId, payload, options);\n};\n\nconst playerAPI = async (videoId, payload, options) => {\n  const { jar, dispatcher } = options.agent;\n  const opts = {\n    requestOptions: {\n      method: \"POST\",\n      dispatcher,\n      query: {\n        prettyPrint: false,\n        t: utils.generateClientPlaybackNonce(12),\n        id: videoId,\n      },\n      headers: {\n        \"Content-Type\": \"application/json\",\n        Cookie: jar.getCookieStringSync(\"https://www.youtube.com\"),\n        \"X-Goog-Api-Format-Version\": \"2\",\n      },\n      body: JSON.stringify(payload),\n    },\n  };\n  if (options.visitorId) opts.requestOptions.headers[\"X-Goog-Visitor-Id\"] = options.visitorId;\n  const response = await utils.request(\"https://youtubei.googleapis.com/youtubei/v1/player\", opts);\n  const playErr = utils.playError(response);\n  if (playErr) throw playErr;\n  if (!response.videoDetails || videoId !== response.videoDetails.videoId) {\n    const err = new Error(\"Malformed response from YouTube\");\n    err.response = response;\n    throw err;\n  }\n  return response;\n};\n\nconst IOS_CLIENT_VERSION = \"19.45.4\",\n  IOS_DEVICE_MODEL = \"iPhone16,2\",\n  IOS_USER_AGENT_VERSION = \"17_5_1\",\n  IOS_OS_VERSION = \"17.5.1.21F90\";\n\nconst fetchIosJsonPlayer = async (videoId, options) => {\n  const payload = {\n    videoId,\n    cpn: utils.generateClientPlaybackNonce(16),\n    contentCheckOk: true,\n    racyCheckOk: true,\n    context: {\n      client: {\n        clientName: \"IOS\",\n        clientVersion: IOS_CLIENT_VERSION,\n        deviceMake: \"Apple\",\n        deviceModel: IOS_DEVICE_MODEL,\n        platform: \"MOBILE\",\n        osName: \"iOS\",\n        osVersion: IOS_OS_VERSION,\n        hl: \"en\",\n        gl: \"US\",\n        utcOffsetMinutes: -240,\n      },\n      request: {\n        internalExperimentFlags: [],\n        useSsl: true,\n      },\n      user: {\n        lockedSafetyMode: false,\n      },\n    },\n  };\n\n  const { jar, dispatcher } = options.agent;\n  const opts = {\n    requestOptions: {\n      method: \"POST\",\n      dispatcher,\n      query: {\n        prettyPrint: false,\n        t: utils.generateClientPlaybackNonce(12),\n        id: videoId,\n      },\n      headers: {\n        \"Content-Type\": \"application/json\",\n        cookie: jar.getCookieStringSync(\"https://www.youtube.com\"),\n        \"User-Agent\": `com.google.ios.youtube/${IOS_CLIENT_VERSION}(${\n          IOS_DEVICE_MODEL\n        }; U; CPU iOS ${IOS_USER_AGENT_VERSION} like Mac OS X; en_US)`,\n        \"X-Goog-Api-Format-Version\": \"2\",\n      },\n      body: JSON.stringify(payload),\n    },\n  };\n  const response = await utils.request(\"https://youtubei.googleapis.com/youtubei/v1/player\", opts);\n  const playErr = utils.playError(response);\n  if (playErr) throw playErr;\n  if (!response.videoDetails || videoId !== response.videoDetails.videoId) {\n    const err = new Error(\"Malformed response from YouTube\");\n    err.response = response;\n    throw err;\n  }\n  return response;\n};\n\nconst ANDROID_CLIENT_VERSION = \"19.44.38\",\n  ANDROID_OS_VERSION = \"11\",\n  ANDROID_SDK_VERSION = \"30\";\n\nconst fetchAndroidJsonPlayer = async (videoId, options) => {\n  const payload = {\n    videoId,\n    cpn: utils.generateClientPlaybackNonce(16),\n    contentCheckOk: true,\n    racyCheckOk: true,\n    context: {\n      client: {\n        clientName: \"ANDROID\",\n        clientVersion: ANDROID_CLIENT_VERSION,\n        platform: \"MOBILE\",\n        osName: \"Android\",\n        osVersion: ANDROID_OS_VERSION,\n        androidSdkVersion: ANDROID_SDK_VERSION,\n        hl: \"en\",\n        gl: \"US\",\n        utcOffsetMinutes: -240,\n      },\n      request: {\n        internalExperimentFlags: [],\n        useSsl: true,\n      },\n      user: {\n        lockedSafetyMode: false,\n      },\n    },\n  };\n\n  const { jar, dispatcher } = options.agent;\n  const opts = {\n    requestOptions: {\n      method: \"POST\",\n      dispatcher,\n      query: {\n        prettyPrint: false,\n        t: utils.generateClientPlaybackNonce(12),\n        id: videoId,\n      },\n      headers: {\n        \"Content-Type\": \"application/json\",\n        cookie: jar.getCookieStringSync(\"https://www.youtube.com\"),\n        \"User-Agent\": `com.google.android.youtube/${\n          ANDROID_CLIENT_VERSION\n        } (Linux; U; Android ${ANDROID_OS_VERSION}) gzip`,\n        \"X-Goog-Api-Format-Version\": \"2\",\n      },\n      body: JSON.stringify(payload),\n    },\n  };\n  const response = await utils.request(\"https://youtubei.googleapis.com/youtubei/v1/player\", opts);\n  const playErr = utils.playError(response);\n  if (playErr) throw playErr;\n  if (!response.videoDetails || videoId !== response.videoDetails.videoId) {\n    const err = new Error(\"Malformed response from YouTube\");\n    err.response = response;\n    throw err;\n  }\n  return response;\n};\n\n/**\n * Gets additional DASH formats.\n *\n * @param {string} url\n * @param {Object} options\n * @returns {Promise<Array.<Object>>}\n */\nconst getDashManifest = (url, options) =>\n  new Promise((resolve, reject) => {\n    const formats = {};\n    const parser = sax.parser(false);\n    parser.onerror = reject;\n    let adaptationSet;\n    parser.onopentag = node => {\n      if (node.name === \"ADAPTATIONSET\") {\n        adaptationSet = node.attributes;\n      } else if (node.name === \"REPRESENTATION\") {\n        const itag = parseInt(node.attributes.ID);\n        if (!isNaN(itag)) {\n          formats[url] = Object.assign(\n            {\n              itag,\n              url,\n              bitrate: parseInt(node.attributes.BANDWIDTH),\n              mimeType: `${adaptationSet.MIMETYPE}; codecs=\"${node.attributes.CODECS}\"`,\n            },\n            node.attributes.HEIGHT\n              ? {\n                  width: parseInt(node.attributes.WIDTH),\n                  height: parseInt(node.attributes.HEIGHT),\n                  fps: parseInt(node.attributes.FRAMERATE),\n                }\n              : {\n                  audioSampleRate: node.attributes.AUDIOSAMPLINGRATE,\n                },\n          );\n        }\n      }\n    };\n    parser.onend = () => {\n      resolve(formats);\n    };\n    utils\n      .request(new URL(url, BASE_URL).toString(), options)\n      .then(res => {\n        parser.write(res);\n        parser.close();\n      })\n      .catch(reject);\n  });\n\n/**\n * Gets additional formats.\n *\n * @param {string} url\n * @param {Object} options\n * @returns {Promise<Array.<Object>>}\n */\nconst getM3U8 = async (url, options) => {\n  url = new URL(url, BASE_URL);\n  const body = await utils.request(url.toString(), options);\n  const formats = {};\n  body\n    .split(\"\\n\")\n    .filter(line => /^https?:\\/\\//.test(line))\n    .forEach(line => {\n      const itag = parseInt(line.match(/\\/itag\\/(\\d+)\\//)[1]);\n      formats[line] = { itag, url: line };\n    });\n  return formats;\n};\n\n// Cache get info functions.\n// In case a user wants to get a video's info before downloading.\nfor (const funcName of [\"getBasicInfo\", \"getInfo\"]) {\n  /**\n   * @param {string} link\n   * @param {Object} options\n   * @returns {Promise<Object>}\n   */\n  const func = exports[funcName];\n  exports[funcName] = async (link, options = {}) => {\n    utils.checkForUpdates();\n    const id = await urlUtils.getVideoID(link);\n    const key = [funcName, id, options.lang].join(\"-\");\n    return exports.cache.getOrSet(key, () => func(id, options));\n  };\n}\n\n// Export a few helpers.\nexports.validateID = urlUtils.validateID;\nexports.validateURL = urlUtils.validateURL;\nexports.getURLVideoID = urlUtils.getURLVideoID;\nexports.getVideoID = urlUtils.getVideoID;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGRpc3R1YmUveXRkbC1jb3JlL2xpYi9pbmZvLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsWUFBWSxtQkFBTyxDQUFDLGdEQUFLOztBQUV6QixjQUFjLG1CQUFPLENBQUMscUVBQVM7QUFDL0I7QUFDQSxRQUFRLGFBQWEsRUFBRSxtQkFBTyxDQUFDLHNCQUFRO0FBQ3ZDLG9CQUFvQixtQkFBTyxDQUFDLG1GQUFnQjtBQUM1QyxpQkFBaUIsbUJBQU8sQ0FBQyw2RUFBYTtBQUN0QyxlQUFlLG1CQUFPLENBQUMsaUZBQWU7QUFDdEMsY0FBYyxtQkFBTyxDQUFDLHFFQUFTO0FBQy9CLFlBQVksbUJBQU8sQ0FBQyxpRUFBTzs7QUFFM0I7O0FBRUE7QUFDQSxhQUFhO0FBQ2Isc0JBQXNCOztBQUV0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDLFVBQVUsa0JBQWtCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLLGNBQWMsTUFBTSxxQkFBcUIsU0FBUyw2QkFBNkI7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQixlQUFlLE1BQU0scUJBQXFCO0FBQ2hFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsV0FBVyxnQkFBZ0I7QUFDM0IsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sbUNBQW1DLFNBQVMsS0FBSyxPQUFPLElBQUksWUFBWTtBQUN4RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFNBQVMsS0FBSyxPQUFPO0FBQ3ZEO0FBQ0Esd0RBQXdELFlBQVksRUFBRSxRQUFRO0FBQzlFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxVQUFVO0FBQ3BGLHdFQUF3RTtBQUN4RSx3RUFBd0U7QUFDeEUsMkZBQTJGLG1CQUFtQjtBQUM5RyxNQUFNO0FBQ04sNEZBQTRGLGtCQUFrQjtBQUM5RztBQUNBOztBQUVBO0FBQ0EsOERBQThELFVBQVU7QUFDeEUsNERBQTREO0FBQzVELG9FQUFvRSxVQUFVO0FBQzlFLGtFQUFrRTtBQUNsRSw4RUFBOEUsbUJBQW1CO0FBQ2pHO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtDQUErQzs7QUFFL0M7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixnREFBZ0Q7QUFDakUsa0JBQWtCOztBQUVsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFVBQVUsa0JBQWtCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUEsVUFBVSxrQkFBa0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsbUJBQW1CO0FBQ25FO0FBQ0EsV0FBVyxHQUFHLFVBQVUsd0JBQXdCLGVBQWU7QUFDL0Q7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUEsVUFBVSxrQkFBa0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxRQUFRLEdBQUcsVUFBVSxtQkFBbUI7QUFDbEQ7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQix5QkFBeUIsVUFBVSx1QkFBdUI7QUFDckYsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QixLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsZUFBZTtBQUNmO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCLG1CQUFtQjtBQUNuQixxQkFBcUI7QUFDckIsa0JBQWtCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8veXQtZG93bmxvYWRlci8uL25vZGVfbW9kdWxlcy9AZGlzdHViZS95dGRsLWNvcmUvbGliL2luZm8uanM/MTY0YiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuY29uc3Qgc2F4ID0gcmVxdWlyZShcInNheFwiKTtcblxuY29uc3QgdXRpbHMgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbi8vIEZvcmNlcyBOb2RlIEpTIHZlcnNpb24gb2Ygc2V0VGltZW91dCBmb3IgRWxlY3Ryb24gYmFzZWQgYXBwbGljYXRpb25zXG5jb25zdCB7IHNldFRpbWVvdXQgfSA9IHJlcXVpcmUoXCJ0aW1lcnNcIik7XG5jb25zdCBmb3JtYXRVdGlscyA9IHJlcXVpcmUoXCIuL2Zvcm1hdC11dGlsc1wiKTtcbmNvbnN0IHVybFV0aWxzID0gcmVxdWlyZShcIi4vdXJsLXV0aWxzXCIpO1xuY29uc3QgZXh0cmFzID0gcmVxdWlyZShcIi4vaW5mby1leHRyYXNcIik7XG5jb25zdCBDYWNoZSA9IHJlcXVpcmUoXCIuL2NhY2hlXCIpO1xuY29uc3Qgc2lnID0gcmVxdWlyZShcIi4vc2lnXCIpO1xuXG5jb25zdCBCQVNFX1VSTCA9IFwiaHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1cIjtcblxuLy8gQ2FjaGVkIGZvciBzdG9yaW5nIGJhc2ljL2Z1bGwgaW5mby5cbmV4cG9ydHMuY2FjaGUgPSBuZXcgQ2FjaGUoKTtcbmV4cG9ydHMud2F0Y2hQYWdlQ2FjaGUgPSBuZXcgQ2FjaGUoKTtcblxuLy8gTGlzdCBvZiBVUkxzIHRoYXQgc2hvdyB1cCBpbiBgbm90aWNlX3VybGAgZm9yIGFnZSByZXN0cmljdGVkIHZpZGVvcy5cbmNvbnN0IEFHRV9SRVNUUklDVEVEX1VSTFMgPSBbXCJzdXBwb3J0Lmdvb2dsZS5jb20veW91dHViZS8/cD1hZ2VfcmVzdHJpY3Rpb25zXCIsIFwieW91dHViZS5jb20vdC9jb21tdW5pdHlfZ3VpZGVsaW5lc1wiXTtcblxuLyoqXG4gKiBHZXRzIGluZm8gZnJvbSBhIHZpZGVvIHdpdGhvdXQgZ2V0dGluZyBhZGRpdGlvbmFsIGZvcm1hdHMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGlkXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn1cbiAqL1xuZXhwb3J0cy5nZXRCYXNpY0luZm8gPSBhc3luYyAoaWQsIG9wdGlvbnMpID0+IHtcbiAgdXRpbHMuYXBwbHlJUHY2Um90YXRpb25zKG9wdGlvbnMpO1xuICB1dGlscy5hcHBseURlZmF1bHRIZWFkZXJzKG9wdGlvbnMpO1xuICB1dGlscy5hcHBseURlZmF1bHRBZ2VudChvcHRpb25zKTtcbiAgdXRpbHMuYXBwbHlPbGRMb2NhbEFkZHJlc3Mob3B0aW9ucyk7XG4gIGNvbnN0IHJldHJ5T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMucmVxdWVzdE9wdGlvbnMpO1xuICBjb25zdCB7IGphciwgZGlzcGF0Y2hlciB9ID0gb3B0aW9ucy5hZ2VudDtcbiAgdXRpbHMuc2V0UHJvcEluc2Vuc2l0aXZlKFxuICAgIG9wdGlvbnMucmVxdWVzdE9wdGlvbnMuaGVhZGVycyxcbiAgICBcImNvb2tpZVwiLFxuICAgIGphci5nZXRDb29raWVTdHJpbmdTeW5jKFwiaHR0cHM6Ly93d3cueW91dHViZS5jb21cIiksXG4gICk7XG4gIG9wdGlvbnMucmVxdWVzdE9wdGlvbnMuZGlzcGF0Y2hlciA9IGRpc3BhdGNoZXI7XG4gIGNvbnN0IGluZm8gPSBhd2FpdCByZXRyeUZ1bmMoZ2V0V2F0Y2hIVE1MUGFnZSwgW2lkLCBvcHRpb25zXSwgcmV0cnlPcHRpb25zKTtcblxuICBjb25zdCBwbGF5RXJyID0gdXRpbHMucGxheUVycm9yKGluZm8ucGxheWVyX3Jlc3BvbnNlKTtcbiAgaWYgKHBsYXlFcnIpIHRocm93IHBsYXlFcnI7XG5cbiAgT2JqZWN0LmFzc2lnbihpbmZvLCB7XG4gICAgLy8gUmVwbGFjZSB3aXRoIGZvcm1hdHMgZnJvbSBpb3NQbGF5ZXJSZXNwb25zZVxuICAgIC8vIGZvcm1hdHM6IHBhcnNlRm9ybWF0cyhpbmZvLnBsYXllcl9yZXNwb25zZSksXG4gICAgcmVsYXRlZF92aWRlb3M6IGV4dHJhcy5nZXRSZWxhdGVkVmlkZW9zKGluZm8pLFxuICB9KTtcblxuICAvLyBBZGQgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIHRvIGluZm8uXG4gIGNvbnN0IG1lZGlhID0gZXh0cmFzLmdldE1lZGlhKGluZm8pO1xuICBjb25zdCBhZGRpdGlvbmFsID0ge1xuICAgIGF1dGhvcjogZXh0cmFzLmdldEF1dGhvcihpbmZvKSxcbiAgICBtZWRpYSxcbiAgICBsaWtlczogZXh0cmFzLmdldExpa2VzKGluZm8pLFxuICAgIGFnZV9yZXN0cmljdGVkOiAhIShcbiAgICAgIG1lZGlhICYmIEFHRV9SRVNUUklDVEVEX1VSTFMuc29tZSh1cmwgPT4gT2JqZWN0LnZhbHVlcyhtZWRpYSkuc29tZSh2ID0+IHR5cGVvZiB2ID09PSBcInN0cmluZ1wiICYmIHYuaW5jbHVkZXModXJsKSkpXG4gICAgKSxcblxuICAgIC8vIEdpdmUgdGhlIHN0YW5kYXJkIGxpbmsgdG8gdGhlIHZpZGVvLlxuICAgIHZpZGVvX3VybDogQkFTRV9VUkwgKyBpZCxcbiAgICBzdG9yeWJvYXJkczogZXh0cmFzLmdldFN0b3J5Ym9hcmRzKGluZm8pLFxuICAgIGNoYXB0ZXJzOiBleHRyYXMuZ2V0Q2hhcHRlcnMoaW5mbyksXG4gIH07XG5cbiAgaW5mby52aWRlb0RldGFpbHMgPSBleHRyYXMuY2xlYW5WaWRlb0RldGFpbHMoXG4gICAgT2JqZWN0LmFzc2lnbihcbiAgICAgIHt9LFxuICAgICAgaW5mby5wbGF5ZXJfcmVzcG9uc2U/Lm1pY3JvZm9ybWF0Py5wbGF5ZXJNaWNyb2Zvcm1hdFJlbmRlcmVyLFxuICAgICAgaW5mby5wbGF5ZXJfcmVzcG9uc2U/LnZpZGVvRGV0YWlscyxcbiAgICAgIGFkZGl0aW9uYWwsXG4gICAgKSxcbiAgICBpbmZvLFxuICApO1xuXG4gIHJldHVybiBpbmZvO1xufTtcblxuY29uc3QgZ2V0V2F0Y2hIVE1MVVJMID0gKGlkLCBvcHRpb25zKSA9PlxuICBgJHtCQVNFX1VSTCArIGlkfSZobD0ke29wdGlvbnMubGFuZyB8fCBcImVuXCJ9JmJwY3RyPSR7TWF0aC5jZWlsKERhdGUubm93KCkgLyAxMDAwKX0maGFzX3ZlcmlmaWVkPTFgO1xuY29uc3QgZ2V0V2F0Y2hIVE1MUGFnZUJvZHkgPSAoaWQsIG9wdGlvbnMpID0+IHtcbiAgY29uc3QgdXJsID0gZ2V0V2F0Y2hIVE1MVVJMKGlkLCBvcHRpb25zKTtcbiAgcmV0dXJuIGV4cG9ydHMud2F0Y2hQYWdlQ2FjaGUuZ2V0T3JTZXQodXJsLCAoKSA9PiB1dGlscy5yZXF1ZXN0KHVybCwgb3B0aW9ucykpO1xufTtcblxuY29uc3QgRU1CRURfVVJMID0gXCJodHRwczovL3d3dy55b3V0dWJlLmNvbS9lbWJlZC9cIjtcbmNvbnN0IGdldEVtYmVkUGFnZUJvZHkgPSAoaWQsIG9wdGlvbnMpID0+IHtcbiAgY29uc3QgZW1iZWRVcmwgPSBgJHtFTUJFRF9VUkwgKyBpZH0/aGw9JHtvcHRpb25zLmxhbmcgfHwgXCJlblwifWA7XG4gIHJldHVybiB1dGlscy5yZXF1ZXN0KGVtYmVkVXJsLCBvcHRpb25zKTtcbn07XG5cbmNvbnN0IGdldEhUTUw1cGxheWVyID0gYm9keSA9PiB7XG4gIGNvbnN0IGh0bWw1cGxheWVyUmVzID1cbiAgICAvPHNjcmlwdFxccytzcmM9XCIoW15cIl0rKVwiKD86XFxzK3R5cGU9XCJ0ZXh0XFwvamF2YXNjcmlwdFwiKT9cXHMrbmFtZT1cInBsYXllcl9pYXNcXC9iYXNlXCJcXHMqPnxcImpzVXJsXCI6XCIoW15cIl0rKVwiLy5leGVjKGJvZHkpO1xuICByZXR1cm4gaHRtbDVwbGF5ZXJSZXM/LlsxXSB8fCBodG1sNXBsYXllclJlcz8uWzJdO1xufTtcblxuLyoqXG4gKiBHaXZlbiBhIGZ1bmN0aW9uLCBjYWxscyBpdCB3aXRoIGBhcmdzYCB1bnRpbCBpdCdzIHN1Y2Nlc3NmdWwsXG4gKiBvciB1bnRpbCBpdCBlbmNvdW50ZXJzIGFuIHVucmVjb3ZlcmFibGUgZXJyb3IuXG4gKiBDdXJyZW50bHksIGFueSBlcnJvciBmcm9tIG1pbmlnZXQgaXMgY29uc2lkZXJlZCB1bnJlY292ZXJhYmxlLiBFcnJvcnMgc3VjaCBhc1xuICogdG9vIG1hbnkgcmVkaXJlY3RzLCBpbnZhbGlkIFVSTCwgc3RhdHVzIGNvZGUgNDA0LCBzdGF0dXMgY29kZSA1MDIuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuY1xuICogQHBhcmFtIHtBcnJheS48T2JqZWN0Pn0gYXJnc1xuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLm1heFJldHJpZXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLmJhY2tvZmZcbiAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLmJhY2tvZmYuaW5jXG4gKi9cbmNvbnN0IHJldHJ5RnVuYyA9IGFzeW5jIChmdW5jLCBhcmdzLCBvcHRpb25zKSA9PiB7XG4gIGxldCBjdXJyZW50VHJ5ID0gMCxcbiAgICByZXN1bHQ7XG4gIGlmICghb3B0aW9ucy5tYXhSZXRyaWVzKSBvcHRpb25zLm1heFJldHJpZXMgPSAzO1xuICBpZiAoIW9wdGlvbnMuYmFja29mZikgb3B0aW9ucy5iYWNrb2ZmID0geyBpbmM6IDUwMCwgbWF4OiA1MDAwIH07XG4gIHdoaWxlIChjdXJyZW50VHJ5IDw9IG9wdGlvbnMubWF4UmV0cmllcykge1xuICAgIHRyeSB7XG4gICAgICByZXN1bHQgPSBhd2FpdCBmdW5jKC4uLmFyZ3MpO1xuICAgICAgYnJlYWs7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAoZXJyPy5zdGF0dXNDb2RlIDwgNTAwIHx8IGN1cnJlbnRUcnkgPj0gb3B0aW9ucy5tYXhSZXRyaWVzKSB0aHJvdyBlcnI7XG4gICAgICBjb25zdCB3YWl0ID0gTWF0aC5taW4oKytjdXJyZW50VHJ5ICogb3B0aW9ucy5iYWNrb2ZmLmluYywgb3B0aW9ucy5iYWNrb2ZmLm1heCk7XG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgd2FpdCkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuY29uc3QganNvbkNsb3NpbmdDaGFycyA9IC9eWylcXF19J1xcc10rLztcbmNvbnN0IHBhcnNlSlNPTiA9IChzb3VyY2UsIHZhck5hbWUsIGpzb24pID0+IHtcbiAgaWYgKCFqc29uIHx8IHR5cGVvZiBqc29uID09PSBcIm9iamVjdFwiKSB7XG4gICAgcmV0dXJuIGpzb247XG4gIH0gZWxzZSB7XG4gICAgdHJ5IHtcbiAgICAgIGpzb24gPSBqc29uLnJlcGxhY2UoanNvbkNsb3NpbmdDaGFycywgXCJcIik7XG4gICAgICByZXR1cm4gSlNPTi5wYXJzZShqc29uKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRocm93IEVycm9yKGBFcnJvciBwYXJzaW5nICR7dmFyTmFtZX0gaW4gJHtzb3VyY2V9OiAke2Vyci5tZXNzYWdlfWApO1xuICAgIH1cbiAgfVxufTtcblxuY29uc3QgZmluZEpTT04gPSAoc291cmNlLCB2YXJOYW1lLCBib2R5LCBsZWZ0LCByaWdodCwgcHJlcGVuZEpTT04pID0+IHtcbiAgY29uc3QganNvblN0ciA9IHV0aWxzLmJldHdlZW4oYm9keSwgbGVmdCwgcmlnaHQpO1xuICBpZiAoIWpzb25TdHIpIHtcbiAgICB0aHJvdyBFcnJvcihgQ291bGQgbm90IGZpbmQgJHt2YXJOYW1lfSBpbiAke3NvdXJjZX1gKTtcbiAgfVxuICByZXR1cm4gcGFyc2VKU09OKHNvdXJjZSwgdmFyTmFtZSwgdXRpbHMuY3V0QWZ0ZXJKUyhgJHtwcmVwZW5kSlNPTn0ke2pzb25TdHJ9YCkpO1xufTtcblxuY29uc3QgZmluZFBsYXllclJlc3BvbnNlID0gKHNvdXJjZSwgaW5mbykgPT4ge1xuICBpZiAoIWluZm8pIHJldHVybiB7fTtcbiAgY29uc3QgcGxheWVyX3Jlc3BvbnNlID1cbiAgICBpbmZvLmFyZ3M/LnBsYXllcl9yZXNwb25zZSB8fCBpbmZvLnBsYXllcl9yZXNwb25zZSB8fCBpbmZvLnBsYXllclJlc3BvbnNlIHx8IGluZm8uZW1iZWRkZWRfcGxheWVyX3Jlc3BvbnNlO1xuICByZXR1cm4gcGFyc2VKU09OKHNvdXJjZSwgXCJwbGF5ZXJfcmVzcG9uc2VcIiwgcGxheWVyX3Jlc3BvbnNlKTtcbn07XG5cbmNvbnN0IGdldFdhdGNoSFRNTFBhZ2UgPSBhc3luYyAoaWQsIG9wdGlvbnMpID0+IHtcbiAgY29uc3QgYm9keSA9IGF3YWl0IGdldFdhdGNoSFRNTFBhZ2VCb2R5KGlkLCBvcHRpb25zKTtcbiAgY29uc3QgaW5mbyA9IHsgcGFnZTogXCJ3YXRjaFwiIH07XG4gIHRyeSB7XG4gICAgdHJ5IHtcbiAgICAgIGluZm8ucGxheWVyX3Jlc3BvbnNlID1cbiAgICAgICAgdXRpbHMudHJ5UGFyc2VCZXR3ZWVuKGJvZHksIFwidmFyIHl0SW5pdGlhbFBsYXllclJlc3BvbnNlID0gXCIsIFwifX07XCIsIFwiXCIsIFwifX1cIikgfHxcbiAgICAgICAgdXRpbHMudHJ5UGFyc2VCZXR3ZWVuKGJvZHksIFwidmFyIHl0SW5pdGlhbFBsYXllclJlc3BvbnNlID0gXCIsIFwiO3ZhclwiKSB8fFxuICAgICAgICB1dGlscy50cnlQYXJzZUJldHdlZW4oYm9keSwgXCJ2YXIgeXRJbml0aWFsUGxheWVyUmVzcG9uc2UgPSBcIiwgXCI7PC9zY3JpcHQ+XCIpIHx8XG4gICAgICAgIGZpbmRKU09OKFwid2F0Y2guaHRtbFwiLCBcInBsYXllcl9yZXNwb25zZVwiLCBib2R5LCAvXFxieXRJbml0aWFsUGxheWVyUmVzcG9uc2VcXHMqPVxccypcXHsvaSwgXCI8L3NjcmlwdD5cIiwgXCJ7XCIpO1xuICAgIH0gY2F0Y2ggKF9lKSB7XG4gICAgICBsZXQgYXJncyA9IGZpbmRKU09OKFwid2F0Y2guaHRtbFwiLCBcInBsYXllcl9yZXNwb25zZVwiLCBib2R5LCAvXFxieXRwbGF5ZXJcXC5jb25maWdcXHMqPVxccyp7LywgXCI8L3NjcmlwdD5cIiwgXCJ7XCIpO1xuICAgICAgaW5mby5wbGF5ZXJfcmVzcG9uc2UgPSBmaW5kUGxheWVyUmVzcG9uc2UoXCJ3YXRjaC5odG1sXCIsIGFyZ3MpO1xuICAgIH1cblxuICAgIGluZm8ucmVzcG9uc2UgPVxuICAgICAgdXRpbHMudHJ5UGFyc2VCZXR3ZWVuKGJvZHksIFwidmFyIHl0SW5pdGlhbERhdGEgPSBcIiwgXCJ9fTtcIiwgXCJcIiwgXCJ9fVwiKSB8fFxuICAgICAgdXRpbHMudHJ5UGFyc2VCZXR3ZWVuKGJvZHksIFwidmFyIHl0SW5pdGlhbERhdGEgPSBcIiwgXCI7PC9zY3JpcHQ+XCIpIHx8XG4gICAgICB1dGlscy50cnlQYXJzZUJldHdlZW4oYm9keSwgJ3dpbmRvd1tcInl0SW5pdGlhbERhdGFcIl0gPSAnLCBcIn19O1wiLCBcIlwiLCBcIn19XCIpIHx8XG4gICAgICB1dGlscy50cnlQYXJzZUJldHdlZW4oYm9keSwgJ3dpbmRvd1tcInl0SW5pdGlhbERhdGFcIl0gPSAnLCBcIjs8L3NjcmlwdD5cIikgfHxcbiAgICAgIGZpbmRKU09OKFwid2F0Y2guaHRtbFwiLCBcInJlc3BvbnNlXCIsIGJvZHksIC9cXGJ5dEluaXRpYWxEYXRhKFwiXFxdKT9cXHMqPVxccypcXHsvaSwgXCI8L3NjcmlwdD5cIiwgXCJ7XCIpO1xuICAgIGluZm8uaHRtbDVwbGF5ZXIgPSBnZXRIVE1MNXBsYXllcihib2R5KTtcbiAgfSBjYXRjaCAoXykge1xuICAgIHRocm93IEVycm9yKFxuICAgICAgXCJFcnJvciB3aGVuIHBhcnNpbmcgd2F0Y2guaHRtbCwgbWF5YmUgWW91VHViZSBtYWRlIGEgY2hhbmdlLlxcblwiICtcbiAgICAgICAgYFBsZWFzZSByZXBvcnQgdGhpcyBpc3N1ZSB3aXRoIHRoZSBcIiR7dXRpbHMuc2F2ZURlYnVnRmlsZShcbiAgICAgICAgICBcIndhdGNoLmh0bWxcIixcbiAgICAgICAgICBib2R5LFxuICAgICAgICApfVwiIGZpbGUgb24gaHR0cHM6Ly9naXRodWIuY29tL2Rpc3R1YmVqcy95dGRsLWNvcmUvaXNzdWVzLmAsXG4gICAgKTtcbiAgfVxuICByZXR1cm4gaW5mbztcbn07XG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3R9IHBsYXllcl9yZXNwb25zZVxuICogQHJldHVybnMge0FycmF5LjxPYmplY3Q+fVxuICovXG5jb25zdCBwYXJzZUZvcm1hdHMgPSBwbGF5ZXJfcmVzcG9uc2UgPT4ge1xuICByZXR1cm4gKHBsYXllcl9yZXNwb25zZT8uc3RyZWFtaW5nRGF0YT8uZm9ybWF0cyB8fCBbXSk/LmNvbmNhdChwbGF5ZXJfcmVzcG9uc2U/LnN0cmVhbWluZ0RhdGE/LmFkYXB0aXZlRm9ybWF0cyB8fCBbXSk7XG59O1xuXG5jb25zdCBwYXJzZUFkZGl0aW9uYWxNYW5pZmVzdHMgPSAocGxheWVyX3Jlc3BvbnNlLCBvcHRpb25zKSA9PiB7XG4gIGNvbnN0IHN0cmVhbWluZ0RhdGEgPSBwbGF5ZXJfcmVzcG9uc2U/LnN0cmVhbWluZ0RhdGEsXG4gICAgbWFuaWZlc3RzID0gW107XG4gIGlmIChzdHJlYW1pbmdEYXRhKSB7XG4gICAgaWYgKHN0cmVhbWluZ0RhdGEuZGFzaE1hbmlmZXN0VXJsKSB7XG4gICAgICBtYW5pZmVzdHMucHVzaChnZXREYXNoTWFuaWZlc3Qoc3RyZWFtaW5nRGF0YS5kYXNoTWFuaWZlc3RVcmwsIG9wdGlvbnMpKTtcbiAgICB9XG4gICAgaWYgKHN0cmVhbWluZ0RhdGEuaGxzTWFuaWZlc3RVcmwpIHtcbiAgICAgIG1hbmlmZXN0cy5wdXNoKGdldE0zVTgoc3RyZWFtaW5nRGF0YS5obHNNYW5pZmVzdFVybCwgb3B0aW9ucykpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbWFuaWZlc3RzO1xufTtcblxuLy8gVE9ETzogQ2xlYW4gdXAgdGhpcyBmdW5jdGlvbiBmb3IgcmVhZGFiaWxpdHkgYW5kIHN1cHBvcnQgbW9yZSBjbGllbnRzXG4vKipcbiAqIEdldHMgaW5mbyBmcm9tIGEgdmlkZW8gYWRkaXRpb25hbCBmb3JtYXRzIGFuZCBkZWNpcGhlcmVkIFVSTHMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGlkXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn1cbiAqL1xuZXhwb3J0cy5nZXRJbmZvID0gYXN5bmMgKGlkLCBvcHRpb25zKSA9PiB7XG4gIC8vIEluaXRpYWxpemUgcmVxdWVzdCBvcHRpb25zXG4gIHV0aWxzLmFwcGx5SVB2NlJvdGF0aW9ucyhvcHRpb25zKTtcbiAgdXRpbHMuYXBwbHlEZWZhdWx0SGVhZGVycyhvcHRpb25zKTtcbiAgdXRpbHMuYXBwbHlEZWZhdWx0QWdlbnQob3B0aW9ucyk7XG4gIHV0aWxzLmFwcGx5T2xkTG9jYWxBZGRyZXNzKG9wdGlvbnMpO1xuICB1dGlscy5hcHBseVBsYXllckNsaWVudHMob3B0aW9ucyk7XG5cbiAgY29uc3QgaW5mbyA9IGF3YWl0IGV4cG9ydHMuZ2V0QmFzaWNJbmZvKGlkLCBvcHRpb25zKTtcblxuICBpbmZvLmh0bWw1cGxheWVyID1cbiAgICBpbmZvLmh0bWw1cGxheWVyIHx8XG4gICAgZ2V0SFRNTDVwbGF5ZXIoYXdhaXQgZ2V0V2F0Y2hIVE1MUGFnZUJvZHkoaWQsIG9wdGlvbnMpKSB8fFxuICAgIGdldEhUTUw1cGxheWVyKGF3YWl0IGdldEVtYmVkUGFnZUJvZHkoaWQsIG9wdGlvbnMpKTtcblxuICBpZiAoIWluZm8uaHRtbDVwbGF5ZXIpIHtcbiAgICB0aHJvdyBFcnJvcihcIlVuYWJsZSB0byBmaW5kIGh0bWw1cGxheWVyIGZpbGVcIik7XG4gIH1cblxuICBpbmZvLmh0bWw1cGxheWVyID0gbmV3IFVSTChpbmZvLmh0bWw1cGxheWVyLCBCQVNFX1VSTCkudG9TdHJpbmcoKTtcblxuICBjb25zdCBmb3JtYXRQcm9taXNlcyA9IFtdO1xuXG4gIHRyeSB7XG4gICAgY29uc3QgY2xpZW50UHJvbWlzZXMgPSBbXTtcblxuICAgIGlmIChvcHRpb25zLnBsYXllckNsaWVudHMuaW5jbHVkZXMoXCJXRUJfRU1CRURERURcIikpIGNsaWVudFByb21pc2VzLnB1c2goZmV0Y2hXZWJFbWJlZGRlZFBsYXllcihpZCwgaW5mbywgb3B0aW9ucykpO1xuICAgIGlmIChvcHRpb25zLnBsYXllckNsaWVudHMuaW5jbHVkZXMoXCJUVlwiKSkgY2xpZW50UHJvbWlzZXMucHVzaChmZXRjaFR2UGxheWVyKGlkLCBpbmZvLCBvcHRpb25zKSk7XG4gICAgaWYgKG9wdGlvbnMucGxheWVyQ2xpZW50cy5pbmNsdWRlcyhcIklPU1wiKSkgY2xpZW50UHJvbWlzZXMucHVzaChmZXRjaElvc0pzb25QbGF5ZXIoaWQsIG9wdGlvbnMpKTtcbiAgICBpZiAob3B0aW9ucy5wbGF5ZXJDbGllbnRzLmluY2x1ZGVzKFwiQU5EUk9JRFwiKSkgY2xpZW50UHJvbWlzZXMucHVzaChmZXRjaEFuZHJvaWRKc29uUGxheWVyKGlkLCBvcHRpb25zKSk7XG5cbiAgICBpZiAoY2xpZW50UHJvbWlzZXMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgcmVzcG9uc2VzID0gYXdhaXQgUHJvbWlzZS5hbGxTZXR0bGVkKGNsaWVudFByb21pc2VzKTtcbiAgICAgIGNvbnN0IHN1Y2Nlc3NmdWxSZXNwb25zZXMgPSByZXNwb25zZXNcbiAgICAgICAgLmZpbHRlcihyID0+IHIuc3RhdHVzID09PSBcImZ1bGZpbGxlZFwiKVxuICAgICAgICAubWFwKHIgPT4gci52YWx1ZSlcbiAgICAgICAgLmZpbHRlcihyID0+IHIpO1xuXG4gICAgICBmb3IgKGNvbnN0IHJlc3BvbnNlIG9mIHN1Y2Nlc3NmdWxSZXNwb25zZXMpIHtcbiAgICAgICAgY29uc3QgZm9ybWF0cyA9IHBhcnNlRm9ybWF0cyhyZXNwb25zZSk7XG4gICAgICAgIGlmIChmb3JtYXRzICYmIGZvcm1hdHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGZvcm1hdFByb21pc2VzLnB1c2goc2lnLmRlY2lwaGVyRm9ybWF0cyhmb3JtYXRzLCBpbmZvLmh0bWw1cGxheWVyLCBvcHRpb25zKSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBtYW5pZmVzdFByb21pc2VzID0gcGFyc2VBZGRpdGlvbmFsTWFuaWZlc3RzKHJlc3BvbnNlLCBvcHRpb25zKTtcbiAgICAgICAgZm9ybWF0UHJvbWlzZXMucHVzaCguLi5tYW5pZmVzdFByb21pc2VzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5wbGF5ZXJDbGllbnRzLmluY2x1ZGVzKFwiV0VCXCIpKSB7XG4gICAgICBiZXN0UGxheWVyUmVzcG9uc2UgPSBpbmZvLnBsYXllcl9yZXNwb25zZTtcblxuICAgICAgY29uc3QgZm9ybWF0cyA9IHBhcnNlRm9ybWF0cyhpbmZvLnBsYXllcl9yZXNwb25zZSk7XG4gICAgICBpZiAoZm9ybWF0cyAmJiBmb3JtYXRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZm9ybWF0UHJvbWlzZXMucHVzaChzaWcuZGVjaXBoZXJGb3JtYXRzKGZvcm1hdHMsIGluZm8uaHRtbDVwbGF5ZXIsIG9wdGlvbnMpKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbWFuaWZlc3RQcm9taXNlcyA9IHBhcnNlQWRkaXRpb25hbE1hbmlmZXN0cyhpbmZvLnBsYXllcl9yZXNwb25zZSwgb3B0aW9ucyk7XG4gICAgICBmb3JtYXRQcm9taXNlcy5wdXNoKC4uLm1hbmlmZXN0UHJvbWlzZXMpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZmV0Y2hpbmcgZm9ybWF0czpcIiwgZXJyb3IpO1xuXG4gICAgY29uc3QgZm9ybWF0cyA9IHBhcnNlRm9ybWF0cyhpbmZvLnBsYXllcl9yZXNwb25zZSk7XG4gICAgaWYgKGZvcm1hdHMgJiYgZm9ybWF0cy5sZW5ndGggPiAwKSB7XG4gICAgICBmb3JtYXRQcm9taXNlcy5wdXNoKHNpZy5kZWNpcGhlckZvcm1hdHMoZm9ybWF0cywgaW5mby5odG1sNXBsYXllciwgb3B0aW9ucykpO1xuICAgIH1cblxuICAgIGNvbnN0IG1hbmlmZXN0UHJvbWlzZXMgPSBwYXJzZUFkZGl0aW9uYWxNYW5pZmVzdHMoaW5mby5wbGF5ZXJfcmVzcG9uc2UsIG9wdGlvbnMpO1xuICAgIGZvcm1hdFByb21pc2VzLnB1c2goLi4ubWFuaWZlc3RQcm9taXNlcyk7XG4gIH1cblxuICBpZiAoZm9ybWF0UHJvbWlzZXMubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGZpbmQgYW55IHBsYXlhYmxlIGZvcm1hdHNcIik7XG4gIH1cblxuICBjb25zdCByZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGwoZm9ybWF0UHJvbWlzZXMpO1xuICBpbmZvLmZvcm1hdHMgPSBPYmplY3QudmFsdWVzKE9iamVjdC5hc3NpZ24oe30sIC4uLnJlc3VsdHMpKTtcblxuICBpbmZvLmZvcm1hdHMgPSBpbmZvLmZvcm1hdHMuZmlsdGVyKGZvcm1hdCA9PiBmb3JtYXQgJiYgZm9ybWF0LnVybCAmJiBmb3JtYXQubWltZVR5cGUpO1xuXG4gIGlmIChpbmZvLmZvcm1hdHMubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gcGxheWFibGUgZm9ybWF0cyBmb3VuZFwiKTtcbiAgfVxuXG4gIGluZm8uZm9ybWF0cyA9IGluZm8uZm9ybWF0cy5tYXAoZm9ybWF0ID0+IHtcbiAgICBjb25zdCBlbmhhbmNlZEZvcm1hdCA9IGZvcm1hdFV0aWxzLmFkZEZvcm1hdE1ldGEoZm9ybWF0KTtcblxuICAgIGlmICghZW5oYW5jZWRGb3JtYXQuYXVkaW9CaXRyYXRlICYmIGVuaGFuY2VkRm9ybWF0Lmhhc0F1ZGlvKSB7XG4gICAgICBlbmhhbmNlZEZvcm1hdC5hdWRpb0JpdHJhdGUgPSBlc3RpbWF0ZUF1ZGlvQml0cmF0ZShlbmhhbmNlZEZvcm1hdCk7XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgIWVuaGFuY2VkRm9ybWF0LmlzSExTICYmXG4gICAgICBlbmhhbmNlZEZvcm1hdC5taW1lVHlwZSAmJlxuICAgICAgKGVuaGFuY2VkRm9ybWF0Lm1pbWVUeXBlLmluY2x1ZGVzKFwiaGxzXCIpIHx8XG4gICAgICAgIGVuaGFuY2VkRm9ybWF0Lm1pbWVUeXBlLmluY2x1ZGVzKFwieC1tcGVnVVJMXCIpIHx8XG4gICAgICAgIGVuaGFuY2VkRm9ybWF0Lm1pbWVUeXBlLmluY2x1ZGVzKFwiYXBwbGljYXRpb24vdm5kLmFwcGxlLm1wZWd1cmxcIikpXG4gICAgKSB7XG4gICAgICBlbmhhbmNlZEZvcm1hdC5pc0hMUyA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVuaGFuY2VkRm9ybWF0O1xuICB9KTtcblxuICBpbmZvLmZvcm1hdHMuc29ydChmb3JtYXRVdGlscy5zb3J0Rm9ybWF0cyk7XG5cbiAgY29uc3QgYmVzdEZvcm1hdCA9XG4gICAgaW5mby5mb3JtYXRzLmZpbmQoZm9ybWF0ID0+IGZvcm1hdC5oYXNWaWRlbyAmJiBmb3JtYXQuaGFzQXVkaW8pIHx8XG4gICAgaW5mby5mb3JtYXRzLmZpbmQoZm9ybWF0ID0+IGZvcm1hdC5oYXNWaWRlbykgfHxcbiAgICBpbmZvLmZvcm1hdHMuZmluZChmb3JtYXQgPT4gZm9ybWF0Lmhhc0F1ZGlvKSB8fFxuICAgIGluZm8uZm9ybWF0c1swXTtcblxuICBpbmZvLmJlc3RGb3JtYXQgPSBiZXN0Rm9ybWF0O1xuICBpbmZvLnZpZGVvVXJsID0gYmVzdEZvcm1hdC51cmw7XG4gIGluZm8uc2VsZWN0ZWRGb3JtYXQgPSBiZXN0Rm9ybWF0O1xuICBpbmZvLmZ1bGwgPSB0cnVlO1xuXG4gIHJldHVybiBpbmZvO1xufTtcblxuY29uc3QgZ2V0UGxheWJhY2tDb250ZXh0ID0gYXN5bmMgKGh0bWw1cGxheWVyLCBvcHRpb25zKSA9PiB7XG4gIGNvbnN0IGJvZHkgPSBhd2FpdCB1dGlscy5yZXF1ZXN0KGh0bWw1cGxheWVyLCBvcHRpb25zKTtcbiAgY29uc3QgbW8gPSBib2R5Lm1hdGNoKC8oc2lnbmF0dXJlVGltZXN0YW1wfHN0cyk6KFxcZCspLyk7XG4gIHJldHVybiB7XG4gICAgY29udGVudFBsYXliYWNrQ29udGV4dDoge1xuICAgICAgaHRtbDVQcmVmZXJlbmNlOiBcIkhUTUw1X1BSRUZfV0FOVFNcIixcbiAgICAgIHNpZ25hdHVyZVRpbWVzdGFtcDogbW8/LlsyXSxcbiAgICB9LFxuICB9O1xufTtcblxuY29uc3QgZ2V0VmlzaXRvckRhdGEgPSAoaW5mbywgX29wdGlvbnMpID0+IHtcbiAgZm9yIChjb25zdCByZXNwS2V5IG9mIFtcInBsYXllcl9yZXNwb25zZVwiLCBcInJlc3BvbnNlXCJdKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBpbmZvW3Jlc3BLZXldLnJlc3BvbnNlQ29udGV4dC5zZXJ2aWNlVHJhY2tpbmdQYXJhbXNcbiAgICAgICAgICAuZmluZCh4ID0+IHguc2VydmljZSA9PT0gXCJHRkVFREJBQ0tcIikucGFyYW1zXG4gICAgICAgICAgLmZpbmQoeCA9PiB4LmtleSA9PT0gXCJ2aXNpdG9yX2RhdGFcIikudmFsdWU7XG4gICAgfVxuICAgIGNhdGNoIHsgLyogbm90IHByZXNlbnQgKi8gfVxuICB9XG4gIHJldHVybiB1bmRlZmluZWQ7XG59O1xuXG5jb25zdCBMT0NBTEUgPSB7IGhsOiBcImVuXCIsIHRpbWVab25lOiBcIlVUQ1wiLCB1dGNPZmZzZXRNaW51dGVzOiAwIH0sXG4gIENIRUNLX0ZMQUdTID0geyBjb250ZW50Q2hlY2tPazogdHJ1ZSwgcmFjeUNoZWNrT2s6IHRydWUgfTtcblxuY29uc3QgV0VCX0VNQkVEREVEX0NPTlRFWFQgPSB7XG4gIGNsaWVudDoge1xuICAgIGNsaWVudE5hbWU6IFwiV0VCX0VNQkVEREVEX1BMQVlFUlwiLFxuICAgIGNsaWVudFZlcnNpb246IFwiMS4yMDI0MDcyMy4wMS4wMFwiLFxuICAgIC4uLkxPQ0FMRSxcbiAgfSxcbn07XG5cbmNvbnN0IFRWSFRNTDVfQ09OVEVYVCA9IHtcbiAgY2xpZW50OiB7XG4gICAgY2xpZW50TmFtZTogXCJUVkhUTUw1XCIsXG4gICAgY2xpZW50VmVyc2lvbjogXCI3LjIwMjQwNzI0LjEzLjAwXCIsXG4gICAgLi4uTE9DQUxFLFxuICB9LFxufTtcblxuY29uc3QgZmV0Y2hXZWJFbWJlZGRlZFBsYXllciA9IGFzeW5jICh2aWRlb0lkLCBpbmZvLCBvcHRpb25zKSA9PiB7XG4gIGNvbnN0IHBheWxvYWQgPSB7XG4gICAgY29udGV4dDogV0VCX0VNQkVEREVEX0NPTlRFWFQsXG4gICAgdmlkZW9JZCxcbiAgICBwbGF5YmFja0NvbnRleHQ6IGF3YWl0IGdldFBsYXliYWNrQ29udGV4dChpbmZvLmh0bWw1cGxheWVyLCBvcHRpb25zKSxcbiAgICAuLi5DSEVDS19GTEFHUyxcbiAgfTtcbiAgcmV0dXJuIGF3YWl0IHBsYXllckFQSSh2aWRlb0lkLCBwYXlsb2FkLCBvcHRpb25zKTtcbn07XG5jb25zdCBmZXRjaFR2UGxheWVyID0gYXN5bmMgKHZpZGVvSWQsIGluZm8sIG9wdGlvbnMpID0+IHtcbiAgY29uc3QgcGF5bG9hZCA9IHtcbiAgICBjb250ZXh0OiBUVkhUTUw1X0NPTlRFWFQsXG4gICAgdmlkZW9JZCxcbiAgICBwbGF5YmFja0NvbnRleHQ6IGF3YWl0IGdldFBsYXliYWNrQ29udGV4dChpbmZvLmh0bWw1cGxheWVyLCBvcHRpb25zKSxcbiAgICAuLi5DSEVDS19GTEFHUyxcbiAgfTtcblxuICBvcHRpb25zLnZpc2l0b3JJZCA9IGdldFZpc2l0b3JEYXRhKGluZm8sIG9wdGlvbnMpO1xuXG4gIHJldHVybiBhd2FpdCBwbGF5ZXJBUEkodmlkZW9JZCwgcGF5bG9hZCwgb3B0aW9ucyk7XG59O1xuXG5jb25zdCBwbGF5ZXJBUEkgPSBhc3luYyAodmlkZW9JZCwgcGF5bG9hZCwgb3B0aW9ucykgPT4ge1xuICBjb25zdCB7IGphciwgZGlzcGF0Y2hlciB9ID0gb3B0aW9ucy5hZ2VudDtcbiAgY29uc3Qgb3B0cyA9IHtcbiAgICByZXF1ZXN0T3B0aW9uczoge1xuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgIGRpc3BhdGNoZXIsXG4gICAgICBxdWVyeToge1xuICAgICAgICBwcmV0dHlQcmludDogZmFsc2UsXG4gICAgICAgIHQ6IHV0aWxzLmdlbmVyYXRlQ2xpZW50UGxheWJhY2tOb25jZSgxMiksXG4gICAgICAgIGlkOiB2aWRlb0lkLFxuICAgICAgfSxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgIENvb2tpZTogamFyLmdldENvb2tpZVN0cmluZ1N5bmMoXCJodHRwczovL3d3dy55b3V0dWJlLmNvbVwiKSxcbiAgICAgICAgXCJYLUdvb2ctQXBpLUZvcm1hdC1WZXJzaW9uXCI6IFwiMlwiLFxuICAgICAgfSxcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHBheWxvYWQpLFxuICAgIH0sXG4gIH07XG4gIGlmIChvcHRpb25zLnZpc2l0b3JJZCkgb3B0cy5yZXF1ZXN0T3B0aW9ucy5oZWFkZXJzW1wiWC1Hb29nLVZpc2l0b3ItSWRcIl0gPSBvcHRpb25zLnZpc2l0b3JJZDtcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB1dGlscy5yZXF1ZXN0KFwiaHR0cHM6Ly95b3V0dWJlaS5nb29nbGVhcGlzLmNvbS95b3V0dWJlaS92MS9wbGF5ZXJcIiwgb3B0cyk7XG4gIGNvbnN0IHBsYXlFcnIgPSB1dGlscy5wbGF5RXJyb3IocmVzcG9uc2UpO1xuICBpZiAocGxheUVycikgdGhyb3cgcGxheUVycjtcbiAgaWYgKCFyZXNwb25zZS52aWRlb0RldGFpbHMgfHwgdmlkZW9JZCAhPT0gcmVzcG9uc2UudmlkZW9EZXRhaWxzLnZpZGVvSWQpIHtcbiAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoXCJNYWxmb3JtZWQgcmVzcG9uc2UgZnJvbSBZb3VUdWJlXCIpO1xuICAgIGVyci5yZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgIHRocm93IGVycjtcbiAgfVxuICByZXR1cm4gcmVzcG9uc2U7XG59O1xuXG5jb25zdCBJT1NfQ0xJRU5UX1ZFUlNJT04gPSBcIjE5LjQ1LjRcIixcbiAgSU9TX0RFVklDRV9NT0RFTCA9IFwiaVBob25lMTYsMlwiLFxuICBJT1NfVVNFUl9BR0VOVF9WRVJTSU9OID0gXCIxN181XzFcIixcbiAgSU9TX09TX1ZFUlNJT04gPSBcIjE3LjUuMS4yMUY5MFwiO1xuXG5jb25zdCBmZXRjaElvc0pzb25QbGF5ZXIgPSBhc3luYyAodmlkZW9JZCwgb3B0aW9ucykgPT4ge1xuICBjb25zdCBwYXlsb2FkID0ge1xuICAgIHZpZGVvSWQsXG4gICAgY3BuOiB1dGlscy5nZW5lcmF0ZUNsaWVudFBsYXliYWNrTm9uY2UoMTYpLFxuICAgIGNvbnRlbnRDaGVja09rOiB0cnVlLFxuICAgIHJhY3lDaGVja09rOiB0cnVlLFxuICAgIGNvbnRleHQ6IHtcbiAgICAgIGNsaWVudDoge1xuICAgICAgICBjbGllbnROYW1lOiBcIklPU1wiLFxuICAgICAgICBjbGllbnRWZXJzaW9uOiBJT1NfQ0xJRU5UX1ZFUlNJT04sXG4gICAgICAgIGRldmljZU1ha2U6IFwiQXBwbGVcIixcbiAgICAgICAgZGV2aWNlTW9kZWw6IElPU19ERVZJQ0VfTU9ERUwsXG4gICAgICAgIHBsYXRmb3JtOiBcIk1PQklMRVwiLFxuICAgICAgICBvc05hbWU6IFwiaU9TXCIsXG4gICAgICAgIG9zVmVyc2lvbjogSU9TX09TX1ZFUlNJT04sXG4gICAgICAgIGhsOiBcImVuXCIsXG4gICAgICAgIGdsOiBcIlVTXCIsXG4gICAgICAgIHV0Y09mZnNldE1pbnV0ZXM6IC0yNDAsXG4gICAgICB9LFxuICAgICAgcmVxdWVzdDoge1xuICAgICAgICBpbnRlcm5hbEV4cGVyaW1lbnRGbGFnczogW10sXG4gICAgICAgIHVzZVNzbDogdHJ1ZSxcbiAgICAgIH0sXG4gICAgICB1c2VyOiB7XG4gICAgICAgIGxvY2tlZFNhZmV0eU1vZGU6IGZhbHNlLFxuICAgICAgfSxcbiAgICB9LFxuICB9O1xuXG4gIGNvbnN0IHsgamFyLCBkaXNwYXRjaGVyIH0gPSBvcHRpb25zLmFnZW50O1xuICBjb25zdCBvcHRzID0ge1xuICAgIHJlcXVlc3RPcHRpb25zOiB7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgZGlzcGF0Y2hlcixcbiAgICAgIHF1ZXJ5OiB7XG4gICAgICAgIHByZXR0eVByaW50OiBmYWxzZSxcbiAgICAgICAgdDogdXRpbHMuZ2VuZXJhdGVDbGllbnRQbGF5YmFja05vbmNlKDEyKSxcbiAgICAgICAgaWQ6IHZpZGVvSWQsXG4gICAgICB9LFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgY29va2llOiBqYXIuZ2V0Q29va2llU3RyaW5nU3luYyhcImh0dHBzOi8vd3d3LnlvdXR1YmUuY29tXCIpLFxuICAgICAgICBcIlVzZXItQWdlbnRcIjogYGNvbS5nb29nbGUuaW9zLnlvdXR1YmUvJHtJT1NfQ0xJRU5UX1ZFUlNJT059KCR7XG4gICAgICAgICAgSU9TX0RFVklDRV9NT0RFTFxuICAgICAgICB9OyBVOyBDUFUgaU9TICR7SU9TX1VTRVJfQUdFTlRfVkVSU0lPTn0gbGlrZSBNYWMgT1MgWDsgZW5fVVMpYCxcbiAgICAgICAgXCJYLUdvb2ctQXBpLUZvcm1hdC1WZXJzaW9uXCI6IFwiMlwiLFxuICAgICAgfSxcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHBheWxvYWQpLFxuICAgIH0sXG4gIH07XG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdXRpbHMucmVxdWVzdChcImh0dHBzOi8veW91dHViZWkuZ29vZ2xlYXBpcy5jb20veW91dHViZWkvdjEvcGxheWVyXCIsIG9wdHMpO1xuICBjb25zdCBwbGF5RXJyID0gdXRpbHMucGxheUVycm9yKHJlc3BvbnNlKTtcbiAgaWYgKHBsYXlFcnIpIHRocm93IHBsYXlFcnI7XG4gIGlmICghcmVzcG9uc2UudmlkZW9EZXRhaWxzIHx8IHZpZGVvSWQgIT09IHJlc3BvbnNlLnZpZGVvRGV0YWlscy52aWRlb0lkKSB7XG4gICAgY29uc3QgZXJyID0gbmV3IEVycm9yKFwiTWFsZm9ybWVkIHJlc3BvbnNlIGZyb20gWW91VHViZVwiKTtcbiAgICBlcnIucmVzcG9uc2UgPSByZXNwb25zZTtcbiAgICB0aHJvdyBlcnI7XG4gIH1cbiAgcmV0dXJuIHJlc3BvbnNlO1xufTtcblxuY29uc3QgQU5EUk9JRF9DTElFTlRfVkVSU0lPTiA9IFwiMTkuNDQuMzhcIixcbiAgQU5EUk9JRF9PU19WRVJTSU9OID0gXCIxMVwiLFxuICBBTkRST0lEX1NES19WRVJTSU9OID0gXCIzMFwiO1xuXG5jb25zdCBmZXRjaEFuZHJvaWRKc29uUGxheWVyID0gYXN5bmMgKHZpZGVvSWQsIG9wdGlvbnMpID0+IHtcbiAgY29uc3QgcGF5bG9hZCA9IHtcbiAgICB2aWRlb0lkLFxuICAgIGNwbjogdXRpbHMuZ2VuZXJhdGVDbGllbnRQbGF5YmFja05vbmNlKDE2KSxcbiAgICBjb250ZW50Q2hlY2tPazogdHJ1ZSxcbiAgICByYWN5Q2hlY2tPazogdHJ1ZSxcbiAgICBjb250ZXh0OiB7XG4gICAgICBjbGllbnQ6IHtcbiAgICAgICAgY2xpZW50TmFtZTogXCJBTkRST0lEXCIsXG4gICAgICAgIGNsaWVudFZlcnNpb246IEFORFJPSURfQ0xJRU5UX1ZFUlNJT04sXG4gICAgICAgIHBsYXRmb3JtOiBcIk1PQklMRVwiLFxuICAgICAgICBvc05hbWU6IFwiQW5kcm9pZFwiLFxuICAgICAgICBvc1ZlcnNpb246IEFORFJPSURfT1NfVkVSU0lPTixcbiAgICAgICAgYW5kcm9pZFNka1ZlcnNpb246IEFORFJPSURfU0RLX1ZFUlNJT04sXG4gICAgICAgIGhsOiBcImVuXCIsXG4gICAgICAgIGdsOiBcIlVTXCIsXG4gICAgICAgIHV0Y09mZnNldE1pbnV0ZXM6IC0yNDAsXG4gICAgICB9LFxuICAgICAgcmVxdWVzdDoge1xuICAgICAgICBpbnRlcm5hbEV4cGVyaW1lbnRGbGFnczogW10sXG4gICAgICAgIHVzZVNzbDogdHJ1ZSxcbiAgICAgIH0sXG4gICAgICB1c2VyOiB7XG4gICAgICAgIGxvY2tlZFNhZmV0eU1vZGU6IGZhbHNlLFxuICAgICAgfSxcbiAgICB9LFxuICB9O1xuXG4gIGNvbnN0IHsgamFyLCBkaXNwYXRjaGVyIH0gPSBvcHRpb25zLmFnZW50O1xuICBjb25zdCBvcHRzID0ge1xuICAgIHJlcXVlc3RPcHRpb25zOiB7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgZGlzcGF0Y2hlcixcbiAgICAgIHF1ZXJ5OiB7XG4gICAgICAgIHByZXR0eVByaW50OiBmYWxzZSxcbiAgICAgICAgdDogdXRpbHMuZ2VuZXJhdGVDbGllbnRQbGF5YmFja05vbmNlKDEyKSxcbiAgICAgICAgaWQ6IHZpZGVvSWQsXG4gICAgICB9LFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgY29va2llOiBqYXIuZ2V0Q29va2llU3RyaW5nU3luYyhcImh0dHBzOi8vd3d3LnlvdXR1YmUuY29tXCIpLFxuICAgICAgICBcIlVzZXItQWdlbnRcIjogYGNvbS5nb29nbGUuYW5kcm9pZC55b3V0dWJlLyR7XG4gICAgICAgICAgQU5EUk9JRF9DTElFTlRfVkVSU0lPTlxuICAgICAgICB9IChMaW51eDsgVTsgQW5kcm9pZCAke0FORFJPSURfT1NfVkVSU0lPTn0pIGd6aXBgLFxuICAgICAgICBcIlgtR29vZy1BcGktRm9ybWF0LVZlcnNpb25cIjogXCIyXCIsXG4gICAgICB9LFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkocGF5bG9hZCksXG4gICAgfSxcbiAgfTtcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB1dGlscy5yZXF1ZXN0KFwiaHR0cHM6Ly95b3V0dWJlaS5nb29nbGVhcGlzLmNvbS95b3V0dWJlaS92MS9wbGF5ZXJcIiwgb3B0cyk7XG4gIGNvbnN0IHBsYXlFcnIgPSB1dGlscy5wbGF5RXJyb3IocmVzcG9uc2UpO1xuICBpZiAocGxheUVycikgdGhyb3cgcGxheUVycjtcbiAgaWYgKCFyZXNwb25zZS52aWRlb0RldGFpbHMgfHwgdmlkZW9JZCAhPT0gcmVzcG9uc2UudmlkZW9EZXRhaWxzLnZpZGVvSWQpIHtcbiAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoXCJNYWxmb3JtZWQgcmVzcG9uc2UgZnJvbSBZb3VUdWJlXCIpO1xuICAgIGVyci5yZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgIHRocm93IGVycjtcbiAgfVxuICByZXR1cm4gcmVzcG9uc2U7XG59O1xuXG4vKipcbiAqIEdldHMgYWRkaXRpb25hbCBEQVNIIGZvcm1hdHMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVybFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm5zIHtQcm9taXNlPEFycmF5LjxPYmplY3Q+Pn1cbiAqL1xuY29uc3QgZ2V0RGFzaE1hbmlmZXN0ID0gKHVybCwgb3B0aW9ucykgPT5cbiAgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IGZvcm1hdHMgPSB7fTtcbiAgICBjb25zdCBwYXJzZXIgPSBzYXgucGFyc2VyKGZhbHNlKTtcbiAgICBwYXJzZXIub25lcnJvciA9IHJlamVjdDtcbiAgICBsZXQgYWRhcHRhdGlvblNldDtcbiAgICBwYXJzZXIub25vcGVudGFnID0gbm9kZSA9PiB7XG4gICAgICBpZiAobm9kZS5uYW1lID09PSBcIkFEQVBUQVRJT05TRVRcIikge1xuICAgICAgICBhZGFwdGF0aW9uU2V0ID0gbm9kZS5hdHRyaWJ1dGVzO1xuICAgICAgfSBlbHNlIGlmIChub2RlLm5hbWUgPT09IFwiUkVQUkVTRU5UQVRJT05cIikge1xuICAgICAgICBjb25zdCBpdGFnID0gcGFyc2VJbnQobm9kZS5hdHRyaWJ1dGVzLklEKTtcbiAgICAgICAgaWYgKCFpc05hTihpdGFnKSkge1xuICAgICAgICAgIGZvcm1hdHNbdXJsXSA9IE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGl0YWcsXG4gICAgICAgICAgICAgIHVybCxcbiAgICAgICAgICAgICAgYml0cmF0ZTogcGFyc2VJbnQobm9kZS5hdHRyaWJ1dGVzLkJBTkRXSURUSCksXG4gICAgICAgICAgICAgIG1pbWVUeXBlOiBgJHthZGFwdGF0aW9uU2V0Lk1JTUVUWVBFfTsgY29kZWNzPVwiJHtub2RlLmF0dHJpYnV0ZXMuQ09ERUNTfVwiYCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBub2RlLmF0dHJpYnV0ZXMuSEVJR0hUXG4gICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgd2lkdGg6IHBhcnNlSW50KG5vZGUuYXR0cmlidXRlcy5XSURUSCksXG4gICAgICAgICAgICAgICAgICBoZWlnaHQ6IHBhcnNlSW50KG5vZGUuYXR0cmlidXRlcy5IRUlHSFQpLFxuICAgICAgICAgICAgICAgICAgZnBzOiBwYXJzZUludChub2RlLmF0dHJpYnV0ZXMuRlJBTUVSQVRFKSxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAgICAgYXVkaW9TYW1wbGVSYXRlOiBub2RlLmF0dHJpYnV0ZXMuQVVESU9TQU1QTElOR1JBVEUsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBwYXJzZXIub25lbmQgPSAoKSA9PiB7XG4gICAgICByZXNvbHZlKGZvcm1hdHMpO1xuICAgIH07XG4gICAgdXRpbHNcbiAgICAgIC5yZXF1ZXN0KG5ldyBVUkwodXJsLCBCQVNFX1VSTCkudG9TdHJpbmcoKSwgb3B0aW9ucylcbiAgICAgIC50aGVuKHJlcyA9PiB7XG4gICAgICAgIHBhcnNlci53cml0ZShyZXMpO1xuICAgICAgICBwYXJzZXIuY2xvc2UoKTtcbiAgICAgIH0pXG4gICAgICAuY2F0Y2gocmVqZWN0KTtcbiAgfSk7XG5cbi8qKlxuICogR2V0cyBhZGRpdGlvbmFsIGZvcm1hdHMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVybFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm5zIHtQcm9taXNlPEFycmF5LjxPYmplY3Q+Pn1cbiAqL1xuY29uc3QgZ2V0TTNVOCA9IGFzeW5jICh1cmwsIG9wdGlvbnMpID0+IHtcbiAgdXJsID0gbmV3IFVSTCh1cmwsIEJBU0VfVVJMKTtcbiAgY29uc3QgYm9keSA9IGF3YWl0IHV0aWxzLnJlcXVlc3QodXJsLnRvU3RyaW5nKCksIG9wdGlvbnMpO1xuICBjb25zdCBmb3JtYXRzID0ge307XG4gIGJvZHlcbiAgICAuc3BsaXQoXCJcXG5cIilcbiAgICAuZmlsdGVyKGxpbmUgPT4gL15odHRwcz86XFwvXFwvLy50ZXN0KGxpbmUpKVxuICAgIC5mb3JFYWNoKGxpbmUgPT4ge1xuICAgICAgY29uc3QgaXRhZyA9IHBhcnNlSW50KGxpbmUubWF0Y2goL1xcL2l0YWdcXC8oXFxkKylcXC8vKVsxXSk7XG4gICAgICBmb3JtYXRzW2xpbmVdID0geyBpdGFnLCB1cmw6IGxpbmUgfTtcbiAgICB9KTtcbiAgcmV0dXJuIGZvcm1hdHM7XG59O1xuXG4vLyBDYWNoZSBnZXQgaW5mbyBmdW5jdGlvbnMuXG4vLyBJbiBjYXNlIGEgdXNlciB3YW50cyB0byBnZXQgYSB2aWRlbydzIGluZm8gYmVmb3JlIGRvd25sb2FkaW5nLlxuZm9yIChjb25zdCBmdW5jTmFtZSBvZiBbXCJnZXRCYXNpY0luZm9cIiwgXCJnZXRJbmZvXCJdKSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGlua1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fVxuICAgKi9cbiAgY29uc3QgZnVuYyA9IGV4cG9ydHNbZnVuY05hbWVdO1xuICBleHBvcnRzW2Z1bmNOYW1lXSA9IGFzeW5jIChsaW5rLCBvcHRpb25zID0ge30pID0+IHtcbiAgICB1dGlscy5jaGVja0ZvclVwZGF0ZXMoKTtcbiAgICBjb25zdCBpZCA9IGF3YWl0IHVybFV0aWxzLmdldFZpZGVvSUQobGluayk7XG4gICAgY29uc3Qga2V5ID0gW2Z1bmNOYW1lLCBpZCwgb3B0aW9ucy5sYW5nXS5qb2luKFwiLVwiKTtcbiAgICByZXR1cm4gZXhwb3J0cy5jYWNoZS5nZXRPclNldChrZXksICgpID0+IGZ1bmMoaWQsIG9wdGlvbnMpKTtcbiAgfTtcbn1cblxuLy8gRXhwb3J0IGEgZmV3IGhlbHBlcnMuXG5leHBvcnRzLnZhbGlkYXRlSUQgPSB1cmxVdGlscy52YWxpZGF0ZUlEO1xuZXhwb3J0cy52YWxpZGF0ZVVSTCA9IHVybFV0aWxzLnZhbGlkYXRlVVJMO1xuZXhwb3J0cy5nZXRVUkxWaWRlb0lEID0gdXJsVXRpbHMuZ2V0VVJMVmlkZW9JRDtcbmV4cG9ydHMuZ2V0VmlkZW9JRCA9IHVybFV0aWxzLmdldFZpZGVvSUQ7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@distube/ytdl-core/lib/info.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@distube/ytdl-core/lib/sig.js":
/*!****************************************************!*\
  !*** ./node_modules/@distube/ytdl-core/lib/sig.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("const querystring = __webpack_require__(/*! querystring */ \"querystring\");\nconst Cache = __webpack_require__(/*! ./cache */ \"(rsc)/./node_modules/@distube/ytdl-core/lib/cache.js\");\nconst utils = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/@distube/ytdl-core/lib/utils.js\");\nconst vm = __webpack_require__(/*! vm */ \"vm\");\n\nexports.cache = new Cache(1);\n\nexports.getFunctions = (html5playerfile, options) =>\n  exports.cache.getOrSet(html5playerfile, async () => {\n    const body = await utils.request(html5playerfile, options);\n    const functions = exports.extractFunctions(body);\n    exports.cache.set(html5playerfile, functions);\n    return functions;\n  });\n\nconst VARIABLE_PART = \"[a-zA-Z_\\\\$][a-zA-Z_0-9\\\\$]*\";\nconst VARIABLE_PART_DEFINE = \"\\\\\\\"?\" + VARIABLE_PART + \"\\\\\\\"?\";\nconst BEFORE_ACCESS = \"(?:\\\\[\\\\\\\"|\\\\.)\";\nconst AFTER_ACCESS = \"(?:\\\\\\\"\\\\]|)\";\nconst VARIABLE_PART_ACCESS = BEFORE_ACCESS + VARIABLE_PART + AFTER_ACCESS;\nconst REVERSE_PART = \":function\\\\(\\\\w\\\\)\\\\{(?:return )?\\\\w\\\\.reverse\\\\(\\\\)\\\\}\";\nconst SLICE_PART = \":function\\\\(\\\\w,\\\\w\\\\)\\\\{return \\\\w\\\\.slice\\\\(\\\\w\\\\)\\\\}\";\nconst SPLICE_PART = \":function\\\\(\\\\w,\\\\w\\\\)\\\\{\\\\w\\\\.splice\\\\(0,\\\\w\\\\)\\\\}\";\nconst SWAP_PART = \":function\\\\(\\\\w,\\\\w\\\\)\\\\{\" +\n  \"var \\\\w=\\\\w\\\\[0\\\\];\\\\w\\\\[0\\\\]=\\\\w\\\\[\\\\w%\\\\w\\\\.length\\\\];\\\\w\\\\[\\\\w(?:%\\\\w.length|)\\\\]=\\\\w(?:;return \\\\w)?\\\\}\";\n\nconst DECIPHER_REGEXP =\n  \"function(?: \" + VARIABLE_PART + \")?\\\\(([a-zA-Z])\\\\)\\\\{\" +\n  \"\\\\1=\\\\1\\\\.split\\\\(\\\"\\\"\\\\);\\\\s*\" +\n  \"((?:(?:\\\\1=)?\" + VARIABLE_PART + VARIABLE_PART_ACCESS + \"\\\\(\\\\1,\\\\d+\\\\);)+)\" +\n  \"return \\\\1\\\\.join\\\\(\\\"\\\"\\\\)\" +\n  \"\\\\}\";\n\nconst HELPER_REGEXP =\n  \"var (\" + VARIABLE_PART + \")=\\\\{((?:(?:\" +\n  VARIABLE_PART_DEFINE + REVERSE_PART + \"|\" +\n  VARIABLE_PART_DEFINE + SLICE_PART + \"|\" +\n  VARIABLE_PART_DEFINE + SPLICE_PART + \"|\" +\n  VARIABLE_PART_DEFINE + SWAP_PART +\n  \"),?\\\\n?)+)\\\\};\";\n\nconst FUNCTION_TCE_REGEXP =\n  \"function(?:\\\\s+[a-zA-Z_\\\\$][a-zA-Z0-9_\\\\$]*)?\\\\(\\\\w\\\\)\\\\{\" +\n  \"\\\\w=\\\\w\\\\.split\\\\((?:\\\"\\\"|[a-zA-Z0-9_$]*\\\\[\\\\d+])\\\\);\" +\n  \"\\\\s*((?:(?:\\\\w=)?[a-zA-Z_\\\\$][a-zA-Z0-9_\\\\$]*(?:\\\\[\\\\\\\"|\\\\.)[a-zA-Z_\\\\$][a-zA-Z0-9_\\\\$]*(?:\\\\\\\"\\\\]|)\\\\(\\\\w,\\\\d+\\\\);)+)\" +\n  \"return \\\\w\\\\.join\\\\((?:\\\"\\\"|[a-zA-Z0-9_$]*\\\\[\\\\d+])\\\\)}\";\n\nconst N_TRANSFORM_REGEXP =\n  \"function\\\\(\\\\s*(\\\\w+)\\\\s*\\\\)\\\\s*\\\\{\" +\n  \"var\\\\s*(\\\\w+)=(?:\\\\1\\\\.split\\\\(.*?\\\\)|String\\\\.prototype\\\\.split\\\\.call\\\\(\\\\1,.*?\\\\)),\" +\n  \"\\\\s*(\\\\w+)=(\\\\[.*?]);\\\\s*\\\\3\\\\[\\\\d+]\" +\n  \"(.*?try)(\\\\{.*?})catch\\\\(\\\\s*(\\\\w+)\\\\s*\\\\)\\\\s*\\\\{\" +\n  '\\\\s*return\"[\\\\w-]+([A-z0-9-]+)\"\\\\s*\\\\+\\\\s*\\\\1\\\\s*}' +\n  '\\\\s*return\\\\s*(\\\\2\\\\.join\\\\(\"\"\\\\)|Array\\\\.prototype\\\\.join\\\\.call\\\\(\\\\2,.*?\\\\))};';\n\nconst N_TRANSFORM_TCE_REGEXP =\n  \"function\\\\(\\\\s*(\\\\w+)\\\\s*\\\\)\\\\s*\\\\{\" +\n  \"\\\\s*var\\\\s*(\\\\w+)=\\\\1\\\\.split\\\\(\\\\1\\\\.slice\\\\(0,0\\\\)\\\\),\\\\s*(\\\\w+)=\\\\[.*?];\" +\n  \".*?catch\\\\(\\\\s*(\\\\w+)\\\\s*\\\\)\\\\s*\\\\{\" +\n  \"\\\\s*return(?:\\\"[^\\\"]+\\\"|\\\\s*[a-zA-Z_0-9$]*\\\\[\\\\d+])\\\\s*\\\\+\\\\s*\\\\1\\\\s*}\" +\n  \"\\\\s*return\\\\s*\\\\2\\\\.join\\\\((?:\\\"\\\"|[a-zA-Z_0-9$]*\\\\[\\\\d+])\\\\)};\";\n\nconst TCE_GLOBAL_VARS_REGEXP =\n  \"(?:^|[;,])\\\\s*(var\\\\s+([\\\\w$]+)\\\\s*=\\\\s*\" +\n  \"(?:\" +\n  \"([\\\"'])(?:\\\\\\\\.|[^\\\\\\\\])*?\\\\3\" +\n  \"\\\\s*\\\\.\\\\s*split\\\\((\" +\n  \"([\\\"'])(?:\\\\\\\\.|[^\\\\\\\\])*?\\\\5\" +\n  \"\\\\))\" +\n  \"|\" +\n  \"\\\\[\\\\s*(?:([\\\"'])(?:\\\\\\\\.|[^\\\\\\\\])*?\\\\6\\\\s*,?\\\\s*)+\\\\]\" +\n  \"))(?=\\\\s*[,;])\";\n\nconst NEW_TCE_GLOBAL_VARS_REGEXP =\n  \"('use\\\\s*strict';)?\" +\n  \"(?<code>var\\\\s*\" +\n  \"(?<varname>[a-zA-Z0-9_$]+)\\\\s*=\\\\s*\" +\n  \"(?<value>\" +\n  \"(?:\\\"[^\\\"\\\\\\\\]*(?:\\\\\\\\.[^\\\"\\\\\\\\]*)*\\\"|'[^'\\\\\\\\]*(?:\\\\\\\\.[^'\\\\\\\\]*)*')\" +\n  \"\\\\.split\\\\(\" +\n  \"(?:\\\"[^\\\"\\\\\\\\]*(?:\\\\\\\\.[^\\\"\\\\\\\\]*)*\\\"|'[^'\\\\\\\\]*(?:\\\\\\\\.[^'\\\\\\\\]*)*')\" +\n  \"\\\\)\" +\n  \"|\" +\n  \"\\\\[\" +\n  \"(?:(?:\\\"[^\\\"\\\\\\\\]*(?:\\\\\\\\.[^\\\"\\\\\\\\]*)*\\\"|'[^'\\\\\\\\]*(?:\\\\\\\\.[^'\\\\\\\\]*)*')\" +\n  \"\\\\s*,?\\\\s*)*\" +\n  \"\\\\]\" +\n  \"|\" +\n  \"\\\"[^\\\"]*\\\"\\\\.split\\\\(\\\"[^\\\"]*\\\"\\\\)\" +\n  \")\" +\n  \")\";\n\nconst TCE_SIGN_FUNCTION_REGEXP = \"function\\\\(\\\\s*([a-zA-Z0-9$])\\\\s*\\\\)\\\\s*\\\\{\" +\n  \"\\\\s*\\\\1\\\\s*=\\\\s*\\\\1\\\\[(\\\\w+)\\\\[\\\\d+\\\\]\\\\]\\\\(\\\\2\\\\[\\\\d+\\\\]\\\\);\" +\n  \"([a-zA-Z0-9$]+)\\\\[\\\\2\\\\[\\\\d+\\\\]\\\\]\\\\(\\\\s*\\\\1\\\\s*,\\\\s*\\\\d+\\\\s*\\\\);\" +\n  \"\\\\s*\\\\3\\\\[\\\\2\\\\[\\\\d+\\\\]\\\\]\\\\(\\\\s*\\\\1\\\\s*,\\\\s*\\\\d+\\\\s*\\\\);\" +\n  \".*?return\\\\s*\\\\1\\\\[\\\\2\\\\[\\\\d+\\\\]\\\\]\\\\(\\\\2\\\\[\\\\d+\\\\]\\\\)\\\\};\";\n\nconst TCE_SIGN_FUNCTION_ACTION_REGEXP = \"var\\\\s+([$A-Za-z0-9_]+)\\\\s*=\\\\s*\\\\{\\\\s*[$A-Za-z0-9_]+\\\\s*:\\\\s*function\\\\s*\\\\([^)]*\\\\)\\\\s*\\\\{[^{}]*(?:\\\\{[^{}]*}[^{}]*)*}\\\\s*,\\\\s*[$A-Za-z0-9_]+\\\\s*:\\\\s*function\\\\s*\\\\([^)]*\\\\)\\\\s*\\\\{[^{}]*(?:\\\\{[^{}]*}[^{}]*)*}\\\\s*,\\\\s*[$A-Za-z0-9_]+\\\\s*:\\\\s*function\\\\s*\\\\([^)]*\\\\)\\\\s*\\\\{[^{}]*(?:\\\\{[^{}]*}[^{}]*)*}\\\\s*};\";\n\nconst TCE_N_FUNCTION_REGEXP = \"function\\\\s*\\\\((\\\\w+)\\\\)\\\\s*\\\\{var\\\\s*\\\\w+\\\\s*=\\\\s*\\\\1\\\\[\\\\w+\\\\[\\\\d+\\\\]\\\\]\\\\(\\\\w+\\\\[\\\\d+\\\\]\\\\)\\\\s*,\\\\s*\\\\w+\\\\s*=\\\\s*\\\\[.*?\\\\]\\\\;.*?catch\\\\s*\\\\(\\\\s*(\\\\w+)\\\\s*\\\\)\\\\s*\\\\{return\\\\s*\\\\w+\\\\[\\\\d+\\\\]\\\\s*\\\\+\\\\s*\\\\1\\\\}\\\\s*return\\\\s*\\\\w+\\\\[\\\\w+\\\\[\\\\d+\\\\]\\\\]\\\\(\\\\w+\\\\[\\\\d+\\\\]\\\\)\\\\}\\\\s*\\\\;\";\n\nconst PATTERN_PREFIX = \"(?:^|,)\\\\\\\"?(\" + VARIABLE_PART + \")\\\\\\\"?\";\nconst REVERSE_PATTERN = new RegExp(PATTERN_PREFIX + REVERSE_PART, \"m\");\nconst SLICE_PATTERN = new RegExp(PATTERN_PREFIX + SLICE_PART, \"m\");\nconst SPLICE_PATTERN = new RegExp(PATTERN_PREFIX + SPLICE_PART, \"m\");\nconst SWAP_PATTERN = new RegExp(PATTERN_PREFIX + SWAP_PART, \"m\");\n\nconst DECIPHER_ARGUMENT = \"sig\";\nconst N_ARGUMENT = \"ncode\";\nconst DECIPHER_FUNC_NAME = \"DisTubeDecipherFunc\";\nconst N_TRANSFORM_FUNC_NAME = \"DisTubeNTransformFunc\";\n\nconst extractDollarEscapedFirstGroup = (pattern, text) => {\n  const match = text.match(pattern);\n  return match ? match[1].replace(/\\$/g, \"\\\\$\") : null;\n};\n\nconst extractTceFunc = (body) => {\n  try {\n    const tceVariableMatcher = body.match(new RegExp(NEW_TCE_GLOBAL_VARS_REGEXP, 'm'));\n\n    if (!tceVariableMatcher) return;\n\n    const tceVariableMatcherGroups = tceVariableMatcher.groups;\n    if (!tceVariableMatcher.groups) return;\n\n    const code = tceVariableMatcherGroups.code;\n    const varname = tceVariableMatcherGroups.varname;\n\n    return { name: varname, code: code };\n  } catch (e) {\n    console.error(\"Error in extractTceFunc:\", e);\n    return null;\n  }\n}\n\nconst extractDecipherFunc = (body, name, code) => {\n  try {\n    const callerFunc = DECIPHER_FUNC_NAME + \"(\" + DECIPHER_ARGUMENT + \");\";\n    let resultFunc;\n\n    const sigFunctionMatcher = body.match(new RegExp(TCE_SIGN_FUNCTION_REGEXP, 's'));\n    const sigFunctionActionsMatcher = body.match(new RegExp(TCE_SIGN_FUNCTION_ACTION_REGEXP, 's'));\n\n    if (sigFunctionMatcher && sigFunctionActionsMatcher && code) {\n      resultFunc = \"var \" + DECIPHER_FUNC_NAME + \"=\" + sigFunctionMatcher[0] + sigFunctionActionsMatcher[0] + code + \";\\n\";\n      return resultFunc + callerFunc;\n    }\n\n    const helperMatch = body.match(new RegExp(HELPER_REGEXP, \"s\"));\n    if (!helperMatch) return null;\n\n    const helperObject = helperMatch[0];\n    const actionBody = helperMatch[2];\n    const helperName = helperMatch[1];\n\n    const reverseKey = extractDollarEscapedFirstGroup(REVERSE_PATTERN, actionBody);\n    const sliceKey = extractDollarEscapedFirstGroup(SLICE_PATTERN, actionBody);\n    const spliceKey = extractDollarEscapedFirstGroup(SPLICE_PATTERN, actionBody);\n    const swapKey = extractDollarEscapedFirstGroup(SWAP_PATTERN, actionBody);\n\n    const quotedFunctions = [reverseKey, sliceKey, spliceKey, swapKey]\n      .filter(Boolean)\n      .map(key => key.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'));\n\n    if (quotedFunctions.length === 0) return null;\n\n    let funcMatch = body.match(new RegExp(DECIPHER_REGEXP, \"s\"));\n    let isTce = false;\n    let decipherFunc;\n\n    if (funcMatch) {\n      decipherFunc = funcMatch[0];\n    } else {\n\n      const tceFuncMatch = body.match(new RegExp(FUNCTION_TCE_REGEXP, \"s\"));\n      if (!tceFuncMatch) return null;\n\n      decipherFunc = tceFuncMatch[0];\n      isTce = true;\n    }\n\n    let tceVars = \"\";\n    if (isTce) {\n      const tceVarsMatch = body.match(new RegExp(TCE_GLOBAL_VARS_REGEXP, \"m\"));\n      if (tceVarsMatch) {\n        tceVars = tceVarsMatch[1] + \";\\n\";\n      }\n    }\n\n    resultFunc = tceVars + helperObject + \"\\nvar \" + DECIPHER_FUNC_NAME + \"=\" + decipherFunc + \";\\n\";\n    return resultFunc + callerFunc;\n  } catch (e) {\n    console.error(\"Error in extractDecipherFunc:\", e);\n    return null;\n  }\n};\n\nconst extractNTransformFunc = (body, name, code) => {\n  try {\n    const callerFunc = N_TRANSFORM_FUNC_NAME + \"(\" + N_ARGUMENT + \");\";\n    let resultFunc;\n    let nFunction;\n\n    const nFunctionMatcher = body.match(new RegExp(TCE_N_FUNCTION_REGEXP, 's'));\n\n    if (nFunctionMatcher && name && code) {\n      nFunction = nFunctionMatcher[0];\n\n      const tceEscapeName = name.replace(\"$\", \"\\\\$\");\n      const shortCircuitPattern = new RegExp(\n        `;\\\\s*if\\\\s*\\\\(\\\\s*typeof\\\\s+[a-zA-Z0-9_$]+\\\\s*===?\\\\s*(?:\\\"undefined\\\"|'undefined'|${tceEscapeName}\\\\[\\\\d+\\\\])\\\\s*\\\\)\\\\s*return\\\\s+\\\\w+;`\n      );\n\n      const tceShortCircuitMatcher = nFunction.match(shortCircuitPattern);\n\n      if (tceShortCircuitMatcher) {\n        nFunction = nFunction.replaceAll(tceShortCircuitMatcher[0], \";\");\n      }\n\n      resultFunc = \"var \" + N_TRANSFORM_FUNC_NAME + \"=\" + nFunction + code + \";\\n\";\n      return resultFunc + callerFunc;\n    }\n\n    let nMatch = body.match(new RegExp(N_TRANSFORM_REGEXP, \"s\"));\n    let isTce = false;\n\n    if (nMatch) {\n      nFunction = nMatch[0];\n    } else {\n\n      const nTceMatch = body.match(new RegExp(N_TRANSFORM_TCE_REGEXP, \"s\"));\n      if (!nTceMatch) return null;\n\n      nFunction = nTceMatch[0];\n      isTce = true;\n    }\n\n    const paramMatch = nFunction.match(/function\\s*\\(\\s*(\\w+)\\s*\\)/);\n    if (!paramMatch) return null;\n\n    const paramName = paramMatch[1];\n\n    const cleanedFunction = nFunction.replace(\n      new RegExp(`if\\\\s*\\\\(typeof\\\\s*[^\\\\s()]+\\\\s*===?.*?\\\\)return ${paramName}\\\\s*;?`, \"g\"),\n      \"\"\n    );\n\n    let tceVars = \"\";\n    if (isTce) {\n      const tceVarsMatch = body.match(new RegExp(TCE_GLOBAL_VARS_REGEXP, \"m\"));\n      if (tceVarsMatch) {\n        tceVars = tceVarsMatch[1] + \";\\n\";\n      }\n    }\n\n    resultFunc = tceVars + \"var \" + N_TRANSFORM_FUNC_NAME + \"=\" + cleanedFunction + \";\\n\";\n    return resultFunc + callerFunc;\n  } catch (e) {\n    console.error(\"Error in extractNTransformFunc:\", e);\n    return null;\n  }\n};\n\nlet decipherWarning = false;\nlet nTransformWarning = false;\n\nconst getExtractFunction = (extractFunctions, body, name, code, postProcess = null) => {\n  for (const extractFunction of extractFunctions) {\n    try {\n      const func = extractFunction(body, name, code);\n      if (!func) continue;\n      return new vm.Script(postProcess ? postProcess(func) : func);\n    } catch (err) {\n      console.error(\"Failed to extract function:\", err);\n      continue;\n    }\n  }\n  return null;\n};\n\nconst extractDecipher = (body, name, code) => {\n  const decipherFunc = getExtractFunction([extractDecipherFunc], body, name, code);\n  if (!decipherFunc && !decipherWarning) {\n    console.warn(\n      \"\\x1b[33mWARNING:\\x1B[0m Could not parse decipher function.\\n\" +\n      \"Stream URLs will be missing.\\n\" +\n      `Please report this issue by uploading the \"${utils.saveDebugFile(\n        \"player-script.js\",\n        body,\n      )}\" file on https://github.com/distubejs/ytdl-core/issues/144.`\n    );\n    decipherWarning = true;\n  }\n  return decipherFunc;\n};\n\nconst extractNTransform = (body, name, code) => {\n  const nTransformFunc = getExtractFunction([extractNTransformFunc], body, name, code);\n\n  if (!nTransformFunc && !nTransformWarning) {\n    console.warn(\n      \"\\x1b[33mWARNING:\\x1B[0m Could not parse n transform function.\\n\" +\n      `Please report this issue by uploading the \"${utils.saveDebugFile(\n        \"player-script.js\",\n        body,\n      )}\" file on https://github.com/distubejs/ytdl-core/issues/144.`\n    );\n    nTransformWarning = true;\n  }\n\n  return nTransformFunc;\n};\n\nexports.extractFunctions = body => {\n  const { name, code } = extractTceFunc(body);\n  return [extractDecipher(body, name, code), extractNTransform(body, name, code)];\n}\n\nexports.setDownloadURL = (format, decipherScript, nTransformScript) => {\n  if (!format) return;\n\n  const decipher = url => {\n    const args = querystring.parse(url);\n    if (!args.s || !decipherScript) return args.url;\n\n    try {\n      const components = new URL(decodeURIComponent(args.url));\n      const context = {};\n      context[DECIPHER_ARGUMENT] = decodeURIComponent(args.s);\n      const decipheredSig = decipherScript.runInNewContext(context);\n\n      components.searchParams.set(args.sp || \"sig\", decipheredSig);\n      return components.toString();\n    } catch (err) {\n      console.error(\"Error applying decipher:\", err);\n      return args.url;\n    }\n  };\n\n  const nTransform = url => {\n    try {\n      const components = new URL(decodeURIComponent(url));\n      const n = components.searchParams.get(\"n\");\n\n      if (!n || !nTransformScript) return url;\n\n      const context = {};\n      context[N_ARGUMENT] = n;\n      const transformedN = nTransformScript.runInNewContext(context);\n\n      if (transformedN) {\n\n        if (n === transformedN) {\n          console.warn(\"Transformed n parameter is the same as input, n function possibly short-circuited\");\n        } else if (transformedN.startsWith(\"enhanced_except_\") || transformedN.endsWith(\"_w8_\" + n)) {\n          console.warn(\"N function did not complete due to exception\");\n        }\n\n        components.searchParams.set(\"n\", transformedN);\n      } else {\n        console.warn(\"Transformed n parameter is null, n function possibly faulty\");\n      }\n\n      return components.toString();\n    } catch (err) {\n      console.error(\"Error applying n transform:\", err);\n      return url;\n    }\n  };\n\n  const cipher = !format.url;\n  const url = format.url || format.signatureCipher || format.cipher;\n\n  if (!url) return;\n\n  try {\n    format.url = nTransform(cipher ? decipher(url) : url);\n\n    delete format.signatureCipher;\n    delete format.cipher;\n  } catch (err) {\n    console.error(\"Error setting download URL:\", err);\n  }\n};\n\nexports.decipherFormats = async (formats, html5player, options) => {\n  try {\n    const decipheredFormats = {};\n    const [decipherScript, nTransformScript] = await exports.getFunctions(html5player, options);\n\n    formats.forEach(format => {\n      exports.setDownloadURL(format, decipherScript, nTransformScript);\n      if (format.url) {\n        decipheredFormats[format.url] = format;\n      }\n    });\n\n    return decipheredFormats;\n  } catch (err) {\n    console.error(\"Error deciphering formats:\", err);\n    return {};\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGRpc3R1YmUveXRkbC1jb3JlL2xpYi9zaWcuanMiLCJtYXBwaW5ncyI6IkFBQUEsb0JBQW9CLG1CQUFPLENBQUMsZ0NBQWE7QUFDekMsY0FBYyxtQkFBTyxDQUFDLHFFQUFTO0FBQy9CLGNBQWMsbUJBQU8sQ0FBQyxxRUFBUztBQUMvQixXQUFXLG1CQUFPLENBQUMsY0FBSTs7QUFFdkIsYUFBYTs7QUFFYixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxrQ0FBa0M7QUFDN0UsNkNBQTZDLDhCQUE4QjtBQUMzRSw4Q0FBOEMsMEJBQTBCO0FBQ3hFLDRDQUE0QztBQUM1QyxzQkFBc0IscUNBQXFDLG9DQUFvQyxlQUFlOztBQUU5RztBQUNBLHlEQUF5RDtBQUN6RCw2QkFBNkI7QUFDN0IsMkVBQTJFO0FBQzNFO0FBQ0EsTUFBTTs7QUFFTjtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQSw0REFBNEQ7QUFDNUQsd0RBQXdEO0FBQ3hELHNIQUFzSDtBQUN0SCwwREFBMEQ7O0FBRTFEO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0Esd0JBQXdCO0FBQ3hCLGVBQWUsSUFBSSxpQ0FBaUM7QUFDcEQscURBQXFEO0FBQ3JELG9GQUFvRjs7QUFFcEY7QUFDQSxzQ0FBc0M7QUFDdEMsOEVBQThFO0FBQzlFLHNDQUFzQztBQUN0Qyx5RUFBeUU7QUFDekUsa0VBQWtFOztBQUVsRTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7O0FBRWY7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkVBQTZFO0FBQzdFLGdFQUFnRTtBQUNoRSxvRUFBb0U7QUFDcEUsNERBQTREO0FBQzVELDZEQUE2RDs7QUFFN0QsNEVBQTRFLHlEQUF5RCxJQUFJLFFBQVEsSUFBSSxHQUFHLElBQUksS0FBSyw4REFBOEQsSUFBSSxRQUFRLElBQUksR0FBRyxJQUFJLEtBQUssOERBQThELElBQUksUUFBUSxJQUFJLEdBQUcsSUFBSSxLQUFLLE1BQU07O0FBRTNWLDhEQUE4RCxpR0FBaUcsdUNBQXVDLHlDQUF5Qyw2REFBNkQsT0FBTzs7QUFFblQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGFBQWE7QUFDYixJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlFQUF5RTtBQUN6RTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsdUhBQXVIO0FBQ3ZIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdDQUF3Qzs7QUFFeEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7O0FBRUEsaUdBQWlHO0FBQ2pHO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxRUFBcUU7QUFDckU7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLG9GQUFvRixjQUFjLHFDQUFxQztBQUNqSjs7QUFFQTs7QUFFQTtBQUNBLHNFQUFzRTtBQUN0RTs7QUFFQSwrRUFBK0U7QUFDL0U7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxxRUFBcUUsVUFBVSxLQUFLO0FBQ3BGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTs7QUFFQSxzRkFBc0Y7QUFDdEY7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx3QkFBd0I7QUFDeEIsVUFBVSxhQUFhO0FBQ3ZCO0FBQ0E7O0FBRUEsc0JBQXNCO0FBQ3RCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8veXQtZG93bmxvYWRlci8uL25vZGVfbW9kdWxlcy9AZGlzdHViZS95dGRsLWNvcmUvbGliL3NpZy5qcz9kNTBmIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHF1ZXJ5c3RyaW5nID0gcmVxdWlyZShcInF1ZXJ5c3RyaW5nXCIpO1xuY29uc3QgQ2FjaGUgPSByZXF1aXJlKFwiLi9jYWNoZVwiKTtcbmNvbnN0IHV0aWxzID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG5jb25zdCB2bSA9IHJlcXVpcmUoXCJ2bVwiKTtcblxuZXhwb3J0cy5jYWNoZSA9IG5ldyBDYWNoZSgxKTtcblxuZXhwb3J0cy5nZXRGdW5jdGlvbnMgPSAoaHRtbDVwbGF5ZXJmaWxlLCBvcHRpb25zKSA9PlxuICBleHBvcnRzLmNhY2hlLmdldE9yU2V0KGh0bWw1cGxheWVyZmlsZSwgYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IGJvZHkgPSBhd2FpdCB1dGlscy5yZXF1ZXN0KGh0bWw1cGxheWVyZmlsZSwgb3B0aW9ucyk7XG4gICAgY29uc3QgZnVuY3Rpb25zID0gZXhwb3J0cy5leHRyYWN0RnVuY3Rpb25zKGJvZHkpO1xuICAgIGV4cG9ydHMuY2FjaGUuc2V0KGh0bWw1cGxheWVyZmlsZSwgZnVuY3Rpb25zKTtcbiAgICByZXR1cm4gZnVuY3Rpb25zO1xuICB9KTtcblxuY29uc3QgVkFSSUFCTEVfUEFSVCA9IFwiW2EtekEtWl9cXFxcJF1bYS16QS1aXzAtOVxcXFwkXSpcIjtcbmNvbnN0IFZBUklBQkxFX1BBUlRfREVGSU5FID0gXCJcXFxcXFxcIj9cIiArIFZBUklBQkxFX1BBUlQgKyBcIlxcXFxcXFwiP1wiO1xuY29uc3QgQkVGT1JFX0FDQ0VTUyA9IFwiKD86XFxcXFtcXFxcXFxcInxcXFxcLilcIjtcbmNvbnN0IEFGVEVSX0FDQ0VTUyA9IFwiKD86XFxcXFxcXCJcXFxcXXwpXCI7XG5jb25zdCBWQVJJQUJMRV9QQVJUX0FDQ0VTUyA9IEJFRk9SRV9BQ0NFU1MgKyBWQVJJQUJMRV9QQVJUICsgQUZURVJfQUNDRVNTO1xuY29uc3QgUkVWRVJTRV9QQVJUID0gXCI6ZnVuY3Rpb25cXFxcKFxcXFx3XFxcXClcXFxceyg/OnJldHVybiApP1xcXFx3XFxcXC5yZXZlcnNlXFxcXChcXFxcKVxcXFx9XCI7XG5jb25zdCBTTElDRV9QQVJUID0gXCI6ZnVuY3Rpb25cXFxcKFxcXFx3LFxcXFx3XFxcXClcXFxce3JldHVybiBcXFxcd1xcXFwuc2xpY2VcXFxcKFxcXFx3XFxcXClcXFxcfVwiO1xuY29uc3QgU1BMSUNFX1BBUlQgPSBcIjpmdW5jdGlvblxcXFwoXFxcXHcsXFxcXHdcXFxcKVxcXFx7XFxcXHdcXFxcLnNwbGljZVxcXFwoMCxcXFxcd1xcXFwpXFxcXH1cIjtcbmNvbnN0IFNXQVBfUEFSVCA9IFwiOmZ1bmN0aW9uXFxcXChcXFxcdyxcXFxcd1xcXFwpXFxcXHtcIiArXG4gIFwidmFyIFxcXFx3PVxcXFx3XFxcXFswXFxcXF07XFxcXHdcXFxcWzBcXFxcXT1cXFxcd1xcXFxbXFxcXHclXFxcXHdcXFxcLmxlbmd0aFxcXFxdO1xcXFx3XFxcXFtcXFxcdyg/OiVcXFxcdy5sZW5ndGh8KVxcXFxdPVxcXFx3KD86O3JldHVybiBcXFxcdyk/XFxcXH1cIjtcblxuY29uc3QgREVDSVBIRVJfUkVHRVhQID1cbiAgXCJmdW5jdGlvbig/OiBcIiArIFZBUklBQkxFX1BBUlQgKyBcIik/XFxcXCgoW2EtekEtWl0pXFxcXClcXFxce1wiICtcbiAgXCJcXFxcMT1cXFxcMVxcXFwuc3BsaXRcXFxcKFxcXCJcXFwiXFxcXCk7XFxcXHMqXCIgK1xuICBcIigoPzooPzpcXFxcMT0pP1wiICsgVkFSSUFCTEVfUEFSVCArIFZBUklBQkxFX1BBUlRfQUNDRVNTICsgXCJcXFxcKFxcXFwxLFxcXFxkK1xcXFwpOykrKVwiICtcbiAgXCJyZXR1cm4gXFxcXDFcXFxcLmpvaW5cXFxcKFxcXCJcXFwiXFxcXClcIiArXG4gIFwiXFxcXH1cIjtcblxuY29uc3QgSEVMUEVSX1JFR0VYUCA9XG4gIFwidmFyIChcIiArIFZBUklBQkxFX1BBUlQgKyBcIik9XFxcXHsoKD86KD86XCIgK1xuICBWQVJJQUJMRV9QQVJUX0RFRklORSArIFJFVkVSU0VfUEFSVCArIFwifFwiICtcbiAgVkFSSUFCTEVfUEFSVF9ERUZJTkUgKyBTTElDRV9QQVJUICsgXCJ8XCIgK1xuICBWQVJJQUJMRV9QQVJUX0RFRklORSArIFNQTElDRV9QQVJUICsgXCJ8XCIgK1xuICBWQVJJQUJMRV9QQVJUX0RFRklORSArIFNXQVBfUEFSVCArXG4gIFwiKSw/XFxcXG4/KSspXFxcXH07XCI7XG5cbmNvbnN0IEZVTkNUSU9OX1RDRV9SRUdFWFAgPVxuICBcImZ1bmN0aW9uKD86XFxcXHMrW2EtekEtWl9cXFxcJF1bYS16QS1aMC05X1xcXFwkXSopP1xcXFwoXFxcXHdcXFxcKVxcXFx7XCIgK1xuICBcIlxcXFx3PVxcXFx3XFxcXC5zcGxpdFxcXFwoKD86XFxcIlxcXCJ8W2EtekEtWjAtOV8kXSpcXFxcW1xcXFxkK10pXFxcXCk7XCIgK1xuICBcIlxcXFxzKigoPzooPzpcXFxcdz0pP1thLXpBLVpfXFxcXCRdW2EtekEtWjAtOV9cXFxcJF0qKD86XFxcXFtcXFxcXFxcInxcXFxcLilbYS16QS1aX1xcXFwkXVthLXpBLVowLTlfXFxcXCRdKig/OlxcXFxcXFwiXFxcXF18KVxcXFwoXFxcXHcsXFxcXGQrXFxcXCk7KSspXCIgK1xuICBcInJldHVybiBcXFxcd1xcXFwuam9pblxcXFwoKD86XFxcIlxcXCJ8W2EtekEtWjAtOV8kXSpcXFxcW1xcXFxkK10pXFxcXCl9XCI7XG5cbmNvbnN0IE5fVFJBTlNGT1JNX1JFR0VYUCA9XG4gIFwiZnVuY3Rpb25cXFxcKFxcXFxzKihcXFxcdyspXFxcXHMqXFxcXClcXFxccypcXFxce1wiICtcbiAgXCJ2YXJcXFxccyooXFxcXHcrKT0oPzpcXFxcMVxcXFwuc3BsaXRcXFxcKC4qP1xcXFwpfFN0cmluZ1xcXFwucHJvdG90eXBlXFxcXC5zcGxpdFxcXFwuY2FsbFxcXFwoXFxcXDEsLio/XFxcXCkpLFwiICtcbiAgXCJcXFxccyooXFxcXHcrKT0oXFxcXFsuKj9dKTtcXFxccypcXFxcM1xcXFxbXFxcXGQrXVwiICtcbiAgXCIoLio/dHJ5KShcXFxcey4qP30pY2F0Y2hcXFxcKFxcXFxzKihcXFxcdyspXFxcXHMqXFxcXClcXFxccypcXFxce1wiICtcbiAgJ1xcXFxzKnJldHVyblwiW1xcXFx3LV0rKFtBLXowLTktXSspXCJcXFxccypcXFxcK1xcXFxzKlxcXFwxXFxcXHMqfScgK1xuICAnXFxcXHMqcmV0dXJuXFxcXHMqKFxcXFwyXFxcXC5qb2luXFxcXChcIlwiXFxcXCl8QXJyYXlcXFxcLnByb3RvdHlwZVxcXFwuam9pblxcXFwuY2FsbFxcXFwoXFxcXDIsLio/XFxcXCkpfTsnO1xuXG5jb25zdCBOX1RSQU5TRk9STV9UQ0VfUkVHRVhQID1cbiAgXCJmdW5jdGlvblxcXFwoXFxcXHMqKFxcXFx3KylcXFxccypcXFxcKVxcXFxzKlxcXFx7XCIgK1xuICBcIlxcXFxzKnZhclxcXFxzKihcXFxcdyspPVxcXFwxXFxcXC5zcGxpdFxcXFwoXFxcXDFcXFxcLnNsaWNlXFxcXCgwLDBcXFxcKVxcXFwpLFxcXFxzKihcXFxcdyspPVxcXFxbLio/XTtcIiArXG4gIFwiLio/Y2F0Y2hcXFxcKFxcXFxzKihcXFxcdyspXFxcXHMqXFxcXClcXFxccypcXFxce1wiICtcbiAgXCJcXFxccypyZXR1cm4oPzpcXFwiW15cXFwiXStcXFwifFxcXFxzKlthLXpBLVpfMC05JF0qXFxcXFtcXFxcZCtdKVxcXFxzKlxcXFwrXFxcXHMqXFxcXDFcXFxccyp9XCIgK1xuICBcIlxcXFxzKnJldHVyblxcXFxzKlxcXFwyXFxcXC5qb2luXFxcXCgoPzpcXFwiXFxcInxbYS16QS1aXzAtOSRdKlxcXFxbXFxcXGQrXSlcXFxcKX07XCI7XG5cbmNvbnN0IFRDRV9HTE9CQUxfVkFSU19SRUdFWFAgPVxuICBcIig/Ol58WzssXSlcXFxccyoodmFyXFxcXHMrKFtcXFxcdyRdKylcXFxccyo9XFxcXHMqXCIgK1xuICBcIig/OlwiICtcbiAgXCIoW1xcXCInXSkoPzpcXFxcXFxcXC58W15cXFxcXFxcXF0pKj9cXFxcM1wiICtcbiAgXCJcXFxccypcXFxcLlxcXFxzKnNwbGl0XFxcXCgoXCIgK1xuICBcIihbXFxcIiddKSg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcXSkqP1xcXFw1XCIgK1xuICBcIlxcXFwpKVwiICtcbiAgXCJ8XCIgK1xuICBcIlxcXFxbXFxcXHMqKD86KFtcXFwiJ10pKD86XFxcXFxcXFwufFteXFxcXFxcXFxdKSo/XFxcXDZcXFxccyosP1xcXFxzKikrXFxcXF1cIiArXG4gIFwiKSkoPz1cXFxccypbLDtdKVwiO1xuXG5jb25zdCBORVdfVENFX0dMT0JBTF9WQVJTX1JFR0VYUCA9XG4gIFwiKCd1c2VcXFxccypzdHJpY3QnOyk/XCIgK1xuICBcIig/PGNvZGU+dmFyXFxcXHMqXCIgK1xuICBcIig/PHZhcm5hbWU+W2EtekEtWjAtOV8kXSspXFxcXHMqPVxcXFxzKlwiICtcbiAgXCIoPzx2YWx1ZT5cIiArXG4gIFwiKD86XFxcIlteXFxcIlxcXFxcXFxcXSooPzpcXFxcXFxcXC5bXlxcXCJcXFxcXFxcXF0qKSpcXFwifCdbXidcXFxcXFxcXF0qKD86XFxcXFxcXFwuW14nXFxcXFxcXFxdKikqJylcIiArXG4gIFwiXFxcXC5zcGxpdFxcXFwoXCIgK1xuICBcIig/OlxcXCJbXlxcXCJcXFxcXFxcXF0qKD86XFxcXFxcXFwuW15cXFwiXFxcXFxcXFxdKikqXFxcInwnW14nXFxcXFxcXFxdKig/OlxcXFxcXFxcLlteJ1xcXFxcXFxcXSopKicpXCIgK1xuICBcIlxcXFwpXCIgK1xuICBcInxcIiArXG4gIFwiXFxcXFtcIiArXG4gIFwiKD86KD86XFxcIlteXFxcIlxcXFxcXFxcXSooPzpcXFxcXFxcXC5bXlxcXCJcXFxcXFxcXF0qKSpcXFwifCdbXidcXFxcXFxcXF0qKD86XFxcXFxcXFwuW14nXFxcXFxcXFxdKikqJylcIiArXG4gIFwiXFxcXHMqLD9cXFxccyopKlwiICtcbiAgXCJcXFxcXVwiICtcbiAgXCJ8XCIgK1xuICBcIlxcXCJbXlxcXCJdKlxcXCJcXFxcLnNwbGl0XFxcXChcXFwiW15cXFwiXSpcXFwiXFxcXClcIiArXG4gIFwiKVwiICtcbiAgXCIpXCI7XG5cbmNvbnN0IFRDRV9TSUdOX0ZVTkNUSU9OX1JFR0VYUCA9IFwiZnVuY3Rpb25cXFxcKFxcXFxzKihbYS16QS1aMC05JF0pXFxcXHMqXFxcXClcXFxccypcXFxce1wiICtcbiAgXCJcXFxccypcXFxcMVxcXFxzKj1cXFxccypcXFxcMVxcXFxbKFxcXFx3KylcXFxcW1xcXFxkK1xcXFxdXFxcXF1cXFxcKFxcXFwyXFxcXFtcXFxcZCtcXFxcXVxcXFwpO1wiICtcbiAgXCIoW2EtekEtWjAtOSRdKylcXFxcW1xcXFwyXFxcXFtcXFxcZCtcXFxcXVxcXFxdXFxcXChcXFxccypcXFxcMVxcXFxzKixcXFxccypcXFxcZCtcXFxccypcXFxcKTtcIiArXG4gIFwiXFxcXHMqXFxcXDNcXFxcW1xcXFwyXFxcXFtcXFxcZCtcXFxcXVxcXFxdXFxcXChcXFxccypcXFxcMVxcXFxzKixcXFxccypcXFxcZCtcXFxccypcXFxcKTtcIiArXG4gIFwiLio/cmV0dXJuXFxcXHMqXFxcXDFcXFxcW1xcXFwyXFxcXFtcXFxcZCtcXFxcXVxcXFxdXFxcXChcXFxcMlxcXFxbXFxcXGQrXFxcXF1cXFxcKVxcXFx9O1wiO1xuXG5jb25zdCBUQ0VfU0lHTl9GVU5DVElPTl9BQ1RJT05fUkVHRVhQID0gXCJ2YXJcXFxccysoWyRBLVphLXowLTlfXSspXFxcXHMqPVxcXFxzKlxcXFx7XFxcXHMqWyRBLVphLXowLTlfXStcXFxccyo6XFxcXHMqZnVuY3Rpb25cXFxccypcXFxcKFteKV0qXFxcXClcXFxccypcXFxce1tee31dKig/OlxcXFx7W157fV0qfVtee31dKikqfVxcXFxzKixcXFxccypbJEEtWmEtejAtOV9dK1xcXFxzKjpcXFxccypmdW5jdGlvblxcXFxzKlxcXFwoW14pXSpcXFxcKVxcXFxzKlxcXFx7W157fV0qKD86XFxcXHtbXnt9XSp9W157fV0qKSp9XFxcXHMqLFxcXFxzKlskQS1aYS16MC05X10rXFxcXHMqOlxcXFxzKmZ1bmN0aW9uXFxcXHMqXFxcXChbXildKlxcXFwpXFxcXHMqXFxcXHtbXnt9XSooPzpcXFxce1tee31dKn1bXnt9XSopKn1cXFxccyp9O1wiO1xuXG5jb25zdCBUQ0VfTl9GVU5DVElPTl9SRUdFWFAgPSBcImZ1bmN0aW9uXFxcXHMqXFxcXCgoXFxcXHcrKVxcXFwpXFxcXHMqXFxcXHt2YXJcXFxccypcXFxcdytcXFxccyo9XFxcXHMqXFxcXDFcXFxcW1xcXFx3K1xcXFxbXFxcXGQrXFxcXF1cXFxcXVxcXFwoXFxcXHcrXFxcXFtcXFxcZCtcXFxcXVxcXFwpXFxcXHMqLFxcXFxzKlxcXFx3K1xcXFxzKj1cXFxccypcXFxcWy4qP1xcXFxdXFxcXDsuKj9jYXRjaFxcXFxzKlxcXFwoXFxcXHMqKFxcXFx3KylcXFxccypcXFxcKVxcXFxzKlxcXFx7cmV0dXJuXFxcXHMqXFxcXHcrXFxcXFtcXFxcZCtcXFxcXVxcXFxzKlxcXFwrXFxcXHMqXFxcXDFcXFxcfVxcXFxzKnJldHVyblxcXFxzKlxcXFx3K1xcXFxbXFxcXHcrXFxcXFtcXFxcZCtcXFxcXVxcXFxdXFxcXChcXFxcdytcXFxcW1xcXFxkK1xcXFxdXFxcXClcXFxcfVxcXFxzKlxcXFw7XCI7XG5cbmNvbnN0IFBBVFRFUk5fUFJFRklYID0gXCIoPzpefCwpXFxcXFxcXCI/KFwiICsgVkFSSUFCTEVfUEFSVCArIFwiKVxcXFxcXFwiP1wiO1xuY29uc3QgUkVWRVJTRV9QQVRURVJOID0gbmV3IFJlZ0V4cChQQVRURVJOX1BSRUZJWCArIFJFVkVSU0VfUEFSVCwgXCJtXCIpO1xuY29uc3QgU0xJQ0VfUEFUVEVSTiA9IG5ldyBSZWdFeHAoUEFUVEVSTl9QUkVGSVggKyBTTElDRV9QQVJULCBcIm1cIik7XG5jb25zdCBTUExJQ0VfUEFUVEVSTiA9IG5ldyBSZWdFeHAoUEFUVEVSTl9QUkVGSVggKyBTUExJQ0VfUEFSVCwgXCJtXCIpO1xuY29uc3QgU1dBUF9QQVRURVJOID0gbmV3IFJlZ0V4cChQQVRURVJOX1BSRUZJWCArIFNXQVBfUEFSVCwgXCJtXCIpO1xuXG5jb25zdCBERUNJUEhFUl9BUkdVTUVOVCA9IFwic2lnXCI7XG5jb25zdCBOX0FSR1VNRU5UID0gXCJuY29kZVwiO1xuY29uc3QgREVDSVBIRVJfRlVOQ19OQU1FID0gXCJEaXNUdWJlRGVjaXBoZXJGdW5jXCI7XG5jb25zdCBOX1RSQU5TRk9STV9GVU5DX05BTUUgPSBcIkRpc1R1YmVOVHJhbnNmb3JtRnVuY1wiO1xuXG5jb25zdCBleHRyYWN0RG9sbGFyRXNjYXBlZEZpcnN0R3JvdXAgPSAocGF0dGVybiwgdGV4dCkgPT4ge1xuICBjb25zdCBtYXRjaCA9IHRleHQubWF0Y2gocGF0dGVybik7XG4gIHJldHVybiBtYXRjaCA/IG1hdGNoWzFdLnJlcGxhY2UoL1xcJC9nLCBcIlxcXFwkXCIpIDogbnVsbDtcbn07XG5cbmNvbnN0IGV4dHJhY3RUY2VGdW5jID0gKGJvZHkpID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCB0Y2VWYXJpYWJsZU1hdGNoZXIgPSBib2R5Lm1hdGNoKG5ldyBSZWdFeHAoTkVXX1RDRV9HTE9CQUxfVkFSU19SRUdFWFAsICdtJykpO1xuXG4gICAgaWYgKCF0Y2VWYXJpYWJsZU1hdGNoZXIpIHJldHVybjtcblxuICAgIGNvbnN0IHRjZVZhcmlhYmxlTWF0Y2hlckdyb3VwcyA9IHRjZVZhcmlhYmxlTWF0Y2hlci5ncm91cHM7XG4gICAgaWYgKCF0Y2VWYXJpYWJsZU1hdGNoZXIuZ3JvdXBzKSByZXR1cm47XG5cbiAgICBjb25zdCBjb2RlID0gdGNlVmFyaWFibGVNYXRjaGVyR3JvdXBzLmNvZGU7XG4gICAgY29uc3QgdmFybmFtZSA9IHRjZVZhcmlhYmxlTWF0Y2hlckdyb3Vwcy52YXJuYW1lO1xuXG4gICAgcmV0dXJuIHsgbmFtZTogdmFybmFtZSwgY29kZTogY29kZSB9O1xuICB9IGNhdGNoIChlKSB7XG4gICAgY29uc29sZS5lcnJvcihcIkVycm9yIGluIGV4dHJhY3RUY2VGdW5jOlwiLCBlKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5jb25zdCBleHRyYWN0RGVjaXBoZXJGdW5jID0gKGJvZHksIG5hbWUsIGNvZGUpID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCBjYWxsZXJGdW5jID0gREVDSVBIRVJfRlVOQ19OQU1FICsgXCIoXCIgKyBERUNJUEhFUl9BUkdVTUVOVCArIFwiKTtcIjtcbiAgICBsZXQgcmVzdWx0RnVuYztcblxuICAgIGNvbnN0IHNpZ0Z1bmN0aW9uTWF0Y2hlciA9IGJvZHkubWF0Y2gobmV3IFJlZ0V4cChUQ0VfU0lHTl9GVU5DVElPTl9SRUdFWFAsICdzJykpO1xuICAgIGNvbnN0IHNpZ0Z1bmN0aW9uQWN0aW9uc01hdGNoZXIgPSBib2R5Lm1hdGNoKG5ldyBSZWdFeHAoVENFX1NJR05fRlVOQ1RJT05fQUNUSU9OX1JFR0VYUCwgJ3MnKSk7XG5cbiAgICBpZiAoc2lnRnVuY3Rpb25NYXRjaGVyICYmIHNpZ0Z1bmN0aW9uQWN0aW9uc01hdGNoZXIgJiYgY29kZSkge1xuICAgICAgcmVzdWx0RnVuYyA9IFwidmFyIFwiICsgREVDSVBIRVJfRlVOQ19OQU1FICsgXCI9XCIgKyBzaWdGdW5jdGlvbk1hdGNoZXJbMF0gKyBzaWdGdW5jdGlvbkFjdGlvbnNNYXRjaGVyWzBdICsgY29kZSArIFwiO1xcblwiO1xuICAgICAgcmV0dXJuIHJlc3VsdEZ1bmMgKyBjYWxsZXJGdW5jO1xuICAgIH1cblxuICAgIGNvbnN0IGhlbHBlck1hdGNoID0gYm9keS5tYXRjaChuZXcgUmVnRXhwKEhFTFBFUl9SRUdFWFAsIFwic1wiKSk7XG4gICAgaWYgKCFoZWxwZXJNYXRjaCkgcmV0dXJuIG51bGw7XG5cbiAgICBjb25zdCBoZWxwZXJPYmplY3QgPSBoZWxwZXJNYXRjaFswXTtcbiAgICBjb25zdCBhY3Rpb25Cb2R5ID0gaGVscGVyTWF0Y2hbMl07XG4gICAgY29uc3QgaGVscGVyTmFtZSA9IGhlbHBlck1hdGNoWzFdO1xuXG4gICAgY29uc3QgcmV2ZXJzZUtleSA9IGV4dHJhY3REb2xsYXJFc2NhcGVkRmlyc3RHcm91cChSRVZFUlNFX1BBVFRFUk4sIGFjdGlvbkJvZHkpO1xuICAgIGNvbnN0IHNsaWNlS2V5ID0gZXh0cmFjdERvbGxhckVzY2FwZWRGaXJzdEdyb3VwKFNMSUNFX1BBVFRFUk4sIGFjdGlvbkJvZHkpO1xuICAgIGNvbnN0IHNwbGljZUtleSA9IGV4dHJhY3REb2xsYXJFc2NhcGVkRmlyc3RHcm91cChTUExJQ0VfUEFUVEVSTiwgYWN0aW9uQm9keSk7XG4gICAgY29uc3Qgc3dhcEtleSA9IGV4dHJhY3REb2xsYXJFc2NhcGVkRmlyc3RHcm91cChTV0FQX1BBVFRFUk4sIGFjdGlvbkJvZHkpO1xuXG4gICAgY29uc3QgcXVvdGVkRnVuY3Rpb25zID0gW3JldmVyc2VLZXksIHNsaWNlS2V5LCBzcGxpY2VLZXksIHN3YXBLZXldXG4gICAgICAuZmlsdGVyKEJvb2xlYW4pXG4gICAgICAubWFwKGtleSA9PiBrZXkucmVwbGFjZSgvWy4qKz9eJHt9KCl8W1xcXVxcXFxdL2csICdcXFxcJCYnKSk7XG5cbiAgICBpZiAocXVvdGVkRnVuY3Rpb25zLmxlbmd0aCA9PT0gMCkgcmV0dXJuIG51bGw7XG5cbiAgICBsZXQgZnVuY01hdGNoID0gYm9keS5tYXRjaChuZXcgUmVnRXhwKERFQ0lQSEVSX1JFR0VYUCwgXCJzXCIpKTtcbiAgICBsZXQgaXNUY2UgPSBmYWxzZTtcbiAgICBsZXQgZGVjaXBoZXJGdW5jO1xuXG4gICAgaWYgKGZ1bmNNYXRjaCkge1xuICAgICAgZGVjaXBoZXJGdW5jID0gZnVuY01hdGNoWzBdO1xuICAgIH0gZWxzZSB7XG5cbiAgICAgIGNvbnN0IHRjZUZ1bmNNYXRjaCA9IGJvZHkubWF0Y2gobmV3IFJlZ0V4cChGVU5DVElPTl9UQ0VfUkVHRVhQLCBcInNcIikpO1xuICAgICAgaWYgKCF0Y2VGdW5jTWF0Y2gpIHJldHVybiBudWxsO1xuXG4gICAgICBkZWNpcGhlckZ1bmMgPSB0Y2VGdW5jTWF0Y2hbMF07XG4gICAgICBpc1RjZSA9IHRydWU7XG4gICAgfVxuXG4gICAgbGV0IHRjZVZhcnMgPSBcIlwiO1xuICAgIGlmIChpc1RjZSkge1xuICAgICAgY29uc3QgdGNlVmFyc01hdGNoID0gYm9keS5tYXRjaChuZXcgUmVnRXhwKFRDRV9HTE9CQUxfVkFSU19SRUdFWFAsIFwibVwiKSk7XG4gICAgICBpZiAodGNlVmFyc01hdGNoKSB7XG4gICAgICAgIHRjZVZhcnMgPSB0Y2VWYXJzTWF0Y2hbMV0gKyBcIjtcXG5cIjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXN1bHRGdW5jID0gdGNlVmFycyArIGhlbHBlck9iamVjdCArIFwiXFxudmFyIFwiICsgREVDSVBIRVJfRlVOQ19OQU1FICsgXCI9XCIgKyBkZWNpcGhlckZ1bmMgKyBcIjtcXG5cIjtcbiAgICByZXR1cm4gcmVzdWx0RnVuYyArIGNhbGxlckZ1bmM7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgaW4gZXh0cmFjdERlY2lwaGVyRnVuYzpcIiwgZSk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn07XG5cbmNvbnN0IGV4dHJhY3ROVHJhbnNmb3JtRnVuYyA9IChib2R5LCBuYW1lLCBjb2RlKSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgY2FsbGVyRnVuYyA9IE5fVFJBTlNGT1JNX0ZVTkNfTkFNRSArIFwiKFwiICsgTl9BUkdVTUVOVCArIFwiKTtcIjtcbiAgICBsZXQgcmVzdWx0RnVuYztcbiAgICBsZXQgbkZ1bmN0aW9uO1xuXG4gICAgY29uc3QgbkZ1bmN0aW9uTWF0Y2hlciA9IGJvZHkubWF0Y2gobmV3IFJlZ0V4cChUQ0VfTl9GVU5DVElPTl9SRUdFWFAsICdzJykpO1xuXG4gICAgaWYgKG5GdW5jdGlvbk1hdGNoZXIgJiYgbmFtZSAmJiBjb2RlKSB7XG4gICAgICBuRnVuY3Rpb24gPSBuRnVuY3Rpb25NYXRjaGVyWzBdO1xuXG4gICAgICBjb25zdCB0Y2VFc2NhcGVOYW1lID0gbmFtZS5yZXBsYWNlKFwiJFwiLCBcIlxcXFwkXCIpO1xuICAgICAgY29uc3Qgc2hvcnRDaXJjdWl0UGF0dGVybiA9IG5ldyBSZWdFeHAoXG4gICAgICAgIGA7XFxcXHMqaWZcXFxccypcXFxcKFxcXFxzKnR5cGVvZlxcXFxzK1thLXpBLVowLTlfJF0rXFxcXHMqPT09P1xcXFxzKig/OlxcXCJ1bmRlZmluZWRcXFwifCd1bmRlZmluZWQnfCR7dGNlRXNjYXBlTmFtZX1cXFxcW1xcXFxkK1xcXFxdKVxcXFxzKlxcXFwpXFxcXHMqcmV0dXJuXFxcXHMrXFxcXHcrO2BcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IHRjZVNob3J0Q2lyY3VpdE1hdGNoZXIgPSBuRnVuY3Rpb24ubWF0Y2goc2hvcnRDaXJjdWl0UGF0dGVybik7XG5cbiAgICAgIGlmICh0Y2VTaG9ydENpcmN1aXRNYXRjaGVyKSB7XG4gICAgICAgIG5GdW5jdGlvbiA9IG5GdW5jdGlvbi5yZXBsYWNlQWxsKHRjZVNob3J0Q2lyY3VpdE1hdGNoZXJbMF0sIFwiO1wiKTtcbiAgICAgIH1cblxuICAgICAgcmVzdWx0RnVuYyA9IFwidmFyIFwiICsgTl9UUkFOU0ZPUk1fRlVOQ19OQU1FICsgXCI9XCIgKyBuRnVuY3Rpb24gKyBjb2RlICsgXCI7XFxuXCI7XG4gICAgICByZXR1cm4gcmVzdWx0RnVuYyArIGNhbGxlckZ1bmM7XG4gICAgfVxuXG4gICAgbGV0IG5NYXRjaCA9IGJvZHkubWF0Y2gobmV3IFJlZ0V4cChOX1RSQU5TRk9STV9SRUdFWFAsIFwic1wiKSk7XG4gICAgbGV0IGlzVGNlID0gZmFsc2U7XG5cbiAgICBpZiAobk1hdGNoKSB7XG4gICAgICBuRnVuY3Rpb24gPSBuTWF0Y2hbMF07XG4gICAgfSBlbHNlIHtcblxuICAgICAgY29uc3QgblRjZU1hdGNoID0gYm9keS5tYXRjaChuZXcgUmVnRXhwKE5fVFJBTlNGT1JNX1RDRV9SRUdFWFAsIFwic1wiKSk7XG4gICAgICBpZiAoIW5UY2VNYXRjaCkgcmV0dXJuIG51bGw7XG5cbiAgICAgIG5GdW5jdGlvbiA9IG5UY2VNYXRjaFswXTtcbiAgICAgIGlzVGNlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBjb25zdCBwYXJhbU1hdGNoID0gbkZ1bmN0aW9uLm1hdGNoKC9mdW5jdGlvblxccypcXChcXHMqKFxcdyspXFxzKlxcKS8pO1xuICAgIGlmICghcGFyYW1NYXRjaCkgcmV0dXJuIG51bGw7XG5cbiAgICBjb25zdCBwYXJhbU5hbWUgPSBwYXJhbU1hdGNoWzFdO1xuXG4gICAgY29uc3QgY2xlYW5lZEZ1bmN0aW9uID0gbkZ1bmN0aW9uLnJlcGxhY2UoXG4gICAgICBuZXcgUmVnRXhwKGBpZlxcXFxzKlxcXFwodHlwZW9mXFxcXHMqW15cXFxccygpXStcXFxccyo9PT0/Lio/XFxcXClyZXR1cm4gJHtwYXJhbU5hbWV9XFxcXHMqOz9gLCBcImdcIiksXG4gICAgICBcIlwiXG4gICAgKTtcblxuICAgIGxldCB0Y2VWYXJzID0gXCJcIjtcbiAgICBpZiAoaXNUY2UpIHtcbiAgICAgIGNvbnN0IHRjZVZhcnNNYXRjaCA9IGJvZHkubWF0Y2gobmV3IFJlZ0V4cChUQ0VfR0xPQkFMX1ZBUlNfUkVHRVhQLCBcIm1cIikpO1xuICAgICAgaWYgKHRjZVZhcnNNYXRjaCkge1xuICAgICAgICB0Y2VWYXJzID0gdGNlVmFyc01hdGNoWzFdICsgXCI7XFxuXCI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmVzdWx0RnVuYyA9IHRjZVZhcnMgKyBcInZhciBcIiArIE5fVFJBTlNGT1JNX0ZVTkNfTkFNRSArIFwiPVwiICsgY2xlYW5lZEZ1bmN0aW9uICsgXCI7XFxuXCI7XG4gICAgcmV0dXJuIHJlc3VsdEZ1bmMgKyBjYWxsZXJGdW5jO1xuICB9IGNhdGNoIChlKSB7XG4gICAgY29uc29sZS5lcnJvcihcIkVycm9yIGluIGV4dHJhY3ROVHJhbnNmb3JtRnVuYzpcIiwgZSk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn07XG5cbmxldCBkZWNpcGhlcldhcm5pbmcgPSBmYWxzZTtcbmxldCBuVHJhbnNmb3JtV2FybmluZyA9IGZhbHNlO1xuXG5jb25zdCBnZXRFeHRyYWN0RnVuY3Rpb24gPSAoZXh0cmFjdEZ1bmN0aW9ucywgYm9keSwgbmFtZSwgY29kZSwgcG9zdFByb2Nlc3MgPSBudWxsKSA9PiB7XG4gIGZvciAoY29uc3QgZXh0cmFjdEZ1bmN0aW9uIG9mIGV4dHJhY3RGdW5jdGlvbnMpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZnVuYyA9IGV4dHJhY3RGdW5jdGlvbihib2R5LCBuYW1lLCBjb2RlKTtcbiAgICAgIGlmICghZnVuYykgY29udGludWU7XG4gICAgICByZXR1cm4gbmV3IHZtLlNjcmlwdChwb3N0UHJvY2VzcyA/IHBvc3RQcm9jZXNzKGZ1bmMpIDogZnVuYyk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIGV4dHJhY3QgZnVuY3Rpb246XCIsIGVycik7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuXG5jb25zdCBleHRyYWN0RGVjaXBoZXIgPSAoYm9keSwgbmFtZSwgY29kZSkgPT4ge1xuICBjb25zdCBkZWNpcGhlckZ1bmMgPSBnZXRFeHRyYWN0RnVuY3Rpb24oW2V4dHJhY3REZWNpcGhlckZ1bmNdLCBib2R5LCBuYW1lLCBjb2RlKTtcbiAgaWYgKCFkZWNpcGhlckZ1bmMgJiYgIWRlY2lwaGVyV2FybmluZykge1xuICAgIGNvbnNvbGUud2FybihcbiAgICAgIFwiXFx4MWJbMzNtV0FSTklORzpcXHgxQlswbSBDb3VsZCBub3QgcGFyc2UgZGVjaXBoZXIgZnVuY3Rpb24uXFxuXCIgK1xuICAgICAgXCJTdHJlYW0gVVJMcyB3aWxsIGJlIG1pc3NpbmcuXFxuXCIgK1xuICAgICAgYFBsZWFzZSByZXBvcnQgdGhpcyBpc3N1ZSBieSB1cGxvYWRpbmcgdGhlIFwiJHt1dGlscy5zYXZlRGVidWdGaWxlKFxuICAgICAgICBcInBsYXllci1zY3JpcHQuanNcIixcbiAgICAgICAgYm9keSxcbiAgICAgICl9XCIgZmlsZSBvbiBodHRwczovL2dpdGh1Yi5jb20vZGlzdHViZWpzL3l0ZGwtY29yZS9pc3N1ZXMvMTQ0LmBcbiAgICApO1xuICAgIGRlY2lwaGVyV2FybmluZyA9IHRydWU7XG4gIH1cbiAgcmV0dXJuIGRlY2lwaGVyRnVuYztcbn07XG5cbmNvbnN0IGV4dHJhY3ROVHJhbnNmb3JtID0gKGJvZHksIG5hbWUsIGNvZGUpID0+IHtcbiAgY29uc3QgblRyYW5zZm9ybUZ1bmMgPSBnZXRFeHRyYWN0RnVuY3Rpb24oW2V4dHJhY3ROVHJhbnNmb3JtRnVuY10sIGJvZHksIG5hbWUsIGNvZGUpO1xuXG4gIGlmICghblRyYW5zZm9ybUZ1bmMgJiYgIW5UcmFuc2Zvcm1XYXJuaW5nKSB7XG4gICAgY29uc29sZS53YXJuKFxuICAgICAgXCJcXHgxYlszM21XQVJOSU5HOlxceDFCWzBtIENvdWxkIG5vdCBwYXJzZSBuIHRyYW5zZm9ybSBmdW5jdGlvbi5cXG5cIiArXG4gICAgICBgUGxlYXNlIHJlcG9ydCB0aGlzIGlzc3VlIGJ5IHVwbG9hZGluZyB0aGUgXCIke3V0aWxzLnNhdmVEZWJ1Z0ZpbGUoXG4gICAgICAgIFwicGxheWVyLXNjcmlwdC5qc1wiLFxuICAgICAgICBib2R5LFxuICAgICAgKX1cIiBmaWxlIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9kaXN0dWJlanMveXRkbC1jb3JlL2lzc3Vlcy8xNDQuYFxuICAgICk7XG4gICAgblRyYW5zZm9ybVdhcm5pbmcgPSB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIG5UcmFuc2Zvcm1GdW5jO1xufTtcblxuZXhwb3J0cy5leHRyYWN0RnVuY3Rpb25zID0gYm9keSA9PiB7XG4gIGNvbnN0IHsgbmFtZSwgY29kZSB9ID0gZXh0cmFjdFRjZUZ1bmMoYm9keSk7XG4gIHJldHVybiBbZXh0cmFjdERlY2lwaGVyKGJvZHksIG5hbWUsIGNvZGUpLCBleHRyYWN0TlRyYW5zZm9ybShib2R5LCBuYW1lLCBjb2RlKV07XG59XG5cbmV4cG9ydHMuc2V0RG93bmxvYWRVUkwgPSAoZm9ybWF0LCBkZWNpcGhlclNjcmlwdCwgblRyYW5zZm9ybVNjcmlwdCkgPT4ge1xuICBpZiAoIWZvcm1hdCkgcmV0dXJuO1xuXG4gIGNvbnN0IGRlY2lwaGVyID0gdXJsID0+IHtcbiAgICBjb25zdCBhcmdzID0gcXVlcnlzdHJpbmcucGFyc2UodXJsKTtcbiAgICBpZiAoIWFyZ3MucyB8fCAhZGVjaXBoZXJTY3JpcHQpIHJldHVybiBhcmdzLnVybDtcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCBjb21wb25lbnRzID0gbmV3IFVSTChkZWNvZGVVUklDb21wb25lbnQoYXJncy51cmwpKTtcbiAgICAgIGNvbnN0IGNvbnRleHQgPSB7fTtcbiAgICAgIGNvbnRleHRbREVDSVBIRVJfQVJHVU1FTlRdID0gZGVjb2RlVVJJQ29tcG9uZW50KGFyZ3Mucyk7XG4gICAgICBjb25zdCBkZWNpcGhlcmVkU2lnID0gZGVjaXBoZXJTY3JpcHQucnVuSW5OZXdDb250ZXh0KGNvbnRleHQpO1xuXG4gICAgICBjb21wb25lbnRzLnNlYXJjaFBhcmFtcy5zZXQoYXJncy5zcCB8fCBcInNpZ1wiLCBkZWNpcGhlcmVkU2lnKTtcbiAgICAgIHJldHVybiBjb21wb25lbnRzLnRvU3RyaW5nKCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgYXBwbHlpbmcgZGVjaXBoZXI6XCIsIGVycik7XG4gICAgICByZXR1cm4gYXJncy51cmw7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IG5UcmFuc2Zvcm0gPSB1cmwgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBjb21wb25lbnRzID0gbmV3IFVSTChkZWNvZGVVUklDb21wb25lbnQodXJsKSk7XG4gICAgICBjb25zdCBuID0gY29tcG9uZW50cy5zZWFyY2hQYXJhbXMuZ2V0KFwiblwiKTtcblxuICAgICAgaWYgKCFuIHx8ICFuVHJhbnNmb3JtU2NyaXB0KSByZXR1cm4gdXJsO1xuXG4gICAgICBjb25zdCBjb250ZXh0ID0ge307XG4gICAgICBjb250ZXh0W05fQVJHVU1FTlRdID0gbjtcbiAgICAgIGNvbnN0IHRyYW5zZm9ybWVkTiA9IG5UcmFuc2Zvcm1TY3JpcHQucnVuSW5OZXdDb250ZXh0KGNvbnRleHQpO1xuXG4gICAgICBpZiAodHJhbnNmb3JtZWROKSB7XG5cbiAgICAgICAgaWYgKG4gPT09IHRyYW5zZm9ybWVkTikge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcIlRyYW5zZm9ybWVkIG4gcGFyYW1ldGVyIGlzIHRoZSBzYW1lIGFzIGlucHV0LCBuIGZ1bmN0aW9uIHBvc3NpYmx5IHNob3J0LWNpcmN1aXRlZFwiKTtcbiAgICAgICAgfSBlbHNlIGlmICh0cmFuc2Zvcm1lZE4uc3RhcnRzV2l0aChcImVuaGFuY2VkX2V4Y2VwdF9cIikgfHwgdHJhbnNmb3JtZWROLmVuZHNXaXRoKFwiX3c4X1wiICsgbikpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXCJOIGZ1bmN0aW9uIGRpZCBub3QgY29tcGxldGUgZHVlIHRvIGV4Y2VwdGlvblwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbXBvbmVudHMuc2VhcmNoUGFyYW1zLnNldChcIm5cIiwgdHJhbnNmb3JtZWROKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIlRyYW5zZm9ybWVkIG4gcGFyYW1ldGVyIGlzIG51bGwsIG4gZnVuY3Rpb24gcG9zc2libHkgZmF1bHR5XCIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29tcG9uZW50cy50b1N0cmluZygpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGFwcGx5aW5nIG4gdHJhbnNmb3JtOlwiLCBlcnIpO1xuICAgICAgcmV0dXJuIHVybDtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgY2lwaGVyID0gIWZvcm1hdC51cmw7XG4gIGNvbnN0IHVybCA9IGZvcm1hdC51cmwgfHwgZm9ybWF0LnNpZ25hdHVyZUNpcGhlciB8fCBmb3JtYXQuY2lwaGVyO1xuXG4gIGlmICghdXJsKSByZXR1cm47XG5cbiAgdHJ5IHtcbiAgICBmb3JtYXQudXJsID0gblRyYW5zZm9ybShjaXBoZXIgPyBkZWNpcGhlcih1cmwpIDogdXJsKTtcblxuICAgIGRlbGV0ZSBmb3JtYXQuc2lnbmF0dXJlQ2lwaGVyO1xuICAgIGRlbGV0ZSBmb3JtYXQuY2lwaGVyO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiRXJyb3Igc2V0dGluZyBkb3dubG9hZCBVUkw6XCIsIGVycik7XG4gIH1cbn07XG5cbmV4cG9ydHMuZGVjaXBoZXJGb3JtYXRzID0gYXN5bmMgKGZvcm1hdHMsIGh0bWw1cGxheWVyLCBvcHRpb25zKSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgZGVjaXBoZXJlZEZvcm1hdHMgPSB7fTtcbiAgICBjb25zdCBbZGVjaXBoZXJTY3JpcHQsIG5UcmFuc2Zvcm1TY3JpcHRdID0gYXdhaXQgZXhwb3J0cy5nZXRGdW5jdGlvbnMoaHRtbDVwbGF5ZXIsIG9wdGlvbnMpO1xuXG4gICAgZm9ybWF0cy5mb3JFYWNoKGZvcm1hdCA9PiB7XG4gICAgICBleHBvcnRzLnNldERvd25sb2FkVVJMKGZvcm1hdCwgZGVjaXBoZXJTY3JpcHQsIG5UcmFuc2Zvcm1TY3JpcHQpO1xuICAgICAgaWYgKGZvcm1hdC51cmwpIHtcbiAgICAgICAgZGVjaXBoZXJlZEZvcm1hdHNbZm9ybWF0LnVybF0gPSBmb3JtYXQ7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gZGVjaXBoZXJlZEZvcm1hdHM7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBkZWNpcGhlcmluZyBmb3JtYXRzOlwiLCBlcnIpO1xuICAgIHJldHVybiB7fTtcbiAgfVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@distube/ytdl-core/lib/sig.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@distube/ytdl-core/lib/url-utils.js":
/*!**********************************************************!*\
  !*** ./node_modules/@distube/ytdl-core/lib/url-utils.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/**\n * Get video ID.\n *\n * There are a few type of video URL formats.\n *  - https://www.youtube.com/watch?v=VIDEO_ID\n *  - https://m.youtube.com/watch?v=VIDEO_ID\n *  - https://youtu.be/VIDEO_ID\n *  - https://www.youtube.com/v/VIDEO_ID\n *  - https://www.youtube.com/embed/VIDEO_ID\n *  - https://music.youtube.com/watch?v=VIDEO_ID\n *  - https://gaming.youtube.com/watch?v=VIDEO_ID\n *\n * @param {string} link\n * @return {string}\n * @throws {Error} If unable to find a id\n * @throws {TypeError} If videoid doesn't match specs\n */\nconst validQueryDomains = new Set([\n  \"youtube.com\",\n  \"www.youtube.com\",\n  \"m.youtube.com\",\n  \"music.youtube.com\",\n  \"gaming.youtube.com\",\n]);\nconst validPathDomains = /^https?:\\/\\/(youtu\\.be\\/|(www\\.)?youtube\\.com\\/(embed|v|shorts|live)\\/)/;\nexports.getURLVideoID = link => {\n  const parsed = new URL(link.trim());\n  let id = parsed.searchParams.get(\"v\");\n  if (validPathDomains.test(link.trim()) && !id) {\n    const paths = parsed.pathname.split(\"/\");\n    id = parsed.host === \"youtu.be\" ? paths[1] : paths[2];\n  } else if (parsed.hostname && !validQueryDomains.has(parsed.hostname)) {\n    throw Error(\"Not a YouTube domain\");\n  }\n  if (!id) {\n    throw Error(`No video id found: \"${link}\"`);\n  }\n  id = id.substring(0, 11);\n  if (!exports.validateID(id)) {\n    throw TypeError(`Video id (${id}) does not match expected ` + `format (${idRegex.toString()})`);\n  }\n  return id;\n};\n\n/**\n * Gets video ID either from a url or by checking if the given string\n * matches the video ID format.\n *\n * @param {string} str\n * @returns {string}\n * @throws {Error} If unable to find a id\n * @throws {TypeError} If videoid doesn't match specs\n */\nconst urlRegex = /^https?:\\/\\//;\nexports.getVideoID = str => {\n  if (exports.validateID(str)) {\n    return str;\n  } else if (urlRegex.test(str.trim())) {\n    return exports.getURLVideoID(str);\n  } else {\n    throw Error(`No video id found: ${str}`);\n  }\n};\n\n/**\n * Returns true if given id satifies YouTube's id format.\n *\n * @param {string} id\n * @return {boolean}\n */\nconst idRegex = /^[a-zA-Z0-9-_]{11}$/;\nexports.validateID = id => idRegex.test(id.trim());\n\n/**\n * Checks wether the input string includes a valid id.\n *\n * @param {string} string\n * @returns {boolean}\n */\nexports.validateURL = string => {\n  try {\n    exports.getURLVideoID(string);\n    return true;\n  } catch (e) {\n    return false;\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGRpc3R1YmUveXRkbC1jb3JlL2xpYi91cmwtdXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWixZQUFZLE9BQU87QUFDbkIsWUFBWSxXQUFXO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxLQUFLO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxHQUFHLHlDQUF5QyxtQkFBbUI7QUFDaEc7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYixZQUFZLE9BQU87QUFDbkIsWUFBWSxXQUFXO0FBQ3ZCO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSixzQ0FBc0MsSUFBSTtBQUMxQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQSxnQ0FBZ0MsR0FBRztBQUNuQyxrQkFBa0I7O0FBRWxCO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3l0LWRvd25sb2FkZXIvLi9ub2RlX21vZHVsZXMvQGRpc3R1YmUveXRkbC1jb3JlL2xpYi91cmwtdXRpbHMuanM/NTJkMSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEdldCB2aWRlbyBJRC5cbiAqXG4gKiBUaGVyZSBhcmUgYSBmZXcgdHlwZSBvZiB2aWRlbyBVUkwgZm9ybWF0cy5cbiAqICAtIGh0dHBzOi8vd3d3LnlvdXR1YmUuY29tL3dhdGNoP3Y9VklERU9fSURcbiAqICAtIGh0dHBzOi8vbS55b3V0dWJlLmNvbS93YXRjaD92PVZJREVPX0lEXG4gKiAgLSBodHRwczovL3lvdXR1LmJlL1ZJREVPX0lEXG4gKiAgLSBodHRwczovL3d3dy55b3V0dWJlLmNvbS92L1ZJREVPX0lEXG4gKiAgLSBodHRwczovL3d3dy55b3V0dWJlLmNvbS9lbWJlZC9WSURFT19JRFxuICogIC0gaHR0cHM6Ly9tdXNpYy55b3V0dWJlLmNvbS93YXRjaD92PVZJREVPX0lEXG4gKiAgLSBodHRwczovL2dhbWluZy55b3V0dWJlLmNvbS93YXRjaD92PVZJREVPX0lEXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGxpbmtcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB1bmFibGUgdG8gZmluZCBhIGlkXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIHZpZGVvaWQgZG9lc24ndCBtYXRjaCBzcGVjc1xuICovXG5jb25zdCB2YWxpZFF1ZXJ5RG9tYWlucyA9IG5ldyBTZXQoW1xuICBcInlvdXR1YmUuY29tXCIsXG4gIFwid3d3LnlvdXR1YmUuY29tXCIsXG4gIFwibS55b3V0dWJlLmNvbVwiLFxuICBcIm11c2ljLnlvdXR1YmUuY29tXCIsXG4gIFwiZ2FtaW5nLnlvdXR1YmUuY29tXCIsXG5dKTtcbmNvbnN0IHZhbGlkUGF0aERvbWFpbnMgPSAvXmh0dHBzPzpcXC9cXC8oeW91dHVcXC5iZVxcL3wod3d3XFwuKT95b3V0dWJlXFwuY29tXFwvKGVtYmVkfHZ8c2hvcnRzfGxpdmUpXFwvKS87XG5leHBvcnRzLmdldFVSTFZpZGVvSUQgPSBsaW5rID0+IHtcbiAgY29uc3QgcGFyc2VkID0gbmV3IFVSTChsaW5rLnRyaW0oKSk7XG4gIGxldCBpZCA9IHBhcnNlZC5zZWFyY2hQYXJhbXMuZ2V0KFwidlwiKTtcbiAgaWYgKHZhbGlkUGF0aERvbWFpbnMudGVzdChsaW5rLnRyaW0oKSkgJiYgIWlkKSB7XG4gICAgY29uc3QgcGF0aHMgPSBwYXJzZWQucGF0aG5hbWUuc3BsaXQoXCIvXCIpO1xuICAgIGlkID0gcGFyc2VkLmhvc3QgPT09IFwieW91dHUuYmVcIiA/IHBhdGhzWzFdIDogcGF0aHNbMl07XG4gIH0gZWxzZSBpZiAocGFyc2VkLmhvc3RuYW1lICYmICF2YWxpZFF1ZXJ5RG9tYWlucy5oYXMocGFyc2VkLmhvc3RuYW1lKSkge1xuICAgIHRocm93IEVycm9yKFwiTm90IGEgWW91VHViZSBkb21haW5cIik7XG4gIH1cbiAgaWYgKCFpZCkge1xuICAgIHRocm93IEVycm9yKGBObyB2aWRlbyBpZCBmb3VuZDogXCIke2xpbmt9XCJgKTtcbiAgfVxuICBpZCA9IGlkLnN1YnN0cmluZygwLCAxMSk7XG4gIGlmICghZXhwb3J0cy52YWxpZGF0ZUlEKGlkKSkge1xuICAgIHRocm93IFR5cGVFcnJvcihgVmlkZW8gaWQgKCR7aWR9KSBkb2VzIG5vdCBtYXRjaCBleHBlY3RlZCBgICsgYGZvcm1hdCAoJHtpZFJlZ2V4LnRvU3RyaW5nKCl9KWApO1xuICB9XG4gIHJldHVybiBpZDtcbn07XG5cbi8qKlxuICogR2V0cyB2aWRlbyBJRCBlaXRoZXIgZnJvbSBhIHVybCBvciBieSBjaGVja2luZyBpZiB0aGUgZ2l2ZW4gc3RyaW5nXG4gKiBtYXRjaGVzIHRoZSB2aWRlbyBJRCBmb3JtYXQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICogQHJldHVybnMge3N0cmluZ31cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB1bmFibGUgdG8gZmluZCBhIGlkXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIHZpZGVvaWQgZG9lc24ndCBtYXRjaCBzcGVjc1xuICovXG5jb25zdCB1cmxSZWdleCA9IC9eaHR0cHM/OlxcL1xcLy87XG5leHBvcnRzLmdldFZpZGVvSUQgPSBzdHIgPT4ge1xuICBpZiAoZXhwb3J0cy52YWxpZGF0ZUlEKHN0cikpIHtcbiAgICByZXR1cm4gc3RyO1xuICB9IGVsc2UgaWYgKHVybFJlZ2V4LnRlc3Qoc3RyLnRyaW0oKSkpIHtcbiAgICByZXR1cm4gZXhwb3J0cy5nZXRVUkxWaWRlb0lEKHN0cik7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgRXJyb3IoYE5vIHZpZGVvIGlkIGZvdW5kOiAke3N0cn1gKTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgZ2l2ZW4gaWQgc2F0aWZpZXMgWW91VHViZSdzIGlkIGZvcm1hdC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gaWRcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmNvbnN0IGlkUmVnZXggPSAvXlthLXpBLVowLTktX117MTF9JC87XG5leHBvcnRzLnZhbGlkYXRlSUQgPSBpZCA9PiBpZFJlZ2V4LnRlc3QoaWQudHJpbSgpKTtcblxuLyoqXG4gKiBDaGVja3Mgd2V0aGVyIHRoZSBpbnB1dCBzdHJpbmcgaW5jbHVkZXMgYSB2YWxpZCBpZC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0cy52YWxpZGF0ZVVSTCA9IHN0cmluZyA9PiB7XG4gIHRyeSB7XG4gICAgZXhwb3J0cy5nZXRVUkxWaWRlb0lEKHN0cmluZyk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@distube/ytdl-core/lib/url-utils.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@distube/ytdl-core/lib/utils.js":
/*!******************************************************!*\
  !*** ./node_modules/@distube/ytdl-core/lib/utils.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("const { request } = __webpack_require__(/*! undici */ \"(rsc)/./node_modules/undici/index.js\");\nconst { writeFileSync } = __webpack_require__(/*! fs */ \"fs\");\nconst AGENT = __webpack_require__(/*! ./agent */ \"(rsc)/./node_modules/@distube/ytdl-core/lib/agent.js\");\n\n/**\n * Extract string inbetween another.\n *\n * @param {string} haystack\n * @param {string} left\n * @param {string} right\n * @returns {string}\n */\nconst between = (exports.between = (haystack, left, right) => {\n  let pos;\n  if (left instanceof RegExp) {\n    const match = haystack.match(left);\n    if (!match) {\n      return \"\";\n    }\n    pos = match.index + match[0].length;\n  } else {\n    pos = haystack.indexOf(left);\n    if (pos === -1) {\n      return \"\";\n    }\n    pos += left.length;\n  }\n  haystack = haystack.slice(pos);\n  pos = haystack.indexOf(right);\n  if (pos === -1) {\n    return \"\";\n  }\n  haystack = haystack.slice(0, pos);\n  return haystack;\n});\n\nexports.tryParseBetween = (body, left, right, prepend = \"\", append = \"\") => {\n  try {\n    let data = between(body, left, right);\n    if (!data) return null;\n    return JSON.parse(`${prepend}${data}${append}`);\n  } catch (e) {\n    return null;\n  }\n};\n\n/**\n * Get a number from an abbreviated number string.\n *\n * @param {string} string\n * @returns {number}\n */\nexports.parseAbbreviatedNumber = string => {\n  const match = string\n    .replace(\",\", \".\")\n    .replace(\" \", \"\")\n    .match(/([\\d,.]+)([MK]?)/);\n  if (match) {\n    let [, num, multi] = match;\n    num = parseFloat(num);\n    return Math.round(multi === \"M\" ? num * 1000000 : multi === \"K\" ? num * 1000 : num);\n  }\n  return null;\n};\n\n/**\n * Escape sequences for cutAfterJS\n * @param {string} start the character string the escape sequence\n * @param {string} end the character string to stop the escape seequence\n * @param {undefined|Regex} startPrefix a regex to check against the preceding 10 characters\n */\nconst ESCAPING_SEQUENZES = [\n  // Strings\n  { start: '\"', end: '\"' },\n  { start: \"'\", end: \"'\" },\n  { start: \"`\", end: \"`\" },\n  // RegeEx\n  { start: \"/\", end: \"/\", startPrefix: /(^|[[{:;,/])\\s?$/ },\n];\n\n/**\n * Match begin and end braces of input JS, return only JS\n *\n * @param {string} mixedJson\n * @returns {string}\n */\nexports.cutAfterJS = mixedJson => {\n  // Define the general open and closing tag\n  let open, close;\n  if (mixedJson[0] === \"[\") {\n    open = \"[\";\n    close = \"]\";\n  } else if (mixedJson[0] === \"{\") {\n    open = \"{\";\n    close = \"}\";\n  }\n\n  if (!open) {\n    throw new Error(`Can't cut unsupported JSON (need to begin with [ or { ) but got: ${mixedJson[0]}`);\n  }\n\n  // States if the loop is currently inside an escaped js object\n  let isEscapedObject = null;\n\n  // States if the current character is treated as escaped or not\n  let isEscaped = false;\n\n  // Current open brackets to be closed\n  let counter = 0;\n\n  let i;\n  // Go through all characters from the start\n  for (i = 0; i < mixedJson.length; i++) {\n    // End of current escaped object\n    if (!isEscaped && isEscapedObject !== null && mixedJson[i] === isEscapedObject.end) {\n      isEscapedObject = null;\n      continue;\n      // Might be the start of a new escaped object\n    } else if (!isEscaped && isEscapedObject === null) {\n      for (const escaped of ESCAPING_SEQUENZES) {\n        if (mixedJson[i] !== escaped.start) continue;\n        // Test startPrefix against last 10 characters\n        if (!escaped.startPrefix || mixedJson.substring(i - 10, i).match(escaped.startPrefix)) {\n          isEscapedObject = escaped;\n          break;\n        }\n      }\n      // Continue if we found a new escaped object\n      if (isEscapedObject !== null) {\n        continue;\n      }\n    }\n\n    // Toggle the isEscaped boolean for every backslash\n    // Reset for every regular character\n    isEscaped = mixedJson[i] === \"\\\\\" && !isEscaped;\n\n    if (isEscapedObject !== null) continue;\n\n    if (mixedJson[i] === open) {\n      counter++;\n    } else if (mixedJson[i] === close) {\n      counter--;\n    }\n\n    // All brackets have been closed, thus end of JSON is reached\n    if (counter === 0) {\n      // Return the cut JSON\n      return mixedJson.substring(0, i + 1);\n    }\n  }\n\n  // We ran through the whole string and ended up with an unclosed bracket\n  throw Error(\"Can't cut unsupported JSON (no matching closing bracket found)\");\n};\n\nclass UnrecoverableError extends Error {}\n/**\n * Checks if there is a playability error.\n *\n * @param {Object} player_response\n * @returns {!Error}\n */\nexports.playError = player_response => {\n  const playability = player_response?.playabilityStatus;\n  if (!playability) return null;\n  if ([\"ERROR\", \"LOGIN_REQUIRED\"].includes(playability.status)) {\n    return new UnrecoverableError(playability.reason || playability.messages?.[0]);\n  }\n  if (playability.status === \"LIVE_STREAM_OFFLINE\") {\n    return new UnrecoverableError(playability.reason || \"The live stream is offline.\");\n  }\n  if (playability.status === \"UNPLAYABLE\") {\n    return new UnrecoverableError(playability.reason || \"This video is unavailable.\");\n  }\n  return null;\n};\n\n// Undici request\nconst useFetch = async (fetch, url, requestOptions) => {\n  // embed query to url\n  const query = requestOptions.query;\n  if (query) {\n    const urlObject = new URL(url);\n    for (const key in query) {\n      urlObject.searchParams.append(key, query[key]);\n    }\n    url = urlObject.toString();\n  }\n\n  const response = await fetch(url, requestOptions);\n\n  // convert webstandard response to undici request's response\n  const statusCode = response.status;\n  const body = Object.assign(response, response.body || {});\n  const headers = Object.fromEntries(response.headers.entries());\n\n  return { body, statusCode, headers };\n};\nexports.request = async (url, options = {}) => {\n  let { requestOptions, rewriteRequest, fetch } = options;\n\n  if (typeof rewriteRequest === \"function\") {\n    const rewritten = rewriteRequest(url, requestOptions);\n    requestOptions = rewritten.requestOptions || requestOptions;\n    url = rewritten.url || url;\n  }\n\n  const req =\n    typeof fetch === \"function\" ? await useFetch(fetch, url, requestOptions) : await request(url, requestOptions);\n  const code = req.statusCode.toString();\n\n  if (code.startsWith(\"2\")) {\n    if (req.headers[\"content-type\"].includes(\"application/json\")) return req.body.json();\n    return req.body.text();\n  }\n  if (code.startsWith(\"3\")) return exports.request(req.headers.location, options);\n\n  const e = new Error(`Status code: ${code}`);\n  e.statusCode = req.statusCode;\n  throw e;\n};\n\n/**\n * Temporary helper to help deprecating a few properties.\n *\n * @param {Object} obj\n * @param {string} prop\n * @param {Object} value\n * @param {string} oldPath\n * @param {string} newPath\n */\nexports.deprecate = (obj, prop, value, oldPath, newPath) => {\n  Object.defineProperty(obj, prop, {\n    get: () => {\n      console.warn(`\\`${oldPath}\\` will be removed in a near future release, ` + `use \\`${newPath}\\` instead.`);\n      return value;\n    },\n  });\n};\n\n// Check for updates.\nconst pkg = __webpack_require__(/*! ../package.json */ \"(rsc)/./node_modules/@distube/ytdl-core/package.json\");\nconst UPDATE_INTERVAL = 1000 * 60 * 60 * 12;\nlet updateWarnTimes = 0;\nexports.lastUpdateCheck = 0;\nexports.checkForUpdates = () => {\n  if (\n    !process.env.YTDL_NO_UPDATE &&\n    !pkg.version.startsWith(\"0.0.0-\") &&\n    Date.now() - exports.lastUpdateCheck >= UPDATE_INTERVAL\n  ) {\n    exports.lastUpdateCheck = Date.now();\n    return exports\n      .request(\"https://api.github.com/repos/distubejs/ytdl-core/contents/package.json\", {\n        requestOptions: {\n          headers: {\n            \"User-Agent\":\n              \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/129.0.0.0 Safari/537.3\",\n          },\n        },\n      })\n      .then(\n        response => {\n          const buf = Buffer.from(response.content, response.encoding);\n          const pkgFile = JSON.parse(buf.toString(\"ascii\"));\n          if (pkgFile.version !== pkg.version && updateWarnTimes++ < 5) {\n            // eslint-disable-next-line max-len\n            console.warn(\n              '\\x1b[33mWARNING:\\x1B[0m @distube/ytdl-core is out of date! Update with \"npm install @distube/ytdl-core@latest\".',\n            );\n          }\n        },\n        err => {\n          console.warn(\"Error checking for updates:\", err.message);\n          console.warn(\"You can disable this check by setting the `YTDL_NO_UPDATE` env variable.\");\n        },\n      );\n  }\n  return null;\n};\n\n/**\n * Gets random IPv6 Address from a block\n *\n * @param {string} ip the IPv6 block in CIDR-Notation\n * @returns {string}\n */\nconst getRandomIPv6 = ip => {\n  if (!isIPv6(ip)) {\n    throw new Error(\"Invalid IPv6 format\");\n  }\n\n  const [rawAddr, rawMask] = ip.split(\"/\");\n  const mask = parseInt(rawMask, 10);\n\n  if (isNaN(mask) || mask > 128 || mask < 1) {\n    throw new Error(\"Invalid IPv6 subnet mask (must be between 1 and 128)\");\n  }\n\n  const base10addr = normalizeIP(rawAddr);\n\n  const fullMaskGroups = Math.floor(mask / 16);\n  const remainingBits = mask % 16;\n\n  const result = new Array(8).fill(0);\n\n  for (let i = 0; i < 8; i++) {\n    if (i < fullMaskGroups) {\n      result[i] = base10addr[i];\n    } else if (i === fullMaskGroups && remainingBits > 0) {\n      const groupMask = 0xffff << (16 - remainingBits);\n      const randomPart = Math.floor(Math.random() * (1 << (16 - remainingBits)));\n      result[i] = (base10addr[i] & groupMask) | randomPart;\n    } else {\n      result[i] = Math.floor(Math.random() * 0x10000);\n    }\n  }\n\n  return result.map(x => x.toString(16).padStart(4, \"0\")).join(\":\");\n};\n\nconst isIPv6 = ip => {\n  const IPV6_REGEX =\n    /^(?:(?:[0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|(?:[0-9a-fA-F]{1,4}:){1,7}:|(?:[0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|(?:[0-9a-fA-F]{1,4}:){1,5}(?::[0-9a-fA-F]{1,4}){1,2}|(?:[0-9a-fA-F]{1,4}:){1,4}(?::[0-9a-fA-F]{1,4}){1,3}|(?:[0-9a-fA-F]{1,4}:){1,3}(?::[0-9a-fA-F]{1,4}){1,4}|(?:[0-9a-fA-F]{1,4}:){1,2}(?::[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:(?:(?::[0-9a-fA-F]{1,4}){1,6})|:(?:(?::[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(?::[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(?:ffff(?::0{1,4}){0,1}:){0,1}(?:(?:25[0-5]|(?:2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(?:25[0-5]|(?:2[0-4]|1{0,1}[0-9]){0,1}[0-9])|(?:[0-9a-fA-F]{1,4}:){1,4}:(?:(?:25[0-5]|(?:2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(?:25[0-5]|(?:2[0-4]|1{0,1}[0-9]){0,1}[0-9]))(?:\\/(?:1[0-1][0-9]|12[0-8]|[1-9][0-9]|[1-9]))?$/;\n  return IPV6_REGEX.test(ip);\n};\n\n/**\n * Normalizes an IPv6 address into an array of 8 integers\n * @param {string} ip - IPv6 address\n * @returns {number[]} - Array of 8 integers representing the address\n */\nconst normalizeIP = ip => {\n  const parts = ip.split(\"::\");\n  let start = parts[0] ? parts[0].split(\":\") : [];\n  let end = parts[1] ? parts[1].split(\":\") : [];\n\n  const missing = 8 - (start.length + end.length);\n  const zeros = new Array(missing).fill(\"0\");\n\n  const full = [...start, ...zeros, ...end];\n\n  return full.map(part => parseInt(part || \"0\", 16));\n};\n\nexports.saveDebugFile = (name, body) => {\n  if (process.env.YTDL_NO_DEBUG_FILE) {\n    console.warn(`\\x1b[33mWARNING:\\x1b[0m Debug file saving is disabled. \"${name}\"`);\n    return body;\n  }\n  const filename = `${+new Date()}-${name}`;\n  const debugPath = process.env.YTDL_DEBUG_PATH || '.';\n  writeFileSync(`${debugPath}/${filename}`, body);\n  return filename;\n};\n\nconst findPropKeyInsensitive = (obj, prop) =>\n  Object.keys(obj).find(p => p.toLowerCase() === prop.toLowerCase()) || null;\n\nexports.getPropInsensitive = (obj, prop) => {\n  const key = findPropKeyInsensitive(obj, prop);\n  return key && obj[key];\n};\n\nexports.setPropInsensitive = (obj, prop, value) => {\n  const key = findPropKeyInsensitive(obj, prop);\n  obj[key || prop] = value;\n  return key;\n};\n\nlet oldCookieWarning = true;\nlet oldDispatcherWarning = true;\nexports.applyDefaultAgent = options => {\n  if (!options.agent) {\n    const { jar } = AGENT.defaultAgent;\n    const c = exports.getPropInsensitive(options.requestOptions.headers, \"cookie\");\n    if (c) {\n      jar.removeAllCookiesSync();\n      AGENT.addCookiesFromString(jar, c);\n      if (oldCookieWarning) {\n        oldCookieWarning = false;\n        console.warn(\n          \"\\x1b[33mWARNING:\\x1B[0m Using old cookie format, \" +\n            \"please use the new one instead. (https://github.com/distubejs/ytdl-core#cookies-support)\",\n        );\n      }\n    }\n    if (options.requestOptions.dispatcher && oldDispatcherWarning) {\n      oldDispatcherWarning = false;\n      console.warn(\n        \"\\x1b[33mWARNING:\\x1B[0m Your dispatcher is overridden by `ytdl.Agent`. \" +\n          \"To implement your own, check out the documentation. \" +\n          \"(https://github.com/distubejs/ytdl-core#how-to-implement-ytdlagent-with-your-own-dispatcher)\",\n      );\n    }\n    options.agent = AGENT.defaultAgent;\n  }\n};\n\nlet oldLocalAddressWarning = true;\nexports.applyOldLocalAddress = options => {\n  if (!options?.requestOptions?.localAddress || options.requestOptions.localAddress === options.agent.localAddress)\n    return;\n  options.agent = AGENT.createAgent(undefined, { localAddress: options.requestOptions.localAddress });\n  if (oldLocalAddressWarning) {\n    oldLocalAddressWarning = false;\n    console.warn(\n      \"\\x1b[33mWARNING:\\x1B[0m Using old localAddress option, \" +\n        \"please add it to the agent options instead. (https://github.com/distubejs/ytdl-core#ip-rotation)\",\n    );\n  }\n};\n\nlet oldIpRotationsWarning = true;\nexports.applyIPv6Rotations = options => {\n  if (options.IPv6Block) {\n    options.requestOptions = Object.assign({}, options.requestOptions, {\n      localAddress: getRandomIPv6(options.IPv6Block),\n    });\n    if (oldIpRotationsWarning) {\n      oldIpRotationsWarning = false;\n      oldLocalAddressWarning = false;\n      console.warn(\n        \"\\x1b[33mWARNING:\\x1B[0m IPv6Block option is deprecated, \" +\n          \"please create your own ip rotation instead. (https://github.com/distubejs/ytdl-core#ip-rotation)\",\n      );\n    }\n  }\n};\n\nexports.applyDefaultHeaders = options => {\n  options.requestOptions = Object.assign({}, options.requestOptions);\n  options.requestOptions.headers = Object.assign(\n    {},\n    {\n      // eslint-disable-next-line max-len\n      \"User-Agent\":\n        \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.101 Safari/537.36\",\n    },\n    options.requestOptions.headers,\n  );\n};\n\nexports.generateClientPlaybackNonce = length => {\n  const CPN_CHARS = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\";\n  return Array.from({ length }, () => CPN_CHARS[Math.floor(Math.random() * CPN_CHARS.length)]).join(\"\");\n};\n\nexports.applyPlayerClients = options => {\n  if (!options.playerClients || options.playerClients.length === 0) {\n    options.playerClients = [\"WEB_EMBEDDED\", \"IOS\", \"ANDROID\", \"TV\"];\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGRpc3R1YmUveXRkbC1jb3JlL2xpYi91dGlscy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxRQUFRLFVBQVUsRUFBRSxtQkFBTyxDQUFDLG9EQUFRO0FBQ3BDLFFBQVEsZ0JBQWdCLEVBQUUsbUJBQU8sQ0FBQyxjQUFJO0FBQ3RDLGNBQWMsbUJBQU8sQ0FBQyxxRUFBUzs7QUFFL0I7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0EsaUJBQWlCLGVBQWU7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVELHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsUUFBUSxFQUFFLEtBQUssRUFBRSxPQUFPO0FBQ2pELElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsaUJBQWlCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLElBQUksc0JBQXNCO0FBQzFCLElBQUksc0JBQXNCO0FBQzFCLElBQUksc0JBQXNCO0FBQzFCO0FBQ0EsSUFBSSwwQ0FBMEMsRUFBRSxXQUFXO0FBQzNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksNEJBQTRCO0FBQ2hDLGFBQWE7QUFDYixjQUFjO0FBQ2Q7O0FBRUE7QUFDQSwyRUFBMkUsYUFBYSxhQUFhO0FBQ3JHOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLHNCQUFzQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFEOztBQUVBLFdBQVc7QUFDWDtBQUNBLGVBQWUsMkJBQTJCO0FBQzFDLFFBQVEsd0NBQXdDOztBQUVoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNDQUFzQyxLQUFLO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUSwwREFBMEQsUUFBUTtBQUNsRztBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQSxZQUFZLG1CQUFPLENBQUMsNkVBQWlCO0FBQ3JDO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHVCQUF1QjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLE9BQU87QUFDcEQsV0FBVztBQUNYLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0IsSUFBSSxHQUFHLEVBQUUsWUFBWSxJQUFJLGdCQUFnQixJQUFJLEdBQUcsSUFBSSxpQkFBaUIsSUFBSSxHQUFHLElBQUksYUFBYSxJQUFJLGdCQUFnQixJQUFJLEdBQUcsSUFBSSxnQkFBZ0IsSUFBSSxFQUFFLElBQUksZ0JBQWdCLElBQUksR0FBRyxJQUFJLGdCQUFnQixJQUFJLEVBQUUsSUFBSSxnQkFBZ0IsSUFBSSxHQUFHLElBQUksZ0JBQWdCLElBQUksRUFBRSxJQUFJLGdCQUFnQixJQUFJLEdBQUcsSUFBSSxnQkFBZ0IsSUFBSSxFQUFFLElBQUksYUFBYSxJQUFJLG9CQUFvQixJQUFJLEVBQUUsSUFBSSxzQkFBc0IsSUFBSSxFQUFFLElBQUkseUJBQXlCLElBQUksRUFBRSxJQUFJLGFBQWEsR0FBRyxnQkFBZ0IsSUFBSSxFQUFFLElBQUksR0FBRyxJQUFJLDBCQUEwQixJQUFJLE9BQU8sSUFBSSxVQUFVLElBQUksdUJBQXVCLElBQUksT0FBTyxJQUFJLHNCQUFzQixJQUFJLEdBQUcsSUFBSSwyQkFBMkIsSUFBSSxPQUFPLElBQUksVUFBVSxJQUFJLHVCQUF1QixJQUFJLE9BQU8sSUFBSTtBQUM1c0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxxQkFBcUI7QUFDckI7QUFDQSw0RUFBNEUsS0FBSztBQUNqRjtBQUNBO0FBQ0Esc0JBQXNCLFlBQVksR0FBRyxLQUFLO0FBQzFDO0FBQ0EsbUJBQW1CLFVBQVUsR0FBRyxTQUFTO0FBQ3pDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBOztBQUVBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBLGlEQUFpRCxtREFBbUQ7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBLDZDQUE2QztBQUM3QztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkI7QUFDM0IsMkNBQTJDO0FBQzNDO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxPQUFPO0FBQzlDLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUEsbUNBQW1DO0FBQ25DO0FBQ0Esc0JBQXNCLFFBQVE7QUFDOUI7O0FBRUEsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8veXQtZG93bmxvYWRlci8uL25vZGVfbW9kdWxlcy9AZGlzdHViZS95dGRsLWNvcmUvbGliL3V0aWxzLmpzPzMyYjUiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgeyByZXF1ZXN0IH0gPSByZXF1aXJlKFwidW5kaWNpXCIpO1xuY29uc3QgeyB3cml0ZUZpbGVTeW5jIH0gPSByZXF1aXJlKFwiZnNcIik7XG5jb25zdCBBR0VOVCA9IHJlcXVpcmUoXCIuL2FnZW50XCIpO1xuXG4vKipcbiAqIEV4dHJhY3Qgc3RyaW5nIGluYmV0d2VlbiBhbm90aGVyLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBoYXlzdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGxlZnRcbiAqIEBwYXJhbSB7c3RyaW5nfSByaWdodFxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuY29uc3QgYmV0d2VlbiA9IChleHBvcnRzLmJldHdlZW4gPSAoaGF5c3RhY2ssIGxlZnQsIHJpZ2h0KSA9PiB7XG4gIGxldCBwb3M7XG4gIGlmIChsZWZ0IGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgY29uc3QgbWF0Y2ggPSBoYXlzdGFjay5tYXRjaChsZWZ0KTtcbiAgICBpZiAoIW1hdGNoKSB7XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgcG9zID0gbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGg7XG4gIH0gZWxzZSB7XG4gICAgcG9zID0gaGF5c3RhY2suaW5kZXhPZihsZWZ0KTtcbiAgICBpZiAocG9zID09PSAtMSkge1xuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICAgIHBvcyArPSBsZWZ0Lmxlbmd0aDtcbiAgfVxuICBoYXlzdGFjayA9IGhheXN0YWNrLnNsaWNlKHBvcyk7XG4gIHBvcyA9IGhheXN0YWNrLmluZGV4T2YocmlnaHQpO1xuICBpZiAocG9zID09PSAtMSkge1xuICAgIHJldHVybiBcIlwiO1xuICB9XG4gIGhheXN0YWNrID0gaGF5c3RhY2suc2xpY2UoMCwgcG9zKTtcbiAgcmV0dXJuIGhheXN0YWNrO1xufSk7XG5cbmV4cG9ydHMudHJ5UGFyc2VCZXR3ZWVuID0gKGJvZHksIGxlZnQsIHJpZ2h0LCBwcmVwZW5kID0gXCJcIiwgYXBwZW5kID0gXCJcIikgPT4ge1xuICB0cnkge1xuICAgIGxldCBkYXRhID0gYmV0d2Vlbihib2R5LCBsZWZ0LCByaWdodCk7XG4gICAgaWYgKCFkYXRhKSByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShgJHtwcmVwZW5kfSR7ZGF0YX0ke2FwcGVuZH1gKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59O1xuXG4vKipcbiAqIEdldCBhIG51bWJlciBmcm9tIGFuIGFiYnJldmlhdGVkIG51bWJlciBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0cy5wYXJzZUFiYnJldmlhdGVkTnVtYmVyID0gc3RyaW5nID0+IHtcbiAgY29uc3QgbWF0Y2ggPSBzdHJpbmdcbiAgICAucmVwbGFjZShcIixcIiwgXCIuXCIpXG4gICAgLnJlcGxhY2UoXCIgXCIsIFwiXCIpXG4gICAgLm1hdGNoKC8oW1xcZCwuXSspKFtNS10/KS8pO1xuICBpZiAobWF0Y2gpIHtcbiAgICBsZXQgWywgbnVtLCBtdWx0aV0gPSBtYXRjaDtcbiAgICBudW0gPSBwYXJzZUZsb2F0KG51bSk7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXVsdGkgPT09IFwiTVwiID8gbnVtICogMTAwMDAwMCA6IG11bHRpID09PSBcIktcIiA/IG51bSAqIDEwMDAgOiBudW0pO1xuICB9XG4gIHJldHVybiBudWxsO1xufTtcblxuLyoqXG4gKiBFc2NhcGUgc2VxdWVuY2VzIGZvciBjdXRBZnRlckpTXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RhcnQgdGhlIGNoYXJhY3RlciBzdHJpbmcgdGhlIGVzY2FwZSBzZXF1ZW5jZVxuICogQHBhcmFtIHtzdHJpbmd9IGVuZCB0aGUgY2hhcmFjdGVyIHN0cmluZyB0byBzdG9wIHRoZSBlc2NhcGUgc2VlcXVlbmNlXG4gKiBAcGFyYW0ge3VuZGVmaW5lZHxSZWdleH0gc3RhcnRQcmVmaXggYSByZWdleCB0byBjaGVjayBhZ2FpbnN0IHRoZSBwcmVjZWRpbmcgMTAgY2hhcmFjdGVyc1xuICovXG5jb25zdCBFU0NBUElOR19TRVFVRU5aRVMgPSBbXG4gIC8vIFN0cmluZ3NcbiAgeyBzdGFydDogJ1wiJywgZW5kOiAnXCInIH0sXG4gIHsgc3RhcnQ6IFwiJ1wiLCBlbmQ6IFwiJ1wiIH0sXG4gIHsgc3RhcnQ6IFwiYFwiLCBlbmQ6IFwiYFwiIH0sXG4gIC8vIFJlZ2VFeFxuICB7IHN0YXJ0OiBcIi9cIiwgZW5kOiBcIi9cIiwgc3RhcnRQcmVmaXg6IC8oXnxbW3s6OywvXSlcXHM/JC8gfSxcbl07XG5cbi8qKlxuICogTWF0Y2ggYmVnaW4gYW5kIGVuZCBicmFjZXMgb2YgaW5wdXQgSlMsIHJldHVybiBvbmx5IEpTXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG1peGVkSnNvblxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZXhwb3J0cy5jdXRBZnRlckpTID0gbWl4ZWRKc29uID0+IHtcbiAgLy8gRGVmaW5lIHRoZSBnZW5lcmFsIG9wZW4gYW5kIGNsb3NpbmcgdGFnXG4gIGxldCBvcGVuLCBjbG9zZTtcbiAgaWYgKG1peGVkSnNvblswXSA9PT0gXCJbXCIpIHtcbiAgICBvcGVuID0gXCJbXCI7XG4gICAgY2xvc2UgPSBcIl1cIjtcbiAgfSBlbHNlIGlmIChtaXhlZEpzb25bMF0gPT09IFwie1wiKSB7XG4gICAgb3BlbiA9IFwie1wiO1xuICAgIGNsb3NlID0gXCJ9XCI7XG4gIH1cblxuICBpZiAoIW9wZW4pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYENhbid0IGN1dCB1bnN1cHBvcnRlZCBKU09OIChuZWVkIHRvIGJlZ2luIHdpdGggWyBvciB7ICkgYnV0IGdvdDogJHttaXhlZEpzb25bMF19YCk7XG4gIH1cblxuICAvLyBTdGF0ZXMgaWYgdGhlIGxvb3AgaXMgY3VycmVudGx5IGluc2lkZSBhbiBlc2NhcGVkIGpzIG9iamVjdFxuICBsZXQgaXNFc2NhcGVkT2JqZWN0ID0gbnVsbDtcblxuICAvLyBTdGF0ZXMgaWYgdGhlIGN1cnJlbnQgY2hhcmFjdGVyIGlzIHRyZWF0ZWQgYXMgZXNjYXBlZCBvciBub3RcbiAgbGV0IGlzRXNjYXBlZCA9IGZhbHNlO1xuXG4gIC8vIEN1cnJlbnQgb3BlbiBicmFja2V0cyB0byBiZSBjbG9zZWRcbiAgbGV0IGNvdW50ZXIgPSAwO1xuXG4gIGxldCBpO1xuICAvLyBHbyB0aHJvdWdoIGFsbCBjaGFyYWN0ZXJzIGZyb20gdGhlIHN0YXJ0XG4gIGZvciAoaSA9IDA7IGkgPCBtaXhlZEpzb24ubGVuZ3RoOyBpKyspIHtcbiAgICAvLyBFbmQgb2YgY3VycmVudCBlc2NhcGVkIG9iamVjdFxuICAgIGlmICghaXNFc2NhcGVkICYmIGlzRXNjYXBlZE9iamVjdCAhPT0gbnVsbCAmJiBtaXhlZEpzb25baV0gPT09IGlzRXNjYXBlZE9iamVjdC5lbmQpIHtcbiAgICAgIGlzRXNjYXBlZE9iamVjdCA9IG51bGw7XG4gICAgICBjb250aW51ZTtcbiAgICAgIC8vIE1pZ2h0IGJlIHRoZSBzdGFydCBvZiBhIG5ldyBlc2NhcGVkIG9iamVjdFxuICAgIH0gZWxzZSBpZiAoIWlzRXNjYXBlZCAmJiBpc0VzY2FwZWRPYmplY3QgPT09IG51bGwpIHtcbiAgICAgIGZvciAoY29uc3QgZXNjYXBlZCBvZiBFU0NBUElOR19TRVFVRU5aRVMpIHtcbiAgICAgICAgaWYgKG1peGVkSnNvbltpXSAhPT0gZXNjYXBlZC5zdGFydCkgY29udGludWU7XG4gICAgICAgIC8vIFRlc3Qgc3RhcnRQcmVmaXggYWdhaW5zdCBsYXN0IDEwIGNoYXJhY3RlcnNcbiAgICAgICAgaWYgKCFlc2NhcGVkLnN0YXJ0UHJlZml4IHx8IG1peGVkSnNvbi5zdWJzdHJpbmcoaSAtIDEwLCBpKS5tYXRjaChlc2NhcGVkLnN0YXJ0UHJlZml4KSkge1xuICAgICAgICAgIGlzRXNjYXBlZE9iamVjdCA9IGVzY2FwZWQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIENvbnRpbnVlIGlmIHdlIGZvdW5kIGEgbmV3IGVzY2FwZWQgb2JqZWN0XG4gICAgICBpZiAoaXNFc2NhcGVkT2JqZWN0ICE9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRvZ2dsZSB0aGUgaXNFc2NhcGVkIGJvb2xlYW4gZm9yIGV2ZXJ5IGJhY2tzbGFzaFxuICAgIC8vIFJlc2V0IGZvciBldmVyeSByZWd1bGFyIGNoYXJhY3RlclxuICAgIGlzRXNjYXBlZCA9IG1peGVkSnNvbltpXSA9PT0gXCJcXFxcXCIgJiYgIWlzRXNjYXBlZDtcblxuICAgIGlmIChpc0VzY2FwZWRPYmplY3QgIT09IG51bGwpIGNvbnRpbnVlO1xuXG4gICAgaWYgKG1peGVkSnNvbltpXSA9PT0gb3Blbikge1xuICAgICAgY291bnRlcisrO1xuICAgIH0gZWxzZSBpZiAobWl4ZWRKc29uW2ldID09PSBjbG9zZSkge1xuICAgICAgY291bnRlci0tO1xuICAgIH1cblxuICAgIC8vIEFsbCBicmFja2V0cyBoYXZlIGJlZW4gY2xvc2VkLCB0aHVzIGVuZCBvZiBKU09OIGlzIHJlYWNoZWRcbiAgICBpZiAoY291bnRlciA9PT0gMCkge1xuICAgICAgLy8gUmV0dXJuIHRoZSBjdXQgSlNPTlxuICAgICAgcmV0dXJuIG1peGVkSnNvbi5zdWJzdHJpbmcoMCwgaSArIDEpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFdlIHJhbiB0aHJvdWdoIHRoZSB3aG9sZSBzdHJpbmcgYW5kIGVuZGVkIHVwIHdpdGggYW4gdW5jbG9zZWQgYnJhY2tldFxuICB0aHJvdyBFcnJvcihcIkNhbid0IGN1dCB1bnN1cHBvcnRlZCBKU09OIChubyBtYXRjaGluZyBjbG9zaW5nIGJyYWNrZXQgZm91bmQpXCIpO1xufTtcblxuY2xhc3MgVW5yZWNvdmVyYWJsZUVycm9yIGV4dGVuZHMgRXJyb3Ige31cbi8qKlxuICogQ2hlY2tzIGlmIHRoZXJlIGlzIGEgcGxheWFiaWxpdHkgZXJyb3IuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBsYXllcl9yZXNwb25zZVxuICogQHJldHVybnMgeyFFcnJvcn1cbiAqL1xuZXhwb3J0cy5wbGF5RXJyb3IgPSBwbGF5ZXJfcmVzcG9uc2UgPT4ge1xuICBjb25zdCBwbGF5YWJpbGl0eSA9IHBsYXllcl9yZXNwb25zZT8ucGxheWFiaWxpdHlTdGF0dXM7XG4gIGlmICghcGxheWFiaWxpdHkpIHJldHVybiBudWxsO1xuICBpZiAoW1wiRVJST1JcIiwgXCJMT0dJTl9SRVFVSVJFRFwiXS5pbmNsdWRlcyhwbGF5YWJpbGl0eS5zdGF0dXMpKSB7XG4gICAgcmV0dXJuIG5ldyBVbnJlY292ZXJhYmxlRXJyb3IocGxheWFiaWxpdHkucmVhc29uIHx8IHBsYXlhYmlsaXR5Lm1lc3NhZ2VzPy5bMF0pO1xuICB9XG4gIGlmIChwbGF5YWJpbGl0eS5zdGF0dXMgPT09IFwiTElWRV9TVFJFQU1fT0ZGTElORVwiKSB7XG4gICAgcmV0dXJuIG5ldyBVbnJlY292ZXJhYmxlRXJyb3IocGxheWFiaWxpdHkucmVhc29uIHx8IFwiVGhlIGxpdmUgc3RyZWFtIGlzIG9mZmxpbmUuXCIpO1xuICB9XG4gIGlmIChwbGF5YWJpbGl0eS5zdGF0dXMgPT09IFwiVU5QTEFZQUJMRVwiKSB7XG4gICAgcmV0dXJuIG5ldyBVbnJlY292ZXJhYmxlRXJyb3IocGxheWFiaWxpdHkucmVhc29uIHx8IFwiVGhpcyB2aWRlbyBpcyB1bmF2YWlsYWJsZS5cIik7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuXG4vLyBVbmRpY2kgcmVxdWVzdFxuY29uc3QgdXNlRmV0Y2ggPSBhc3luYyAoZmV0Y2gsIHVybCwgcmVxdWVzdE9wdGlvbnMpID0+IHtcbiAgLy8gZW1iZWQgcXVlcnkgdG8gdXJsXG4gIGNvbnN0IHF1ZXJ5ID0gcmVxdWVzdE9wdGlvbnMucXVlcnk7XG4gIGlmIChxdWVyeSkge1xuICAgIGNvbnN0IHVybE9iamVjdCA9IG5ldyBVUkwodXJsKTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBxdWVyeSkge1xuICAgICAgdXJsT2JqZWN0LnNlYXJjaFBhcmFtcy5hcHBlbmQoa2V5LCBxdWVyeVtrZXldKTtcbiAgICB9XG4gICAgdXJsID0gdXJsT2JqZWN0LnRvU3RyaW5nKCk7XG4gIH1cblxuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwgcmVxdWVzdE9wdGlvbnMpO1xuXG4gIC8vIGNvbnZlcnQgd2Vic3RhbmRhcmQgcmVzcG9uc2UgdG8gdW5kaWNpIHJlcXVlc3QncyByZXNwb25zZVxuICBjb25zdCBzdGF0dXNDb2RlID0gcmVzcG9uc2Uuc3RhdHVzO1xuICBjb25zdCBib2R5ID0gT2JqZWN0LmFzc2lnbihyZXNwb25zZSwgcmVzcG9uc2UuYm9keSB8fCB7fSk7XG4gIGNvbnN0IGhlYWRlcnMgPSBPYmplY3QuZnJvbUVudHJpZXMocmVzcG9uc2UuaGVhZGVycy5lbnRyaWVzKCkpO1xuXG4gIHJldHVybiB7IGJvZHksIHN0YXR1c0NvZGUsIGhlYWRlcnMgfTtcbn07XG5leHBvcnRzLnJlcXVlc3QgPSBhc3luYyAodXJsLCBvcHRpb25zID0ge30pID0+IHtcbiAgbGV0IHsgcmVxdWVzdE9wdGlvbnMsIHJld3JpdGVSZXF1ZXN0LCBmZXRjaCB9ID0gb3B0aW9ucztcblxuICBpZiAodHlwZW9mIHJld3JpdGVSZXF1ZXN0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBjb25zdCByZXdyaXR0ZW4gPSByZXdyaXRlUmVxdWVzdCh1cmwsIHJlcXVlc3RPcHRpb25zKTtcbiAgICByZXF1ZXN0T3B0aW9ucyA9IHJld3JpdHRlbi5yZXF1ZXN0T3B0aW9ucyB8fCByZXF1ZXN0T3B0aW9ucztcbiAgICB1cmwgPSByZXdyaXR0ZW4udXJsIHx8IHVybDtcbiAgfVxuXG4gIGNvbnN0IHJlcSA9XG4gICAgdHlwZW9mIGZldGNoID09PSBcImZ1bmN0aW9uXCIgPyBhd2FpdCB1c2VGZXRjaChmZXRjaCwgdXJsLCByZXF1ZXN0T3B0aW9ucykgOiBhd2FpdCByZXF1ZXN0KHVybCwgcmVxdWVzdE9wdGlvbnMpO1xuICBjb25zdCBjb2RlID0gcmVxLnN0YXR1c0NvZGUudG9TdHJpbmcoKTtcblxuICBpZiAoY29kZS5zdGFydHNXaXRoKFwiMlwiKSkge1xuICAgIGlmIChyZXEuaGVhZGVyc1tcImNvbnRlbnQtdHlwZVwiXS5pbmNsdWRlcyhcImFwcGxpY2F0aW9uL2pzb25cIikpIHJldHVybiByZXEuYm9keS5qc29uKCk7XG4gICAgcmV0dXJuIHJlcS5ib2R5LnRleHQoKTtcbiAgfVxuICBpZiAoY29kZS5zdGFydHNXaXRoKFwiM1wiKSkgcmV0dXJuIGV4cG9ydHMucmVxdWVzdChyZXEuaGVhZGVycy5sb2NhdGlvbiwgb3B0aW9ucyk7XG5cbiAgY29uc3QgZSA9IG5ldyBFcnJvcihgU3RhdHVzIGNvZGU6ICR7Y29kZX1gKTtcbiAgZS5zdGF0dXNDb2RlID0gcmVxLnN0YXR1c0NvZGU7XG4gIHRocm93IGU7XG59O1xuXG4vKipcbiAqIFRlbXBvcmFyeSBoZWxwZXIgdG8gaGVscCBkZXByZWNhdGluZyBhIGZldyBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsdWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBvbGRQYXRoXG4gKiBAcGFyYW0ge3N0cmluZ30gbmV3UGF0aFxuICovXG5leHBvcnRzLmRlcHJlY2F0ZSA9IChvYmosIHByb3AsIHZhbHVlLCBvbGRQYXRoLCBuZXdQYXRoKSA9PiB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIHByb3AsIHtcbiAgICBnZXQ6ICgpID0+IHtcbiAgICAgIGNvbnNvbGUud2FybihgXFxgJHtvbGRQYXRofVxcYCB3aWxsIGJlIHJlbW92ZWQgaW4gYSBuZWFyIGZ1dHVyZSByZWxlYXNlLCBgICsgYHVzZSBcXGAke25ld1BhdGh9XFxgIGluc3RlYWQuYCk7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcbiAgfSk7XG59O1xuXG4vLyBDaGVjayBmb3IgdXBkYXRlcy5cbmNvbnN0IHBrZyA9IHJlcXVpcmUoXCIuLi9wYWNrYWdlLmpzb25cIik7XG5jb25zdCBVUERBVEVfSU5URVJWQUwgPSAxMDAwICogNjAgKiA2MCAqIDEyO1xubGV0IHVwZGF0ZVdhcm5UaW1lcyA9IDA7XG5leHBvcnRzLmxhc3RVcGRhdGVDaGVjayA9IDA7XG5leHBvcnRzLmNoZWNrRm9yVXBkYXRlcyA9ICgpID0+IHtcbiAgaWYgKFxuICAgICFwcm9jZXNzLmVudi5ZVERMX05PX1VQREFURSAmJlxuICAgICFwa2cudmVyc2lvbi5zdGFydHNXaXRoKFwiMC4wLjAtXCIpICYmXG4gICAgRGF0ZS5ub3coKSAtIGV4cG9ydHMubGFzdFVwZGF0ZUNoZWNrID49IFVQREFURV9JTlRFUlZBTFxuICApIHtcbiAgICBleHBvcnRzLmxhc3RVcGRhdGVDaGVjayA9IERhdGUubm93KCk7XG4gICAgcmV0dXJuIGV4cG9ydHNcbiAgICAgIC5yZXF1ZXN0KFwiaHR0cHM6Ly9hcGkuZ2l0aHViLmNvbS9yZXBvcy9kaXN0dWJlanMveXRkbC1jb3JlL2NvbnRlbnRzL3BhY2thZ2UuanNvblwiLCB7XG4gICAgICAgIHJlcXVlc3RPcHRpb25zOiB7XG4gICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgXCJVc2VyLUFnZW50XCI6XG4gICAgICAgICAgICAgIFwiTW96aWxsYS81LjAgKFdpbmRvd3MgTlQgMTAuMDsgV2luNjQ7IHg2NCkgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgQ2hyb21lLzEyOS4wLjAuMCBTYWZhcmkvNTM3LjNcIixcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgfSlcbiAgICAgIC50aGVuKFxuICAgICAgICByZXNwb25zZSA9PiB7XG4gICAgICAgICAgY29uc3QgYnVmID0gQnVmZmVyLmZyb20ocmVzcG9uc2UuY29udGVudCwgcmVzcG9uc2UuZW5jb2RpbmcpO1xuICAgICAgICAgIGNvbnN0IHBrZ0ZpbGUgPSBKU09OLnBhcnNlKGJ1Zi50b1N0cmluZyhcImFzY2lpXCIpKTtcbiAgICAgICAgICBpZiAocGtnRmlsZS52ZXJzaW9uICE9PSBwa2cudmVyc2lvbiAmJiB1cGRhdGVXYXJuVGltZXMrKyA8IDUpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtbGVuXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgICdcXHgxYlszM21XQVJOSU5HOlxceDFCWzBtIEBkaXN0dWJlL3l0ZGwtY29yZSBpcyBvdXQgb2YgZGF0ZSEgVXBkYXRlIHdpdGggXCJucG0gaW5zdGFsbCBAZGlzdHViZS95dGRsLWNvcmVAbGF0ZXN0XCIuJyxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlcnIgPT4ge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcIkVycm9yIGNoZWNraW5nIGZvciB1cGRhdGVzOlwiLCBlcnIubWVzc2FnZSk7XG4gICAgICAgICAgY29uc29sZS53YXJuKFwiWW91IGNhbiBkaXNhYmxlIHRoaXMgY2hlY2sgYnkgc2V0dGluZyB0aGUgYFlURExfTk9fVVBEQVRFYCBlbnYgdmFyaWFibGUuXCIpO1xuICAgICAgICB9LFxuICAgICAgKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5cbi8qKlxuICogR2V0cyByYW5kb20gSVB2NiBBZGRyZXNzIGZyb20gYSBibG9ja1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBpcCB0aGUgSVB2NiBibG9jayBpbiBDSURSLU5vdGF0aW9uXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5jb25zdCBnZXRSYW5kb21JUHY2ID0gaXAgPT4ge1xuICBpZiAoIWlzSVB2NihpcCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIElQdjYgZm9ybWF0XCIpO1xuICB9XG5cbiAgY29uc3QgW3Jhd0FkZHIsIHJhd01hc2tdID0gaXAuc3BsaXQoXCIvXCIpO1xuICBjb25zdCBtYXNrID0gcGFyc2VJbnQocmF3TWFzaywgMTApO1xuXG4gIGlmIChpc05hTihtYXNrKSB8fCBtYXNrID4gMTI4IHx8IG1hc2sgPCAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBJUHY2IHN1Ym5ldCBtYXNrIChtdXN0IGJlIGJldHdlZW4gMSBhbmQgMTI4KVwiKTtcbiAgfVxuXG4gIGNvbnN0IGJhc2UxMGFkZHIgPSBub3JtYWxpemVJUChyYXdBZGRyKTtcblxuICBjb25zdCBmdWxsTWFza0dyb3VwcyA9IE1hdGguZmxvb3IobWFzayAvIDE2KTtcbiAgY29uc3QgcmVtYWluaW5nQml0cyA9IG1hc2sgJSAxNjtcblxuICBjb25zdCByZXN1bHQgPSBuZXcgQXJyYXkoOCkuZmlsbCgwKTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IDg7IGkrKykge1xuICAgIGlmIChpIDwgZnVsbE1hc2tHcm91cHMpIHtcbiAgICAgIHJlc3VsdFtpXSA9IGJhc2UxMGFkZHJbaV07XG4gICAgfSBlbHNlIGlmIChpID09PSBmdWxsTWFza0dyb3VwcyAmJiByZW1haW5pbmdCaXRzID4gMCkge1xuICAgICAgY29uc3QgZ3JvdXBNYXNrID0gMHhmZmZmIDw8ICgxNiAtIHJlbWFpbmluZ0JpdHMpO1xuICAgICAgY29uc3QgcmFuZG9tUGFydCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqICgxIDw8ICgxNiAtIHJlbWFpbmluZ0JpdHMpKSk7XG4gICAgICByZXN1bHRbaV0gPSAoYmFzZTEwYWRkcltpXSAmIGdyb3VwTWFzaykgfCByYW5kb21QYXJ0O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHRbaV0gPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAweDEwMDAwKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0Lm1hcCh4ID0+IHgudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDQsIFwiMFwiKSkuam9pbihcIjpcIik7XG59O1xuXG5jb25zdCBpc0lQdjYgPSBpcCA9PiB7XG4gIGNvbnN0IElQVjZfUkVHRVggPVxuICAgIC9eKD86KD86WzAtOWEtZkEtRl17MSw0fTopezd9WzAtOWEtZkEtRl17MSw0fXwoPzpbMC05YS1mQS1GXXsxLDR9Oil7MSw3fTp8KD86WzAtOWEtZkEtRl17MSw0fTopezEsNn06WzAtOWEtZkEtRl17MSw0fXwoPzpbMC05YS1mQS1GXXsxLDR9Oil7MSw1fSg/OjpbMC05YS1mQS1GXXsxLDR9KXsxLDJ9fCg/OlswLTlhLWZBLUZdezEsNH06KXsxLDR9KD86OlswLTlhLWZBLUZdezEsNH0pezEsM318KD86WzAtOWEtZkEtRl17MSw0fTopezEsM30oPzo6WzAtOWEtZkEtRl17MSw0fSl7MSw0fXwoPzpbMC05YS1mQS1GXXsxLDR9Oil7MSwyfSg/OjpbMC05YS1mQS1GXXsxLDR9KXsxLDV9fFswLTlhLWZBLUZdezEsNH06KD86KD86OlswLTlhLWZBLUZdezEsNH0pezEsNn0pfDooPzooPzo6WzAtOWEtZkEtRl17MSw0fSl7MSw3fXw6KXxmZTgwOig/OjpbMC05YS1mQS1GXXswLDR9KXswLDR9JVswLTlhLXpBLVpdezEsfXw6Oig/OmZmZmYoPzo6MHsxLDR9KXswLDF9Oil7MCwxfSg/Oig/OjI1WzAtNV18KD86MlswLTRdfDF7MCwxfVswLTldKXswLDF9WzAtOV0pXFwuKXszLDN9KD86MjVbMC01XXwoPzoyWzAtNF18MXswLDF9WzAtOV0pezAsMX1bMC05XSl8KD86WzAtOWEtZkEtRl17MSw0fTopezEsNH06KD86KD86MjVbMC01XXwoPzoyWzAtNF18MXswLDF9WzAtOV0pezAsMX1bMC05XSlcXC4pezMsM30oPzoyNVswLTVdfCg/OjJbMC00XXwxezAsMX1bMC05XSl7MCwxfVswLTldKSkoPzpcXC8oPzoxWzAtMV1bMC05XXwxMlswLThdfFsxLTldWzAtOV18WzEtOV0pKT8kLztcbiAgcmV0dXJuIElQVjZfUkVHRVgudGVzdChpcCk7XG59O1xuXG4vKipcbiAqIE5vcm1hbGl6ZXMgYW4gSVB2NiBhZGRyZXNzIGludG8gYW4gYXJyYXkgb2YgOCBpbnRlZ2Vyc1xuICogQHBhcmFtIHtzdHJpbmd9IGlwIC0gSVB2NiBhZGRyZXNzXG4gKiBAcmV0dXJucyB7bnVtYmVyW119IC0gQXJyYXkgb2YgOCBpbnRlZ2VycyByZXByZXNlbnRpbmcgdGhlIGFkZHJlc3NcbiAqL1xuY29uc3Qgbm9ybWFsaXplSVAgPSBpcCA9PiB7XG4gIGNvbnN0IHBhcnRzID0gaXAuc3BsaXQoXCI6OlwiKTtcbiAgbGV0IHN0YXJ0ID0gcGFydHNbMF0gPyBwYXJ0c1swXS5zcGxpdChcIjpcIikgOiBbXTtcbiAgbGV0IGVuZCA9IHBhcnRzWzFdID8gcGFydHNbMV0uc3BsaXQoXCI6XCIpIDogW107XG5cbiAgY29uc3QgbWlzc2luZyA9IDggLSAoc3RhcnQubGVuZ3RoICsgZW5kLmxlbmd0aCk7XG4gIGNvbnN0IHplcm9zID0gbmV3IEFycmF5KG1pc3NpbmcpLmZpbGwoXCIwXCIpO1xuXG4gIGNvbnN0IGZ1bGwgPSBbLi4uc3RhcnQsIC4uLnplcm9zLCAuLi5lbmRdO1xuXG4gIHJldHVybiBmdWxsLm1hcChwYXJ0ID0+IHBhcnNlSW50KHBhcnQgfHwgXCIwXCIsIDE2KSk7XG59O1xuXG5leHBvcnRzLnNhdmVEZWJ1Z0ZpbGUgPSAobmFtZSwgYm9keSkgPT4ge1xuICBpZiAocHJvY2Vzcy5lbnYuWVRETF9OT19ERUJVR19GSUxFKSB7XG4gICAgY29uc29sZS53YXJuKGBcXHgxYlszM21XQVJOSU5HOlxceDFiWzBtIERlYnVnIGZpbGUgc2F2aW5nIGlzIGRpc2FibGVkLiBcIiR7bmFtZX1cImApO1xuICAgIHJldHVybiBib2R5O1xuICB9XG4gIGNvbnN0IGZpbGVuYW1lID0gYCR7K25ldyBEYXRlKCl9LSR7bmFtZX1gO1xuICBjb25zdCBkZWJ1Z1BhdGggPSBwcm9jZXNzLmVudi5ZVERMX0RFQlVHX1BBVEggfHwgJy4nO1xuICB3cml0ZUZpbGVTeW5jKGAke2RlYnVnUGF0aH0vJHtmaWxlbmFtZX1gLCBib2R5KTtcbiAgcmV0dXJuIGZpbGVuYW1lO1xufTtcblxuY29uc3QgZmluZFByb3BLZXlJbnNlbnNpdGl2ZSA9IChvYmosIHByb3ApID0+XG4gIE9iamVjdC5rZXlzKG9iaikuZmluZChwID0+IHAudG9Mb3dlckNhc2UoKSA9PT0gcHJvcC50b0xvd2VyQ2FzZSgpKSB8fCBudWxsO1xuXG5leHBvcnRzLmdldFByb3BJbnNlbnNpdGl2ZSA9IChvYmosIHByb3ApID0+IHtcbiAgY29uc3Qga2V5ID0gZmluZFByb3BLZXlJbnNlbnNpdGl2ZShvYmosIHByb3ApO1xuICByZXR1cm4ga2V5ICYmIG9ialtrZXldO1xufTtcblxuZXhwb3J0cy5zZXRQcm9wSW5zZW5zaXRpdmUgPSAob2JqLCBwcm9wLCB2YWx1ZSkgPT4ge1xuICBjb25zdCBrZXkgPSBmaW5kUHJvcEtleUluc2Vuc2l0aXZlKG9iaiwgcHJvcCk7XG4gIG9ialtrZXkgfHwgcHJvcF0gPSB2YWx1ZTtcbiAgcmV0dXJuIGtleTtcbn07XG5cbmxldCBvbGRDb29raWVXYXJuaW5nID0gdHJ1ZTtcbmxldCBvbGREaXNwYXRjaGVyV2FybmluZyA9IHRydWU7XG5leHBvcnRzLmFwcGx5RGVmYXVsdEFnZW50ID0gb3B0aW9ucyA9PiB7XG4gIGlmICghb3B0aW9ucy5hZ2VudCkge1xuICAgIGNvbnN0IHsgamFyIH0gPSBBR0VOVC5kZWZhdWx0QWdlbnQ7XG4gICAgY29uc3QgYyA9IGV4cG9ydHMuZ2V0UHJvcEluc2Vuc2l0aXZlKG9wdGlvbnMucmVxdWVzdE9wdGlvbnMuaGVhZGVycywgXCJjb29raWVcIik7XG4gICAgaWYgKGMpIHtcbiAgICAgIGphci5yZW1vdmVBbGxDb29raWVzU3luYygpO1xuICAgICAgQUdFTlQuYWRkQ29va2llc0Zyb21TdHJpbmcoamFyLCBjKTtcbiAgICAgIGlmIChvbGRDb29raWVXYXJuaW5nKSB7XG4gICAgICAgIG9sZENvb2tpZVdhcm5pbmcgPSBmYWxzZTtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgIFwiXFx4MWJbMzNtV0FSTklORzpcXHgxQlswbSBVc2luZyBvbGQgY29va2llIGZvcm1hdCwgXCIgK1xuICAgICAgICAgICAgXCJwbGVhc2UgdXNlIHRoZSBuZXcgb25lIGluc3RlYWQuIChodHRwczovL2dpdGh1Yi5jb20vZGlzdHViZWpzL3l0ZGwtY29yZSNjb29raWVzLXN1cHBvcnQpXCIsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnJlcXVlc3RPcHRpb25zLmRpc3BhdGNoZXIgJiYgb2xkRGlzcGF0Y2hlcldhcm5pbmcpIHtcbiAgICAgIG9sZERpc3BhdGNoZXJXYXJuaW5nID0gZmFsc2U7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIFwiXFx4MWJbMzNtV0FSTklORzpcXHgxQlswbSBZb3VyIGRpc3BhdGNoZXIgaXMgb3ZlcnJpZGRlbiBieSBgeXRkbC5BZ2VudGAuIFwiICtcbiAgICAgICAgICBcIlRvIGltcGxlbWVudCB5b3VyIG93biwgY2hlY2sgb3V0IHRoZSBkb2N1bWVudGF0aW9uLiBcIiArXG4gICAgICAgICAgXCIoaHR0cHM6Ly9naXRodWIuY29tL2Rpc3R1YmVqcy95dGRsLWNvcmUjaG93LXRvLWltcGxlbWVudC15dGRsYWdlbnQtd2l0aC15b3VyLW93bi1kaXNwYXRjaGVyKVwiLFxuICAgICAgKTtcbiAgICB9XG4gICAgb3B0aW9ucy5hZ2VudCA9IEFHRU5ULmRlZmF1bHRBZ2VudDtcbiAgfVxufTtcblxubGV0IG9sZExvY2FsQWRkcmVzc1dhcm5pbmcgPSB0cnVlO1xuZXhwb3J0cy5hcHBseU9sZExvY2FsQWRkcmVzcyA9IG9wdGlvbnMgPT4ge1xuICBpZiAoIW9wdGlvbnM/LnJlcXVlc3RPcHRpb25zPy5sb2NhbEFkZHJlc3MgfHwgb3B0aW9ucy5yZXF1ZXN0T3B0aW9ucy5sb2NhbEFkZHJlc3MgPT09IG9wdGlvbnMuYWdlbnQubG9jYWxBZGRyZXNzKVxuICAgIHJldHVybjtcbiAgb3B0aW9ucy5hZ2VudCA9IEFHRU5ULmNyZWF0ZUFnZW50KHVuZGVmaW5lZCwgeyBsb2NhbEFkZHJlc3M6IG9wdGlvbnMucmVxdWVzdE9wdGlvbnMubG9jYWxBZGRyZXNzIH0pO1xuICBpZiAob2xkTG9jYWxBZGRyZXNzV2FybmluZykge1xuICAgIG9sZExvY2FsQWRkcmVzc1dhcm5pbmcgPSBmYWxzZTtcbiAgICBjb25zb2xlLndhcm4oXG4gICAgICBcIlxceDFiWzMzbVdBUk5JTkc6XFx4MUJbMG0gVXNpbmcgb2xkIGxvY2FsQWRkcmVzcyBvcHRpb24sIFwiICtcbiAgICAgICAgXCJwbGVhc2UgYWRkIGl0IHRvIHRoZSBhZ2VudCBvcHRpb25zIGluc3RlYWQuIChodHRwczovL2dpdGh1Yi5jb20vZGlzdHViZWpzL3l0ZGwtY29yZSNpcC1yb3RhdGlvbilcIixcbiAgICApO1xuICB9XG59O1xuXG5sZXQgb2xkSXBSb3RhdGlvbnNXYXJuaW5nID0gdHJ1ZTtcbmV4cG9ydHMuYXBwbHlJUHY2Um90YXRpb25zID0gb3B0aW9ucyA9PiB7XG4gIGlmIChvcHRpb25zLklQdjZCbG9jaykge1xuICAgIG9wdGlvbnMucmVxdWVzdE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLnJlcXVlc3RPcHRpb25zLCB7XG4gICAgICBsb2NhbEFkZHJlc3M6IGdldFJhbmRvbUlQdjYob3B0aW9ucy5JUHY2QmxvY2spLFxuICAgIH0pO1xuICAgIGlmIChvbGRJcFJvdGF0aW9uc1dhcm5pbmcpIHtcbiAgICAgIG9sZElwUm90YXRpb25zV2FybmluZyA9IGZhbHNlO1xuICAgICAgb2xkTG9jYWxBZGRyZXNzV2FybmluZyA9IGZhbHNlO1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBcIlxceDFiWzMzbVdBUk5JTkc6XFx4MUJbMG0gSVB2NkJsb2NrIG9wdGlvbiBpcyBkZXByZWNhdGVkLCBcIiArXG4gICAgICAgICAgXCJwbGVhc2UgY3JlYXRlIHlvdXIgb3duIGlwIHJvdGF0aW9uIGluc3RlYWQuIChodHRwczovL2dpdGh1Yi5jb20vZGlzdHViZWpzL3l0ZGwtY29yZSNpcC1yb3RhdGlvbilcIixcbiAgICAgICk7XG4gICAgfVxuICB9XG59O1xuXG5leHBvcnRzLmFwcGx5RGVmYXVsdEhlYWRlcnMgPSBvcHRpb25zID0+IHtcbiAgb3B0aW9ucy5yZXF1ZXN0T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMucmVxdWVzdE9wdGlvbnMpO1xuICBvcHRpb25zLnJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSBPYmplY3QuYXNzaWduKFxuICAgIHt9LFxuICAgIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtbGVuXG4gICAgICBcIlVzZXItQWdlbnRcIjpcbiAgICAgICAgXCJNb3ppbGxhLzUuMCAoV2luZG93cyBOVCAxMC4wOyBXaW42NDsgeDY0KSBBcHBsZVdlYktpdC81MzcuMzYgKEtIVE1MLCBsaWtlIEdlY2tvKSBDaHJvbWUvODcuMC40MjgwLjEwMSBTYWZhcmkvNTM3LjM2XCIsXG4gICAgfSxcbiAgICBvcHRpb25zLnJlcXVlc3RPcHRpb25zLmhlYWRlcnMsXG4gICk7XG59O1xuXG5leHBvcnRzLmdlbmVyYXRlQ2xpZW50UGxheWJhY2tOb25jZSA9IGxlbmd0aCA9PiB7XG4gIGNvbnN0IENQTl9DSEFSUyA9IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODktX1wiO1xuICByZXR1cm4gQXJyYXkuZnJvbSh7IGxlbmd0aCB9LCAoKSA9PiBDUE5fQ0hBUlNbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogQ1BOX0NIQVJTLmxlbmd0aCldKS5qb2luKFwiXCIpO1xufTtcblxuZXhwb3J0cy5hcHBseVBsYXllckNsaWVudHMgPSBvcHRpb25zID0+IHtcbiAgaWYgKCFvcHRpb25zLnBsYXllckNsaWVudHMgfHwgb3B0aW9ucy5wbGF5ZXJDbGllbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIG9wdGlvbnMucGxheWVyQ2xpZW50cyA9IFtcIldFQl9FTUJFRERFRFwiLCBcIklPU1wiLCBcIkFORFJPSURcIiwgXCJUVlwiXTtcbiAgfVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@distube/ytdl-core/lib/utils.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@distube/ytdl-core/node_modules/agent-base/dist/helpers.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@distube/ytdl-core/node_modules/agent-base/dist/helpers.js ***!
  \*********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.req = exports.json = exports.toBuffer = void 0;\nconst http = __importStar(__webpack_require__(/*! http */ \"http\"));\nconst https = __importStar(__webpack_require__(/*! https */ \"https\"));\nasync function toBuffer(stream) {\n    let length = 0;\n    const chunks = [];\n    for await (const chunk of stream) {\n        length += chunk.length;\n        chunks.push(chunk);\n    }\n    return Buffer.concat(chunks, length);\n}\nexports.toBuffer = toBuffer;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nasync function json(stream) {\n    const buf = await toBuffer(stream);\n    const str = buf.toString('utf8');\n    try {\n        return JSON.parse(str);\n    }\n    catch (_err) {\n        const err = _err;\n        err.message += ` (input: ${str})`;\n        throw err;\n    }\n}\nexports.json = json;\nfunction req(url, opts = {}) {\n    const href = typeof url === 'string' ? url : url.href;\n    const req = (href.startsWith('https:') ? https : http).request(url, opts);\n    const promise = new Promise((resolve, reject) => {\n        req\n            .once('response', resolve)\n            .once('error', reject)\n            .end();\n    });\n    req.then = promise.then.bind(promise);\n    return req;\n}\nexports.req = req;\n//# sourceMappingURL=helpers.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGRpc3R1YmUveXRkbC1jb3JlL25vZGVfbW9kdWxlcy9hZ2VudC1iYXNlL2Rpc3QvaGVscGVycy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMENBQTBDLDRCQUE0QjtBQUN0RSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsV0FBVyxHQUFHLFlBQVksR0FBRyxnQkFBZ0I7QUFDN0MsMEJBQTBCLG1CQUFPLENBQUMsa0JBQU07QUFDeEMsMkJBQTJCLG1CQUFPLENBQUMsb0JBQU87QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxJQUFJO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWiwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8veXQtZG93bmxvYWRlci8uL25vZGVfbW9kdWxlcy9AZGlzdHViZS95dGRsLWNvcmUvbm9kZV9tb2R1bGVzL2FnZW50LWJhc2UvZGlzdC9oZWxwZXJzLmpzPzMzZTIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucmVxID0gZXhwb3J0cy5qc29uID0gZXhwb3J0cy50b0J1ZmZlciA9IHZvaWQgMDtcbmNvbnN0IGh0dHAgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcImh0dHBcIikpO1xuY29uc3QgaHR0cHMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcImh0dHBzXCIpKTtcbmFzeW5jIGZ1bmN0aW9uIHRvQnVmZmVyKHN0cmVhbSkge1xuICAgIGxldCBsZW5ndGggPSAwO1xuICAgIGNvbnN0IGNodW5rcyA9IFtdO1xuICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2Ygc3RyZWFtKSB7XG4gICAgICAgIGxlbmd0aCArPSBjaHVuay5sZW5ndGg7XG4gICAgICAgIGNodW5rcy5wdXNoKGNodW5rKTtcbiAgICB9XG4gICAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoY2h1bmtzLCBsZW5ndGgpO1xufVxuZXhwb3J0cy50b0J1ZmZlciA9IHRvQnVmZmVyO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmFzeW5jIGZ1bmN0aW9uIGpzb24oc3RyZWFtKSB7XG4gICAgY29uc3QgYnVmID0gYXdhaXQgdG9CdWZmZXIoc3RyZWFtKTtcbiAgICBjb25zdCBzdHIgPSBidWYudG9TdHJpbmcoJ3V0ZjgnKTtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShzdHIpO1xuICAgIH1cbiAgICBjYXRjaCAoX2Vycikge1xuICAgICAgICBjb25zdCBlcnIgPSBfZXJyO1xuICAgICAgICBlcnIubWVzc2FnZSArPSBgIChpbnB1dDogJHtzdHJ9KWA7XG4gICAgICAgIHRocm93IGVycjtcbiAgICB9XG59XG5leHBvcnRzLmpzb24gPSBqc29uO1xuZnVuY3Rpb24gcmVxKHVybCwgb3B0cyA9IHt9KSB7XG4gICAgY29uc3QgaHJlZiA9IHR5cGVvZiB1cmwgPT09ICdzdHJpbmcnID8gdXJsIDogdXJsLmhyZWY7XG4gICAgY29uc3QgcmVxID0gKGhyZWYuc3RhcnRzV2l0aCgnaHR0cHM6JykgPyBodHRwcyA6IGh0dHApLnJlcXVlc3QodXJsLCBvcHRzKTtcbiAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICByZXFcbiAgICAgICAgICAgIC5vbmNlKCdyZXNwb25zZScsIHJlc29sdmUpXG4gICAgICAgICAgICAub25jZSgnZXJyb3InLCByZWplY3QpXG4gICAgICAgICAgICAuZW5kKCk7XG4gICAgfSk7XG4gICAgcmVxLnRoZW4gPSBwcm9taXNlLnRoZW4uYmluZChwcm9taXNlKTtcbiAgICByZXR1cm4gcmVxO1xufVxuZXhwb3J0cy5yZXEgPSByZXE7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oZWxwZXJzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@distube/ytdl-core/node_modules/agent-base/dist/helpers.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@distube/ytdl-core/node_modules/agent-base/dist/index.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@distube/ytdl-core/node_modules/agent-base/dist/index.js ***!
  \*******************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Agent = void 0;\nconst net = __importStar(__webpack_require__(/*! net */ \"net\"));\nconst http = __importStar(__webpack_require__(/*! http */ \"http\"));\nconst https_1 = __webpack_require__(/*! https */ \"https\");\n__exportStar(__webpack_require__(/*! ./helpers */ \"(rsc)/./node_modules/@distube/ytdl-core/node_modules/agent-base/dist/helpers.js\"), exports);\nconst INTERNAL = Symbol('AgentBaseInternalState');\nclass Agent extends http.Agent {\n    constructor(opts) {\n        super(opts);\n        this[INTERNAL] = {};\n    }\n    /**\n     * Determine whether this is an `http` or `https` request.\n     */\n    isSecureEndpoint(options) {\n        if (options) {\n            // First check the `secureEndpoint` property explicitly, since this\n            // means that a parent `Agent` is \"passing through\" to this instance.\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            if (typeof options.secureEndpoint === 'boolean') {\n                return options.secureEndpoint;\n            }\n            // If no explicit `secure` endpoint, check if `protocol` property is\n            // set. This will usually be the case since using a full string URL\n            // or `URL` instance should be the most common usage.\n            if (typeof options.protocol === 'string') {\n                return options.protocol === 'https:';\n            }\n        }\n        // Finally, if no `protocol` property was set, then fall back to\n        // checking the stack trace of the current call stack, and try to\n        // detect the \"https\" module.\n        const { stack } = new Error();\n        if (typeof stack !== 'string')\n            return false;\n        return stack\n            .split('\\n')\n            .some((l) => l.indexOf('(https.js:') !== -1 ||\n            l.indexOf('node:https:') !== -1);\n    }\n    // In order to support async signatures in `connect()` and Node's native\n    // connection pooling in `http.Agent`, the array of sockets for each origin\n    // has to be updated synchronously. This is so the length of the array is\n    // accurate when `addRequest()` is next called. We achieve this by creating a\n    // fake socket and adding it to `sockets[origin]` and incrementing\n    // `totalSocketCount`.\n    incrementSockets(name) {\n        // If `maxSockets` and `maxTotalSockets` are both Infinity then there is no\n        // need to create a fake socket because Node.js native connection pooling\n        // will never be invoked.\n        if (this.maxSockets === Infinity && this.maxTotalSockets === Infinity) {\n            return null;\n        }\n        // All instances of `sockets` are expected TypeScript errors. The\n        // alternative is to add it as a private property of this class but that\n        // will break TypeScript subclassing.\n        if (!this.sockets[name]) {\n            // @ts-expect-error `sockets` is readonly in `@types/node`\n            this.sockets[name] = [];\n        }\n        const fakeSocket = new net.Socket({ writable: false });\n        this.sockets[name].push(fakeSocket);\n        // @ts-expect-error `totalSocketCount` isn't defined in `@types/node`\n        this.totalSocketCount++;\n        return fakeSocket;\n    }\n    decrementSockets(name, socket) {\n        if (!this.sockets[name] || socket === null) {\n            return;\n        }\n        const sockets = this.sockets[name];\n        const index = sockets.indexOf(socket);\n        if (index !== -1) {\n            sockets.splice(index, 1);\n            // @ts-expect-error  `totalSocketCount` isn't defined in `@types/node`\n            this.totalSocketCount--;\n            if (sockets.length === 0) {\n                // @ts-expect-error `sockets` is readonly in `@types/node`\n                delete this.sockets[name];\n            }\n        }\n    }\n    // In order to properly update the socket pool, we need to call `getName()` on\n    // the core `https.Agent` if it is a secureEndpoint.\n    getName(options) {\n        const secureEndpoint = this.isSecureEndpoint(options);\n        if (secureEndpoint) {\n            // @ts-expect-error `getName()` isn't defined in `@types/node`\n            return https_1.Agent.prototype.getName.call(this, options);\n        }\n        // @ts-expect-error `getName()` isn't defined in `@types/node`\n        return super.getName(options);\n    }\n    createSocket(req, options, cb) {\n        const connectOpts = {\n            ...options,\n            secureEndpoint: this.isSecureEndpoint(options),\n        };\n        const name = this.getName(connectOpts);\n        const fakeSocket = this.incrementSockets(name);\n        Promise.resolve()\n            .then(() => this.connect(req, connectOpts))\n            .then((socket) => {\n            this.decrementSockets(name, fakeSocket);\n            if (socket instanceof http.Agent) {\n                try {\n                    // @ts-expect-error `addRequest()` isn't defined in `@types/node`\n                    return socket.addRequest(req, connectOpts);\n                }\n                catch (err) {\n                    return cb(err);\n                }\n            }\n            this[INTERNAL].currentSocket = socket;\n            // @ts-expect-error `createSocket()` isn't defined in `@types/node`\n            super.createSocket(req, options, cb);\n        }, (err) => {\n            this.decrementSockets(name, fakeSocket);\n            cb(err);\n        });\n    }\n    createConnection() {\n        const socket = this[INTERNAL].currentSocket;\n        this[INTERNAL].currentSocket = undefined;\n        if (!socket) {\n            throw new Error('No socket was returned in the `connect()` function');\n        }\n        return socket;\n    }\n    get defaultPort() {\n        return (this[INTERNAL].defaultPort ??\n            (this.protocol === 'https:' ? 443 : 80));\n    }\n    set defaultPort(v) {\n        if (this[INTERNAL]) {\n            this[INTERNAL].defaultPort = v;\n        }\n    }\n    get protocol() {\n        return (this[INTERNAL].protocol ??\n            (this.isSecureEndpoint() ? 'https:' : 'http:'));\n    }\n    set protocol(v) {\n        if (this[INTERNAL]) {\n            this[INTERNAL].protocol = v;\n        }\n    }\n}\nexports.Agent = Agent;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGRpc3R1YmUveXRkbC1jb3JlL25vZGVfbW9kdWxlcy9hZ2VudC1iYXNlL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDBDQUEwQyw0QkFBNEI7QUFDdEUsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGFBQWE7QUFDYix5QkFBeUIsbUJBQU8sQ0FBQyxnQkFBSztBQUN0QywwQkFBMEIsbUJBQU8sQ0FBQyxrQkFBTTtBQUN4QyxnQkFBZ0IsbUJBQU8sQ0FBQyxvQkFBTztBQUMvQixhQUFhLG1CQUFPLENBQUMsa0dBQVc7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLGlCQUFpQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8veXQtZG93bmxvYWRlci8uL25vZGVfbW9kdWxlcy9AZGlzdHViZS95dGRsLWNvcmUvbm9kZV9tb2R1bGVzL2FnZW50LWJhc2UvZGlzdC9pbmRleC5qcz84Y2NmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BZ2VudCA9IHZvaWQgMDtcbmNvbnN0IG5ldCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwibmV0XCIpKTtcbmNvbnN0IGh0dHAgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcImh0dHBcIikpO1xuY29uc3QgaHR0cHNfMSA9IHJlcXVpcmUoXCJodHRwc1wiKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9oZWxwZXJzXCIpLCBleHBvcnRzKTtcbmNvbnN0IElOVEVSTkFMID0gU3ltYm9sKCdBZ2VudEJhc2VJbnRlcm5hbFN0YXRlJyk7XG5jbGFzcyBBZ2VudCBleHRlbmRzIGh0dHAuQWdlbnQge1xuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICAgICAgc3VwZXIob3B0cyk7XG4gICAgICAgIHRoaXNbSU5URVJOQUxdID0ge307XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERldGVybWluZSB3aGV0aGVyIHRoaXMgaXMgYW4gYGh0dHBgIG9yIGBodHRwc2AgcmVxdWVzdC5cbiAgICAgKi9cbiAgICBpc1NlY3VyZUVuZHBvaW50KG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIC8vIEZpcnN0IGNoZWNrIHRoZSBgc2VjdXJlRW5kcG9pbnRgIHByb3BlcnR5IGV4cGxpY2l0bHksIHNpbmNlIHRoaXNcbiAgICAgICAgICAgIC8vIG1lYW5zIHRoYXQgYSBwYXJlbnQgYEFnZW50YCBpcyBcInBhc3NpbmcgdGhyb3VnaFwiIHRvIHRoaXMgaW5zdGFuY2UuXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLnNlY3VyZUVuZHBvaW50ID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5zZWN1cmVFbmRwb2ludDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIG5vIGV4cGxpY2l0IGBzZWN1cmVgIGVuZHBvaW50LCBjaGVjayBpZiBgcHJvdG9jb2xgIHByb3BlcnR5IGlzXG4gICAgICAgICAgICAvLyBzZXQuIFRoaXMgd2lsbCB1c3VhbGx5IGJlIHRoZSBjYXNlIHNpbmNlIHVzaW5nIGEgZnVsbCBzdHJpbmcgVVJMXG4gICAgICAgICAgICAvLyBvciBgVVJMYCBpbnN0YW5jZSBzaG91bGQgYmUgdGhlIG1vc3QgY29tbW9uIHVzYWdlLlxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLnByb3RvY29sID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zLnByb3RvY29sID09PSAnaHR0cHM6JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBGaW5hbGx5LCBpZiBubyBgcHJvdG9jb2xgIHByb3BlcnR5IHdhcyBzZXQsIHRoZW4gZmFsbCBiYWNrIHRvXG4gICAgICAgIC8vIGNoZWNraW5nIHRoZSBzdGFjayB0cmFjZSBvZiB0aGUgY3VycmVudCBjYWxsIHN0YWNrLCBhbmQgdHJ5IHRvXG4gICAgICAgIC8vIGRldGVjdCB0aGUgXCJodHRwc1wiIG1vZHVsZS5cbiAgICAgICAgY29uc3QgeyBzdGFjayB9ID0gbmV3IEVycm9yKCk7XG4gICAgICAgIGlmICh0eXBlb2Ygc3RhY2sgIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gc3RhY2tcbiAgICAgICAgICAgIC5zcGxpdCgnXFxuJylcbiAgICAgICAgICAgIC5zb21lKChsKSA9PiBsLmluZGV4T2YoJyhodHRwcy5qczonKSAhPT0gLTEgfHxcbiAgICAgICAgICAgIGwuaW5kZXhPZignbm9kZTpodHRwczonKSAhPT0gLTEpO1xuICAgIH1cbiAgICAvLyBJbiBvcmRlciB0byBzdXBwb3J0IGFzeW5jIHNpZ25hdHVyZXMgaW4gYGNvbm5lY3QoKWAgYW5kIE5vZGUncyBuYXRpdmVcbiAgICAvLyBjb25uZWN0aW9uIHBvb2xpbmcgaW4gYGh0dHAuQWdlbnRgLCB0aGUgYXJyYXkgb2Ygc29ja2V0cyBmb3IgZWFjaCBvcmlnaW5cbiAgICAvLyBoYXMgdG8gYmUgdXBkYXRlZCBzeW5jaHJvbm91c2x5LiBUaGlzIGlzIHNvIHRoZSBsZW5ndGggb2YgdGhlIGFycmF5IGlzXG4gICAgLy8gYWNjdXJhdGUgd2hlbiBgYWRkUmVxdWVzdCgpYCBpcyBuZXh0IGNhbGxlZC4gV2UgYWNoaWV2ZSB0aGlzIGJ5IGNyZWF0aW5nIGFcbiAgICAvLyBmYWtlIHNvY2tldCBhbmQgYWRkaW5nIGl0IHRvIGBzb2NrZXRzW29yaWdpbl1gIGFuZCBpbmNyZW1lbnRpbmdcbiAgICAvLyBgdG90YWxTb2NrZXRDb3VudGAuXG4gICAgaW5jcmVtZW50U29ja2V0cyhuYW1lKSB7XG4gICAgICAgIC8vIElmIGBtYXhTb2NrZXRzYCBhbmQgYG1heFRvdGFsU29ja2V0c2AgYXJlIGJvdGggSW5maW5pdHkgdGhlbiB0aGVyZSBpcyBub1xuICAgICAgICAvLyBuZWVkIHRvIGNyZWF0ZSBhIGZha2Ugc29ja2V0IGJlY2F1c2UgTm9kZS5qcyBuYXRpdmUgY29ubmVjdGlvbiBwb29saW5nXG4gICAgICAgIC8vIHdpbGwgbmV2ZXIgYmUgaW52b2tlZC5cbiAgICAgICAgaWYgKHRoaXMubWF4U29ja2V0cyA9PT0gSW5maW5pdHkgJiYgdGhpcy5tYXhUb3RhbFNvY2tldHMgPT09IEluZmluaXR5KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBBbGwgaW5zdGFuY2VzIG9mIGBzb2NrZXRzYCBhcmUgZXhwZWN0ZWQgVHlwZVNjcmlwdCBlcnJvcnMuIFRoZVxuICAgICAgICAvLyBhbHRlcm5hdGl2ZSBpcyB0byBhZGQgaXQgYXMgYSBwcml2YXRlIHByb3BlcnR5IG9mIHRoaXMgY2xhc3MgYnV0IHRoYXRcbiAgICAgICAgLy8gd2lsbCBicmVhayBUeXBlU2NyaXB0IHN1YmNsYXNzaW5nLlxuICAgICAgICBpZiAoIXRoaXMuc29ja2V0c1tuYW1lXSkge1xuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBgc29ja2V0c2AgaXMgcmVhZG9ubHkgaW4gYEB0eXBlcy9ub2RlYFxuICAgICAgICAgICAgdGhpcy5zb2NrZXRzW25hbWVdID0gW107XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmFrZVNvY2tldCA9IG5ldyBuZXQuU29ja2V0KHsgd3JpdGFibGU6IGZhbHNlIH0pO1xuICAgICAgICB0aGlzLnNvY2tldHNbbmFtZV0ucHVzaChmYWtlU29ja2V0KTtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBgdG90YWxTb2NrZXRDb3VudGAgaXNuJ3QgZGVmaW5lZCBpbiBgQHR5cGVzL25vZGVgXG4gICAgICAgIHRoaXMudG90YWxTb2NrZXRDb3VudCsrO1xuICAgICAgICByZXR1cm4gZmFrZVNvY2tldDtcbiAgICB9XG4gICAgZGVjcmVtZW50U29ja2V0cyhuYW1lLCBzb2NrZXQpIHtcbiAgICAgICAgaWYgKCF0aGlzLnNvY2tldHNbbmFtZV0gfHwgc29ja2V0ID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc29ja2V0cyA9IHRoaXMuc29ja2V0c1tuYW1lXTtcbiAgICAgICAgY29uc3QgaW5kZXggPSBzb2NrZXRzLmluZGV4T2Yoc29ja2V0KTtcbiAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgc29ja2V0cy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciAgYHRvdGFsU29ja2V0Q291bnRgIGlzbid0IGRlZmluZWQgaW4gYEB0eXBlcy9ub2RlYFxuICAgICAgICAgICAgdGhpcy50b3RhbFNvY2tldENvdW50LS07XG4gICAgICAgICAgICBpZiAoc29ja2V0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGBzb2NrZXRzYCBpcyByZWFkb25seSBpbiBgQHR5cGVzL25vZGVgXG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuc29ja2V0c1tuYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBJbiBvcmRlciB0byBwcm9wZXJseSB1cGRhdGUgdGhlIHNvY2tldCBwb29sLCB3ZSBuZWVkIHRvIGNhbGwgYGdldE5hbWUoKWAgb25cbiAgICAvLyB0aGUgY29yZSBgaHR0cHMuQWdlbnRgIGlmIGl0IGlzIGEgc2VjdXJlRW5kcG9pbnQuXG4gICAgZ2V0TmFtZShvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHNlY3VyZUVuZHBvaW50ID0gdGhpcy5pc1NlY3VyZUVuZHBvaW50KG9wdGlvbnMpO1xuICAgICAgICBpZiAoc2VjdXJlRW5kcG9pbnQpIHtcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgYGdldE5hbWUoKWAgaXNuJ3QgZGVmaW5lZCBpbiBgQHR5cGVzL25vZGVgXG4gICAgICAgICAgICByZXR1cm4gaHR0cHNfMS5BZ2VudC5wcm90b3R5cGUuZ2V0TmFtZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgYGdldE5hbWUoKWAgaXNuJ3QgZGVmaW5lZCBpbiBgQHR5cGVzL25vZGVgXG4gICAgICAgIHJldHVybiBzdXBlci5nZXROYW1lKG9wdGlvbnMpO1xuICAgIH1cbiAgICBjcmVhdGVTb2NrZXQocmVxLCBvcHRpb25zLCBjYikge1xuICAgICAgICBjb25zdCBjb25uZWN0T3B0cyA9IHtcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICBzZWN1cmVFbmRwb2ludDogdGhpcy5pc1NlY3VyZUVuZHBvaW50KG9wdGlvbnMpLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBuYW1lID0gdGhpcy5nZXROYW1lKGNvbm5lY3RPcHRzKTtcbiAgICAgICAgY29uc3QgZmFrZVNvY2tldCA9IHRoaXMuaW5jcmVtZW50U29ja2V0cyhuYW1lKTtcbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKClcbiAgICAgICAgICAgIC50aGVuKCgpID0+IHRoaXMuY29ubmVjdChyZXEsIGNvbm5lY3RPcHRzKSlcbiAgICAgICAgICAgIC50aGVuKChzb2NrZXQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZGVjcmVtZW50U29ja2V0cyhuYW1lLCBmYWtlU29ja2V0KTtcbiAgICAgICAgICAgIGlmIChzb2NrZXQgaW5zdGFuY2VvZiBodHRwLkFnZW50KSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBgYWRkUmVxdWVzdCgpYCBpc24ndCBkZWZpbmVkIGluIGBAdHlwZXMvbm9kZWBcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNvY2tldC5hZGRSZXF1ZXN0KHJlcSwgY29ubmVjdE9wdHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYihlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXNbSU5URVJOQUxdLmN1cnJlbnRTb2NrZXQgPSBzb2NrZXQ7XG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGBjcmVhdGVTb2NrZXQoKWAgaXNuJ3QgZGVmaW5lZCBpbiBgQHR5cGVzL25vZGVgXG4gICAgICAgICAgICBzdXBlci5jcmVhdGVTb2NrZXQocmVxLCBvcHRpb25zLCBjYik7XG4gICAgICAgIH0sIChlcnIpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZGVjcmVtZW50U29ja2V0cyhuYW1lLCBmYWtlU29ja2V0KTtcbiAgICAgICAgICAgIGNiKGVycik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjcmVhdGVDb25uZWN0aW9uKCkge1xuICAgICAgICBjb25zdCBzb2NrZXQgPSB0aGlzW0lOVEVSTkFMXS5jdXJyZW50U29ja2V0O1xuICAgICAgICB0aGlzW0lOVEVSTkFMXS5jdXJyZW50U29ja2V0ID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoIXNvY2tldCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBzb2NrZXQgd2FzIHJldHVybmVkIGluIHRoZSBgY29ubmVjdCgpYCBmdW5jdGlvbicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzb2NrZXQ7XG4gICAgfVxuICAgIGdldCBkZWZhdWx0UG9ydCgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzW0lOVEVSTkFMXS5kZWZhdWx0UG9ydCA/P1xuICAgICAgICAgICAgKHRoaXMucHJvdG9jb2wgPT09ICdodHRwczonID8gNDQzIDogODApKTtcbiAgICB9XG4gICAgc2V0IGRlZmF1bHRQb3J0KHYpIHtcbiAgICAgICAgaWYgKHRoaXNbSU5URVJOQUxdKSB7XG4gICAgICAgICAgICB0aGlzW0lOVEVSTkFMXS5kZWZhdWx0UG9ydCA9IHY7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IHByb3RvY29sKCkge1xuICAgICAgICByZXR1cm4gKHRoaXNbSU5URVJOQUxdLnByb3RvY29sID8/XG4gICAgICAgICAgICAodGhpcy5pc1NlY3VyZUVuZHBvaW50KCkgPyAnaHR0cHM6JyA6ICdodHRwOicpKTtcbiAgICB9XG4gICAgc2V0IHByb3RvY29sKHYpIHtcbiAgICAgICAgaWYgKHRoaXNbSU5URVJOQUxdKSB7XG4gICAgICAgICAgICB0aGlzW0lOVEVSTkFMXS5wcm90b2NvbCA9IHY7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkFnZW50ID0gQWdlbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@distube/ytdl-core/node_modules/agent-base/dist/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@distube/ytdl-core/node_modules/https-proxy-agent/dist/index.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@distube/ytdl-core/node_modules/https-proxy-agent/dist/index.js ***!
  \**************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.HttpsProxyAgent = void 0;\nconst net = __importStar(__webpack_require__(/*! net */ \"net\"));\nconst tls = __importStar(__webpack_require__(/*! tls */ \"tls\"));\nconst assert_1 = __importDefault(__webpack_require__(/*! assert */ \"assert\"));\nconst debug_1 = __importDefault(__webpack_require__(/*! debug */ \"(rsc)/./node_modules/debug/src/index.js\"));\nconst agent_base_1 = __webpack_require__(/*! agent-base */ \"(rsc)/./node_modules/@distube/ytdl-core/node_modules/agent-base/dist/index.js\");\nconst url_1 = __webpack_require__(/*! url */ \"url\");\nconst parse_proxy_response_1 = __webpack_require__(/*! ./parse-proxy-response */ \"(rsc)/./node_modules/@distube/ytdl-core/node_modules/https-proxy-agent/dist/parse-proxy-response.js\");\nconst debug = (0, debug_1.default)('https-proxy-agent');\nconst setServernameFromNonIpHost = (options) => {\n    if (options.servername === undefined &&\n        options.host &&\n        !net.isIP(options.host)) {\n        return {\n            ...options,\n            servername: options.host,\n        };\n    }\n    return options;\n};\n/**\n * The `HttpsProxyAgent` implements an HTTP Agent subclass that connects to\n * the specified \"HTTP(s) proxy server\" in order to proxy HTTPS requests.\n *\n * Outgoing HTTP requests are first tunneled through the proxy server using the\n * `CONNECT` HTTP request method to establish a connection to the proxy server,\n * and then the proxy server connects to the destination target and issues the\n * HTTP request from the proxy server.\n *\n * `https:` requests have their socket connection upgraded to TLS once\n * the connection to the proxy server has been established.\n */\nclass HttpsProxyAgent extends agent_base_1.Agent {\n    constructor(proxy, opts) {\n        super(opts);\n        this.options = { path: undefined };\n        this.proxy = typeof proxy === 'string' ? new url_1.URL(proxy) : proxy;\n        this.proxyHeaders = opts?.headers ?? {};\n        debug('Creating new HttpsProxyAgent instance: %o', this.proxy.href);\n        // Trim off the brackets from IPv6 addresses\n        const host = (this.proxy.hostname || this.proxy.host).replace(/^\\[|\\]$/g, '');\n        const port = this.proxy.port\n            ? parseInt(this.proxy.port, 10)\n            : this.proxy.protocol === 'https:'\n                ? 443\n                : 80;\n        this.connectOpts = {\n            // Attempt to negotiate http/1.1 for proxy servers that support http/2\n            ALPNProtocols: ['http/1.1'],\n            ...(opts ? omit(opts, 'headers') : null),\n            host,\n            port,\n        };\n    }\n    /**\n     * Called when the node-core HTTP client library is creating a\n     * new HTTP request.\n     */\n    async connect(req, opts) {\n        const { proxy } = this;\n        if (!opts.host) {\n            throw new TypeError('No \"host\" provided');\n        }\n        // Create a socket connection to the proxy server.\n        let socket;\n        if (proxy.protocol === 'https:') {\n            debug('Creating `tls.Socket`: %o', this.connectOpts);\n            socket = tls.connect(setServernameFromNonIpHost(this.connectOpts));\n        }\n        else {\n            debug('Creating `net.Socket`: %o', this.connectOpts);\n            socket = net.connect(this.connectOpts);\n        }\n        const headers = typeof this.proxyHeaders === 'function'\n            ? this.proxyHeaders()\n            : { ...this.proxyHeaders };\n        const host = net.isIPv6(opts.host) ? `[${opts.host}]` : opts.host;\n        let payload = `CONNECT ${host}:${opts.port} HTTP/1.1\\r\\n`;\n        // Inject the `Proxy-Authorization` header if necessary.\n        if (proxy.username || proxy.password) {\n            const auth = `${decodeURIComponent(proxy.username)}:${decodeURIComponent(proxy.password)}`;\n            headers['Proxy-Authorization'] = `Basic ${Buffer.from(auth).toString('base64')}`;\n        }\n        headers.Host = `${host}:${opts.port}`;\n        if (!headers['Proxy-Connection']) {\n            headers['Proxy-Connection'] = this.keepAlive\n                ? 'Keep-Alive'\n                : 'close';\n        }\n        for (const name of Object.keys(headers)) {\n            payload += `${name}: ${headers[name]}\\r\\n`;\n        }\n        const proxyResponsePromise = (0, parse_proxy_response_1.parseProxyResponse)(socket);\n        socket.write(`${payload}\\r\\n`);\n        const { connect, buffered } = await proxyResponsePromise;\n        req.emit('proxyConnect', connect);\n        this.emit('proxyConnect', connect, req);\n        if (connect.statusCode === 200) {\n            req.once('socket', resume);\n            if (opts.secureEndpoint) {\n                // The proxy is connecting to a TLS server, so upgrade\n                // this socket connection to a TLS connection.\n                debug('Upgrading socket connection to TLS');\n                return tls.connect({\n                    ...omit(setServernameFromNonIpHost(opts), 'host', 'path', 'port'),\n                    socket,\n                });\n            }\n            return socket;\n        }\n        // Some other status code that's not 200... need to re-play the HTTP\n        // header \"data\" events onto the socket once the HTTP machinery is\n        // attached so that the node core `http` can parse and handle the\n        // error status code.\n        // Close the original socket, and a new \"fake\" socket is returned\n        // instead, so that the proxy doesn't get the HTTP request\n        // written to it (which may contain `Authorization` headers or other\n        // sensitive data).\n        //\n        // See: https://hackerone.com/reports/541502\n        socket.destroy();\n        const fakeSocket = new net.Socket({ writable: false });\n        fakeSocket.readable = true;\n        // Need to wait for the \"socket\" event to re-play the \"data\" events.\n        req.once('socket', (s) => {\n            debug('Replaying proxy buffer for failed request');\n            (0, assert_1.default)(s.listenerCount('data') > 0);\n            // Replay the \"buffered\" Buffer onto the fake `socket`, since at\n            // this point the HTTP module machinery has been hooked up for\n            // the user.\n            s.push(buffered);\n            s.push(null);\n        });\n        return fakeSocket;\n    }\n}\nHttpsProxyAgent.protocols = ['http', 'https'];\nexports.HttpsProxyAgent = HttpsProxyAgent;\nfunction resume(socket) {\n    socket.resume();\n}\nfunction omit(obj, ...keys) {\n    const ret = {};\n    let key;\n    for (key in obj) {\n        if (!keys.includes(key)) {\n            ret[key] = obj[key];\n        }\n    }\n    return ret;\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGRpc3R1YmUveXRkbC1jb3JlL25vZGVfbW9kdWxlcy9odHRwcy1wcm94eS1hZ2VudC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSwwQ0FBMEMsNEJBQTRCO0FBQ3RFLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHVCQUF1QjtBQUN2Qix5QkFBeUIsbUJBQU8sQ0FBQyxnQkFBSztBQUN0Qyx5QkFBeUIsbUJBQU8sQ0FBQyxnQkFBSztBQUN0QyxpQ0FBaUMsbUJBQU8sQ0FBQyxzQkFBUTtBQUNqRCxnQ0FBZ0MsbUJBQU8sQ0FBQyxzREFBTztBQUMvQyxxQkFBcUIsbUJBQU8sQ0FBQyxpR0FBWTtBQUN6QyxjQUFjLG1CQUFPLENBQUMsZ0JBQUs7QUFDM0IsK0JBQStCLG1CQUFPLENBQUMsbUlBQXdCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGlEQUFpRCxVQUFVO0FBQzNELGlDQUFpQyxLQUFLLEdBQUcsV0FBVztBQUNwRDtBQUNBO0FBQ0EsNEJBQTRCLG1DQUFtQyxHQUFHLG1DQUFtQztBQUNyRyxzREFBc0QscUNBQXFDO0FBQzNGO0FBQ0EsMEJBQTBCLEtBQUssR0FBRyxVQUFVO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixLQUFLLElBQUksY0FBYztBQUNqRDtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEMsZ0JBQWdCLG9CQUFvQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsaUJBQWlCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly95dC1kb3dubG9hZGVyLy4vbm9kZV9tb2R1bGVzL0BkaXN0dWJlL3l0ZGwtY29yZS9ub2RlX21vZHVsZXMvaHR0cHMtcHJveHktYWdlbnQvZGlzdC9pbmRleC5qcz80YmY5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkh0dHBzUHJveHlBZ2VudCA9IHZvaWQgMDtcbmNvbnN0IG5ldCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwibmV0XCIpKTtcbmNvbnN0IHRscyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwidGxzXCIpKTtcbmNvbnN0IGFzc2VydF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJhc3NlcnRcIikpO1xuY29uc3QgZGVidWdfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiZGVidWdcIikpO1xuY29uc3QgYWdlbnRfYmFzZV8xID0gcmVxdWlyZShcImFnZW50LWJhc2VcIik7XG5jb25zdCB1cmxfMSA9IHJlcXVpcmUoXCJ1cmxcIik7XG5jb25zdCBwYXJzZV9wcm94eV9yZXNwb25zZV8xID0gcmVxdWlyZShcIi4vcGFyc2UtcHJveHktcmVzcG9uc2VcIik7XG5jb25zdCBkZWJ1ZyA9ICgwLCBkZWJ1Z18xLmRlZmF1bHQpKCdodHRwcy1wcm94eS1hZ2VudCcpO1xuY29uc3Qgc2V0U2VydmVybmFtZUZyb21Ob25JcEhvc3QgPSAob3B0aW9ucykgPT4ge1xuICAgIGlmIChvcHRpb25zLnNlcnZlcm5hbWUgPT09IHVuZGVmaW5lZCAmJlxuICAgICAgICBvcHRpb25zLmhvc3QgJiZcbiAgICAgICAgIW5ldC5pc0lQKG9wdGlvbnMuaG9zdCkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICBzZXJ2ZXJuYW1lOiBvcHRpb25zLmhvc3QsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBvcHRpb25zO1xufTtcbi8qKlxuICogVGhlIGBIdHRwc1Byb3h5QWdlbnRgIGltcGxlbWVudHMgYW4gSFRUUCBBZ2VudCBzdWJjbGFzcyB0aGF0IGNvbm5lY3RzIHRvXG4gKiB0aGUgc3BlY2lmaWVkIFwiSFRUUChzKSBwcm94eSBzZXJ2ZXJcIiBpbiBvcmRlciB0byBwcm94eSBIVFRQUyByZXF1ZXN0cy5cbiAqXG4gKiBPdXRnb2luZyBIVFRQIHJlcXVlc3RzIGFyZSBmaXJzdCB0dW5uZWxlZCB0aHJvdWdoIHRoZSBwcm94eSBzZXJ2ZXIgdXNpbmcgdGhlXG4gKiBgQ09OTkVDVGAgSFRUUCByZXF1ZXN0IG1ldGhvZCB0byBlc3RhYmxpc2ggYSBjb25uZWN0aW9uIHRvIHRoZSBwcm94eSBzZXJ2ZXIsXG4gKiBhbmQgdGhlbiB0aGUgcHJveHkgc2VydmVyIGNvbm5lY3RzIHRvIHRoZSBkZXN0aW5hdGlvbiB0YXJnZXQgYW5kIGlzc3VlcyB0aGVcbiAqIEhUVFAgcmVxdWVzdCBmcm9tIHRoZSBwcm94eSBzZXJ2ZXIuXG4gKlxuICogYGh0dHBzOmAgcmVxdWVzdHMgaGF2ZSB0aGVpciBzb2NrZXQgY29ubmVjdGlvbiB1cGdyYWRlZCB0byBUTFMgb25jZVxuICogdGhlIGNvbm5lY3Rpb24gdG8gdGhlIHByb3h5IHNlcnZlciBoYXMgYmVlbiBlc3RhYmxpc2hlZC5cbiAqL1xuY2xhc3MgSHR0cHNQcm94eUFnZW50IGV4dGVuZHMgYWdlbnRfYmFzZV8xLkFnZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihwcm94eSwgb3B0cykge1xuICAgICAgICBzdXBlcihvcHRzKTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0geyBwYXRoOiB1bmRlZmluZWQgfTtcbiAgICAgICAgdGhpcy5wcm94eSA9IHR5cGVvZiBwcm94eSA9PT0gJ3N0cmluZycgPyBuZXcgdXJsXzEuVVJMKHByb3h5KSA6IHByb3h5O1xuICAgICAgICB0aGlzLnByb3h5SGVhZGVycyA9IG9wdHM/LmhlYWRlcnMgPz8ge307XG4gICAgICAgIGRlYnVnKCdDcmVhdGluZyBuZXcgSHR0cHNQcm94eUFnZW50IGluc3RhbmNlOiAlbycsIHRoaXMucHJveHkuaHJlZik7XG4gICAgICAgIC8vIFRyaW0gb2ZmIHRoZSBicmFja2V0cyBmcm9tIElQdjYgYWRkcmVzc2VzXG4gICAgICAgIGNvbnN0IGhvc3QgPSAodGhpcy5wcm94eS5ob3N0bmFtZSB8fCB0aGlzLnByb3h5Lmhvc3QpLnJlcGxhY2UoL15cXFt8XFxdJC9nLCAnJyk7XG4gICAgICAgIGNvbnN0IHBvcnQgPSB0aGlzLnByb3h5LnBvcnRcbiAgICAgICAgICAgID8gcGFyc2VJbnQodGhpcy5wcm94eS5wb3J0LCAxMClcbiAgICAgICAgICAgIDogdGhpcy5wcm94eS5wcm90b2NvbCA9PT0gJ2h0dHBzOidcbiAgICAgICAgICAgICAgICA/IDQ0M1xuICAgICAgICAgICAgICAgIDogODA7XG4gICAgICAgIHRoaXMuY29ubmVjdE9wdHMgPSB7XG4gICAgICAgICAgICAvLyBBdHRlbXB0IHRvIG5lZ290aWF0ZSBodHRwLzEuMSBmb3IgcHJveHkgc2VydmVycyB0aGF0IHN1cHBvcnQgaHR0cC8yXG4gICAgICAgICAgICBBTFBOUHJvdG9jb2xzOiBbJ2h0dHAvMS4xJ10sXG4gICAgICAgICAgICAuLi4ob3B0cyA/IG9taXQob3B0cywgJ2hlYWRlcnMnKSA6IG51bGwpLFxuICAgICAgICAgICAgaG9zdCxcbiAgICAgICAgICAgIHBvcnQsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuIHRoZSBub2RlLWNvcmUgSFRUUCBjbGllbnQgbGlicmFyeSBpcyBjcmVhdGluZyBhXG4gICAgICogbmV3IEhUVFAgcmVxdWVzdC5cbiAgICAgKi9cbiAgICBhc3luYyBjb25uZWN0KHJlcSwgb3B0cykge1xuICAgICAgICBjb25zdCB7IHByb3h5IH0gPSB0aGlzO1xuICAgICAgICBpZiAoIW9wdHMuaG9zdCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTm8gXCJob3N0XCIgcHJvdmlkZWQnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDcmVhdGUgYSBzb2NrZXQgY29ubmVjdGlvbiB0byB0aGUgcHJveHkgc2VydmVyLlxuICAgICAgICBsZXQgc29ja2V0O1xuICAgICAgICBpZiAocHJveHkucHJvdG9jb2wgPT09ICdodHRwczonKSB7XG4gICAgICAgICAgICBkZWJ1ZygnQ3JlYXRpbmcgYHRscy5Tb2NrZXRgOiAlbycsIHRoaXMuY29ubmVjdE9wdHMpO1xuICAgICAgICAgICAgc29ja2V0ID0gdGxzLmNvbm5lY3Qoc2V0U2VydmVybmFtZUZyb21Ob25JcEhvc3QodGhpcy5jb25uZWN0T3B0cykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVidWcoJ0NyZWF0aW5nIGBuZXQuU29ja2V0YDogJW8nLCB0aGlzLmNvbm5lY3RPcHRzKTtcbiAgICAgICAgICAgIHNvY2tldCA9IG5ldC5jb25uZWN0KHRoaXMuY29ubmVjdE9wdHMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSB0eXBlb2YgdGhpcy5wcm94eUhlYWRlcnMgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgID8gdGhpcy5wcm94eUhlYWRlcnMoKVxuICAgICAgICAgICAgOiB7IC4uLnRoaXMucHJveHlIZWFkZXJzIH07XG4gICAgICAgIGNvbnN0IGhvc3QgPSBuZXQuaXNJUHY2KG9wdHMuaG9zdCkgPyBgWyR7b3B0cy5ob3N0fV1gIDogb3B0cy5ob3N0O1xuICAgICAgICBsZXQgcGF5bG9hZCA9IGBDT05ORUNUICR7aG9zdH06JHtvcHRzLnBvcnR9IEhUVFAvMS4xXFxyXFxuYDtcbiAgICAgICAgLy8gSW5qZWN0IHRoZSBgUHJveHktQXV0aG9yaXphdGlvbmAgaGVhZGVyIGlmIG5lY2Vzc2FyeS5cbiAgICAgICAgaWYgKHByb3h5LnVzZXJuYW1lIHx8IHByb3h5LnBhc3N3b3JkKSB7XG4gICAgICAgICAgICBjb25zdCBhdXRoID0gYCR7ZGVjb2RlVVJJQ29tcG9uZW50KHByb3h5LnVzZXJuYW1lKX06JHtkZWNvZGVVUklDb21wb25lbnQocHJveHkucGFzc3dvcmQpfWA7XG4gICAgICAgICAgICBoZWFkZXJzWydQcm94eS1BdXRob3JpemF0aW9uJ10gPSBgQmFzaWMgJHtCdWZmZXIuZnJvbShhdXRoKS50b1N0cmluZygnYmFzZTY0Jyl9YDtcbiAgICAgICAgfVxuICAgICAgICBoZWFkZXJzLkhvc3QgPSBgJHtob3N0fToke29wdHMucG9ydH1gO1xuICAgICAgICBpZiAoIWhlYWRlcnNbJ1Byb3h5LUNvbm5lY3Rpb24nXSkge1xuICAgICAgICAgICAgaGVhZGVyc1snUHJveHktQ29ubmVjdGlvbiddID0gdGhpcy5rZWVwQWxpdmVcbiAgICAgICAgICAgICAgICA/ICdLZWVwLUFsaXZlJ1xuICAgICAgICAgICAgICAgIDogJ2Nsb3NlJztcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgb2YgT2JqZWN0LmtleXMoaGVhZGVycykpIHtcbiAgICAgICAgICAgIHBheWxvYWQgKz0gYCR7bmFtZX06ICR7aGVhZGVyc1tuYW1lXX1cXHJcXG5gO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByb3h5UmVzcG9uc2VQcm9taXNlID0gKDAsIHBhcnNlX3Byb3h5X3Jlc3BvbnNlXzEucGFyc2VQcm94eVJlc3BvbnNlKShzb2NrZXQpO1xuICAgICAgICBzb2NrZXQud3JpdGUoYCR7cGF5bG9hZH1cXHJcXG5gKTtcbiAgICAgICAgY29uc3QgeyBjb25uZWN0LCBidWZmZXJlZCB9ID0gYXdhaXQgcHJveHlSZXNwb25zZVByb21pc2U7XG4gICAgICAgIHJlcS5lbWl0KCdwcm94eUNvbm5lY3QnLCBjb25uZWN0KTtcbiAgICAgICAgdGhpcy5lbWl0KCdwcm94eUNvbm5lY3QnLCBjb25uZWN0LCByZXEpO1xuICAgICAgICBpZiAoY29ubmVjdC5zdGF0dXNDb2RlID09PSAyMDApIHtcbiAgICAgICAgICAgIHJlcS5vbmNlKCdzb2NrZXQnLCByZXN1bWUpO1xuICAgICAgICAgICAgaWYgKG9wdHMuc2VjdXJlRW5kcG9pbnQpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgcHJveHkgaXMgY29ubmVjdGluZyB0byBhIFRMUyBzZXJ2ZXIsIHNvIHVwZ3JhZGVcbiAgICAgICAgICAgICAgICAvLyB0aGlzIHNvY2tldCBjb25uZWN0aW9uIHRvIGEgVExTIGNvbm5lY3Rpb24uXG4gICAgICAgICAgICAgICAgZGVidWcoJ1VwZ3JhZGluZyBzb2NrZXQgY29ubmVjdGlvbiB0byBUTFMnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGxzLmNvbm5lY3Qoe1xuICAgICAgICAgICAgICAgICAgICAuLi5vbWl0KHNldFNlcnZlcm5hbWVGcm9tTm9uSXBIb3N0KG9wdHMpLCAnaG9zdCcsICdwYXRoJywgJ3BvcnQnKSxcbiAgICAgICAgICAgICAgICAgICAgc29ja2V0LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNvY2tldDtcbiAgICAgICAgfVxuICAgICAgICAvLyBTb21lIG90aGVyIHN0YXR1cyBjb2RlIHRoYXQncyBub3QgMjAwLi4uIG5lZWQgdG8gcmUtcGxheSB0aGUgSFRUUFxuICAgICAgICAvLyBoZWFkZXIgXCJkYXRhXCIgZXZlbnRzIG9udG8gdGhlIHNvY2tldCBvbmNlIHRoZSBIVFRQIG1hY2hpbmVyeSBpc1xuICAgICAgICAvLyBhdHRhY2hlZCBzbyB0aGF0IHRoZSBub2RlIGNvcmUgYGh0dHBgIGNhbiBwYXJzZSBhbmQgaGFuZGxlIHRoZVxuICAgICAgICAvLyBlcnJvciBzdGF0dXMgY29kZS5cbiAgICAgICAgLy8gQ2xvc2UgdGhlIG9yaWdpbmFsIHNvY2tldCwgYW5kIGEgbmV3IFwiZmFrZVwiIHNvY2tldCBpcyByZXR1cm5lZFxuICAgICAgICAvLyBpbnN0ZWFkLCBzbyB0aGF0IHRoZSBwcm94eSBkb2Vzbid0IGdldCB0aGUgSFRUUCByZXF1ZXN0XG4gICAgICAgIC8vIHdyaXR0ZW4gdG8gaXQgKHdoaWNoIG1heSBjb250YWluIGBBdXRob3JpemF0aW9uYCBoZWFkZXJzIG9yIG90aGVyXG4gICAgICAgIC8vIHNlbnNpdGl2ZSBkYXRhKS5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gU2VlOiBodHRwczovL2hhY2tlcm9uZS5jb20vcmVwb3J0cy81NDE1MDJcbiAgICAgICAgc29ja2V0LmRlc3Ryb3koKTtcbiAgICAgICAgY29uc3QgZmFrZVNvY2tldCA9IG5ldyBuZXQuU29ja2V0KHsgd3JpdGFibGU6IGZhbHNlIH0pO1xuICAgICAgICBmYWtlU29ja2V0LnJlYWRhYmxlID0gdHJ1ZTtcbiAgICAgICAgLy8gTmVlZCB0byB3YWl0IGZvciB0aGUgXCJzb2NrZXRcIiBldmVudCB0byByZS1wbGF5IHRoZSBcImRhdGFcIiBldmVudHMuXG4gICAgICAgIHJlcS5vbmNlKCdzb2NrZXQnLCAocykgPT4ge1xuICAgICAgICAgICAgZGVidWcoJ1JlcGxheWluZyBwcm94eSBidWZmZXIgZm9yIGZhaWxlZCByZXF1ZXN0Jyk7XG4gICAgICAgICAgICAoMCwgYXNzZXJ0XzEuZGVmYXVsdCkocy5saXN0ZW5lckNvdW50KCdkYXRhJykgPiAwKTtcbiAgICAgICAgICAgIC8vIFJlcGxheSB0aGUgXCJidWZmZXJlZFwiIEJ1ZmZlciBvbnRvIHRoZSBmYWtlIGBzb2NrZXRgLCBzaW5jZSBhdFxuICAgICAgICAgICAgLy8gdGhpcyBwb2ludCB0aGUgSFRUUCBtb2R1bGUgbWFjaGluZXJ5IGhhcyBiZWVuIGhvb2tlZCB1cCBmb3JcbiAgICAgICAgICAgIC8vIHRoZSB1c2VyLlxuICAgICAgICAgICAgcy5wdXNoKGJ1ZmZlcmVkKTtcbiAgICAgICAgICAgIHMucHVzaChudWxsKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmYWtlU29ja2V0O1xuICAgIH1cbn1cbkh0dHBzUHJveHlBZ2VudC5wcm90b2NvbHMgPSBbJ2h0dHAnLCAnaHR0cHMnXTtcbmV4cG9ydHMuSHR0cHNQcm94eUFnZW50ID0gSHR0cHNQcm94eUFnZW50O1xuZnVuY3Rpb24gcmVzdW1lKHNvY2tldCkge1xuICAgIHNvY2tldC5yZXN1bWUoKTtcbn1cbmZ1bmN0aW9uIG9taXQob2JqLCAuLi5rZXlzKSB7XG4gICAgY29uc3QgcmV0ID0ge307XG4gICAgbGV0IGtleTtcbiAgICBmb3IgKGtleSBpbiBvYmopIHtcbiAgICAgICAgaWYgKCFrZXlzLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgIHJldFtrZXldID0gb2JqW2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@distube/ytdl-core/node_modules/https-proxy-agent/dist/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@distube/ytdl-core/node_modules/https-proxy-agent/dist/parse-proxy-response.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/@distube/ytdl-core/node_modules/https-proxy-agent/dist/parse-proxy-response.js ***!
  \*****************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.parseProxyResponse = void 0;\nconst debug_1 = __importDefault(__webpack_require__(/*! debug */ \"(rsc)/./node_modules/debug/src/index.js\"));\nconst debug = (0, debug_1.default)('https-proxy-agent:parse-proxy-response');\nfunction parseProxyResponse(socket) {\n    return new Promise((resolve, reject) => {\n        // we need to buffer any HTTP traffic that happens with the proxy before we get\n        // the CONNECT response, so that if the response is anything other than an \"200\"\n        // response code, then we can re-play the \"data\" events on the socket once the\n        // HTTP parser is hooked up...\n        let buffersLength = 0;\n        const buffers = [];\n        function read() {\n            const b = socket.read();\n            if (b)\n                ondata(b);\n            else\n                socket.once('readable', read);\n        }\n        function cleanup() {\n            socket.removeListener('end', onend);\n            socket.removeListener('error', onerror);\n            socket.removeListener('readable', read);\n        }\n        function onend() {\n            cleanup();\n            debug('onend');\n            reject(new Error('Proxy connection ended before receiving CONNECT response'));\n        }\n        function onerror(err) {\n            cleanup();\n            debug('onerror %o', err);\n            reject(err);\n        }\n        function ondata(b) {\n            buffers.push(b);\n            buffersLength += b.length;\n            const buffered = Buffer.concat(buffers, buffersLength);\n            const endOfHeaders = buffered.indexOf('\\r\\n\\r\\n');\n            if (endOfHeaders === -1) {\n                // keep buffering\n                debug('have not received end of HTTP headers yet...');\n                read();\n                return;\n            }\n            const headerParts = buffered\n                .slice(0, endOfHeaders)\n                .toString('ascii')\n                .split('\\r\\n');\n            const firstLine = headerParts.shift();\n            if (!firstLine) {\n                socket.destroy();\n                return reject(new Error('No header received from proxy CONNECT response'));\n            }\n            const firstLineParts = firstLine.split(' ');\n            const statusCode = +firstLineParts[1];\n            const statusText = firstLineParts.slice(2).join(' ');\n            const headers = {};\n            for (const header of headerParts) {\n                if (!header)\n                    continue;\n                const firstColon = header.indexOf(':');\n                if (firstColon === -1) {\n                    socket.destroy();\n                    return reject(new Error(`Invalid header from proxy CONNECT response: \"${header}\"`));\n                }\n                const key = header.slice(0, firstColon).toLowerCase();\n                const value = header.slice(firstColon + 1).trimStart();\n                const current = headers[key];\n                if (typeof current === 'string') {\n                    headers[key] = [current, value];\n                }\n                else if (Array.isArray(current)) {\n                    current.push(value);\n                }\n                else {\n                    headers[key] = value;\n                }\n            }\n            debug('got proxy server response: %o %o', firstLine, headers);\n            cleanup();\n            resolve({\n                connect: {\n                    statusCode,\n                    statusText,\n                    headers,\n                },\n                buffered,\n            });\n        }\n        socket.on('error', onerror);\n        socket.on('end', onend);\n        read();\n    });\n}\nexports.parseProxyResponse = parseProxyResponse;\n//# sourceMappingURL=parse-proxy-response.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGRpc3R1YmUveXRkbC1jb3JlL25vZGVfbW9kdWxlcy9odHRwcy1wcm94eS1hZ2VudC9kaXN0L3BhcnNlLXByb3h5LXJlc3BvbnNlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsMEJBQTBCO0FBQzFCLGdDQUFnQyxtQkFBTyxDQUFDLHNEQUFPO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEZBQTRGLE9BQU87QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsMEJBQTBCO0FBQzFCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8veXQtZG93bmxvYWRlci8uL25vZGVfbW9kdWxlcy9AZGlzdHViZS95dGRsLWNvcmUvbm9kZV9tb2R1bGVzL2h0dHBzLXByb3h5LWFnZW50L2Rpc3QvcGFyc2UtcHJveHktcmVzcG9uc2UuanM/YzFlYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucGFyc2VQcm94eVJlc3BvbnNlID0gdm9pZCAwO1xuY29uc3QgZGVidWdfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiZGVidWdcIikpO1xuY29uc3QgZGVidWcgPSAoMCwgZGVidWdfMS5kZWZhdWx0KSgnaHR0cHMtcHJveHktYWdlbnQ6cGFyc2UtcHJveHktcmVzcG9uc2UnKTtcbmZ1bmN0aW9uIHBhcnNlUHJveHlSZXNwb25zZShzb2NrZXQpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAvLyB3ZSBuZWVkIHRvIGJ1ZmZlciBhbnkgSFRUUCB0cmFmZmljIHRoYXQgaGFwcGVucyB3aXRoIHRoZSBwcm94eSBiZWZvcmUgd2UgZ2V0XG4gICAgICAgIC8vIHRoZSBDT05ORUNUIHJlc3BvbnNlLCBzbyB0aGF0IGlmIHRoZSByZXNwb25zZSBpcyBhbnl0aGluZyBvdGhlciB0aGFuIGFuIFwiMjAwXCJcbiAgICAgICAgLy8gcmVzcG9uc2UgY29kZSwgdGhlbiB3ZSBjYW4gcmUtcGxheSB0aGUgXCJkYXRhXCIgZXZlbnRzIG9uIHRoZSBzb2NrZXQgb25jZSB0aGVcbiAgICAgICAgLy8gSFRUUCBwYXJzZXIgaXMgaG9va2VkIHVwLi4uXG4gICAgICAgIGxldCBidWZmZXJzTGVuZ3RoID0gMDtcbiAgICAgICAgY29uc3QgYnVmZmVycyA9IFtdO1xuICAgICAgICBmdW5jdGlvbiByZWFkKCkge1xuICAgICAgICAgICAgY29uc3QgYiA9IHNvY2tldC5yZWFkKCk7XG4gICAgICAgICAgICBpZiAoYilcbiAgICAgICAgICAgICAgICBvbmRhdGEoYik7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgc29ja2V0Lm9uY2UoJ3JlYWRhYmxlJywgcmVhZCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICAgICAgICAgIHNvY2tldC5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xuICAgICAgICAgICAgc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgICAgICAgICAgc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdyZWFkYWJsZScsIHJlYWQpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG9uZW5kKCkge1xuICAgICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICAgICAgZGVidWcoJ29uZW5kJyk7XG4gICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdQcm94eSBjb25uZWN0aW9uIGVuZGVkIGJlZm9yZSByZWNlaXZpbmcgQ09OTkVDVCByZXNwb25zZScpKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBvbmVycm9yKGVycikge1xuICAgICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICAgICAgZGVidWcoJ29uZXJyb3IgJW8nLCBlcnIpO1xuICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gb25kYXRhKGIpIHtcbiAgICAgICAgICAgIGJ1ZmZlcnMucHVzaChiKTtcbiAgICAgICAgICAgIGJ1ZmZlcnNMZW5ndGggKz0gYi5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCBidWZmZXJlZCA9IEJ1ZmZlci5jb25jYXQoYnVmZmVycywgYnVmZmVyc0xlbmd0aCk7XG4gICAgICAgICAgICBjb25zdCBlbmRPZkhlYWRlcnMgPSBidWZmZXJlZC5pbmRleE9mKCdcXHJcXG5cXHJcXG4nKTtcbiAgICAgICAgICAgIGlmIChlbmRPZkhlYWRlcnMgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgLy8ga2VlcCBidWZmZXJpbmdcbiAgICAgICAgICAgICAgICBkZWJ1ZygnaGF2ZSBub3QgcmVjZWl2ZWQgZW5kIG9mIEhUVFAgaGVhZGVycyB5ZXQuLi4nKTtcbiAgICAgICAgICAgICAgICByZWFkKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFydHMgPSBidWZmZXJlZFxuICAgICAgICAgICAgICAgIC5zbGljZSgwLCBlbmRPZkhlYWRlcnMpXG4gICAgICAgICAgICAgICAgLnRvU3RyaW5nKCdhc2NpaScpXG4gICAgICAgICAgICAgICAgLnNwbGl0KCdcXHJcXG4nKTtcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0TGluZSA9IGhlYWRlclBhcnRzLnNoaWZ0KCk7XG4gICAgICAgICAgICBpZiAoIWZpcnN0TGluZSkge1xuICAgICAgICAgICAgICAgIHNvY2tldC5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoJ05vIGhlYWRlciByZWNlaXZlZCBmcm9tIHByb3h5IENPTk5FQ1QgcmVzcG9uc2UnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBmaXJzdExpbmVQYXJ0cyA9IGZpcnN0TGluZS5zcGxpdCgnICcpO1xuICAgICAgICAgICAgY29uc3Qgc3RhdHVzQ29kZSA9ICtmaXJzdExpbmVQYXJ0c1sxXTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXR1c1RleHQgPSBmaXJzdExpbmVQYXJ0cy5zbGljZSgyKS5qb2luKCcgJyk7XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJzID0ge307XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGhlYWRlciBvZiBoZWFkZXJQYXJ0cykge1xuICAgICAgICAgICAgICAgIGlmICghaGVhZGVyKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjb25zdCBmaXJzdENvbG9uID0gaGVhZGVyLmluZGV4T2YoJzonKTtcbiAgICAgICAgICAgICAgICBpZiAoZmlyc3RDb2xvbiA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgc29ja2V0LmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoYEludmFsaWQgaGVhZGVyIGZyb20gcHJveHkgQ09OTkVDVCByZXNwb25zZTogXCIke2hlYWRlcn1cImApKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gaGVhZGVyLnNsaWNlKDAsIGZpcnN0Q29sb24pLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBoZWFkZXIuc2xpY2UoZmlyc3RDb2xvbiArIDEpLnRyaW1TdGFydCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnQgPSBoZWFkZXJzW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjdXJyZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzW2tleV0gPSBbY3VycmVudCwgdmFsdWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGN1cnJlbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWJ1ZygnZ290IHByb3h5IHNlcnZlciByZXNwb25zZTogJW8gJW8nLCBmaXJzdExpbmUsIGhlYWRlcnMpO1xuICAgICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgICAgICAgY29ubmVjdDoge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXNDb2RlLFxuICAgICAgICAgICAgICAgICAgICBzdGF0dXNUZXh0LFxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYnVmZmVyZWQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzb2NrZXQub24oJ2Vycm9yJywgb25lcnJvcik7XG4gICAgICAgIHNvY2tldC5vbignZW5kJywgb25lbmQpO1xuICAgICAgICByZWFkKCk7XG4gICAgfSk7XG59XG5leHBvcnRzLnBhcnNlUHJveHlSZXNwb25zZSA9IHBhcnNlUHJveHlSZXNwb25zZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhcnNlLXByb3h5LXJlc3BvbnNlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@distube/ytdl-core/node_modules/https-proxy-agent/dist/parse-proxy-response.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@distube/ytdl-core/package.json":
/*!******************************************************!*\
  !*** ./node_modules/@distube/ytdl-core/package.json ***!
  \******************************************************/
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"name":"@distube/ytdl-core","description":"DisTube fork of ytdl-core. YouTube video downloader in pure javascript.","keywords":["youtube","video","download","distube"],"version":"4.16.12","repository":{"type":"git","url":"git://github.com/distubejs/ytdl-core.git"},"author":"Skick (https://github.com/skick1234)","contributors":["fent <fentbox@gmail.com> (https://github.com/fent)","Tobias Kutscha (https://github.com/TimeForANinja)","Andrew Kelley (https://github.com/andrewrk)","Mauricio Allende (https://github.com/mallendeo)","Rodrigo Altamirano (https://github.com/raltamirano)","Jim Buck (https://github.com/JimmyBoh)","Pawel Rucinski (https://github.com/Roki100)","Alexander Paolini (https://github.com/Million900o)"],"main":"./lib/index.js","types":"./typings/index.d.ts","files":["lib","typings"],"dependencies":{"http-cookie-agent":"^7.0.1","https-proxy-agent":"^7.0.6","m3u8stream":"^0.8.6","miniget":"^4.2.3","sax":"^1.4.1","tough-cookie":"^5.1.2","undici":"^7.8.0"},"devDependencies":{"@types/node":"^22.15.2","prettier":"^3.5.3","typescript":"^5.8.3"},"engines":{"node":">=20.18.1"},"license":"MIT","funding":"https://github.com/distubejs/ytdl-core?sponsor","scripts":{"prettier":"prettier --write \\"**/*.{js,json,yml,md,ts}\\""}}');

/***/ })

};
;